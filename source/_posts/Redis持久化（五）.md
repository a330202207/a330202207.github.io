---
title: Redis持久化（五）
date: 2017-03-09 06:43:42
tags:
- Redis
categories:
- NoSQL
---
Redis持久化
----------------
`Redis` 为了`内部数据`的`安全考虑`，会把本身的数据以`文件`的形式`保存`到`硬盘中`一份，在服务器`重启`后会`自动`把`硬盘`的数据`恢复`到`内存`(Redis)里面

`Redis持久化`分为：
 - RDB 持久化方式
 - AOF 持久化方式

两种持久化可以同时开启

RDB(Redis DataBase)持久化方式
----------------
`RDB 持久化`是指在`指定的时间间隔内`将`内存中`的`数据`快照`写入磁盘`，实际操作过程是 `fork `一个子进程，先将`数据`写入`临时文件`，写入成功后，再`替换`之前的文件，用二进制压缩存储

![此处输入图片的描述][1]

Redis 将数据库快照保存在名字为 `dump.rdb` 的二进制文件中

![此处输入图片的描述][2]

RDB 持久化快照名称与路径(redis.conf 文件)：

![此处输入图片的描述][3]

RDB持久化备份频率：

![此处输入图片的描述][4]
```
$ save 900 1       #900秒内如果超过1个key被修改，则发起快照保存 
$ save 300 10	  #300秒内如果超过10个key被修改，则发起快照保存 
$ save 60 10000    #60秒内如果超过10000个key被修改，则发起快照保存
```

**优点：**
 1. 非常适合于备份，比如你可以在`每个小时`保存一下过去24小时内的数据，同时`每天保存`过去30天的数据，这样即使出了问题你也可以根据需求`恢复`到`不同版本`的数据
 2. 很方便传送到远端数据中心，非常适用于`灾难恢复`
 3. `RDB` 在保存 `RDB` 文件时`父进程`唯一需要做的就是 `fork` 出一个子进程，接下来的工作全部由`子进程`来做，父进程不需要再做其他 `IO` 操作，所以 `RDB` 持久化方式可以最大化 `Redis` 的性能
 4.与 `AOF` 相比，在恢复大的数据的时候，`RDB` 效率更高


**缺点：**

 1. 如果你想保证数据的`高可用性`，即`最大限度`的`避免数据丢失`，那么 `RDB` 将不是一个很好的选择。因为系统一旦在定时持久化之前出现`宕机现象`，你可能会`丢失几分钟的数据`
 2. 由于 `RDB` 是通过 `fork`子进程来协助完成数据持久化工作的，因此，如果当`数据较大`时，可能会导致整个服务器`停止`服务`几百毫秒`，甚至是`1秒钟`

手动发起RDB持久化方式：
输入 `save` 

![此处输入图片的描述][5]

或者 `bgsave` (bgsave 是开启单独线程) 

![此处输入图片的描述][6]

AOF(Append Only File)持久化方式
----------------
`AOF 持久化`以日志的形式记录服务器所处理的`每一个写、删除操作，查询操作`，当服务器`重启`的时候会`重新执行`这些命令来`恢复`原始的数据

![此处输入图片的描述][7]


开启 `AOF` 持久化(redis.conf)

![此处输入图片的描述][8]

`注：`重启 Redis 才生效

![此处输入图片的描述][9]

AOF 持久化名称与路径：

![此处输入图片的描述][10]

AOF 持久化备份频率：

![此处输入图片的描述][11]
```
# 每次有新命令追加到 AOF 文件时就执行一次同步 ：非常慢，也非常安全
$ always 

# 每秒同步一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据
# 推荐（并且也是默认）的措施为每秒同步一次， 这种策略可以兼顾速度和安全性
$ everysec

# 从不同步：将数据交给操作系统来处理。更快，也更不安全的选择
$ no
```

AOF 持久化备份优化:
因为 `AOF` 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， `AOF` 文件的体积也会变得越来越大
例如， 如果你对一个计数器调用了 `100` 次 `INCR` ， 那么仅仅是为了保存这个计数器的当前值， `AOF` 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 `SET` 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的

输入 `bgrewriteaof` 命令优化 `AOF` 文件
![此处输入图片的描述][12]

AOF 文件损坏：
服务器可能在程序正在对 `AOF` 文件进行写入时`宕机`， 宕机会造成了 `AOF` 文件出错（corrupt）， 那么 `Redis` 在重启时会`拒绝载入`这个 `AOF` 文件， 从而确保`数据`的`一致性`不会被破坏。

修复出错的 `AOF` 文件：

 - 为现有的 `AOF` 文件创建一个备份
 - 使用 `Redis` 附带的 `redis-check-aof` 程序，对`原来的 AOF` 文件进行修复：
 ```
 $ redis-check-aof –fix 
 ```
 - 使用 `diff -u` 对比`修复后的 AOF` 文件和`原始 AOF` 文件的备份，`查看`两个文件之间的`不同`之处
 - `重启 Redis` 服务器，等待服务器载入`修复后的 AOF` 文件，并进行`数据恢复`

**优点：**

 1.  `AOF` 持久化可以带来更高的数据安全性。`Redis` 中提供了`3种`同步策略，即`每秒同步`、`每修改同步`和`不同步`。使用默认的`每秒同步`其效率也是非常高的(同步是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，你`最多丢失1秒`的数据
 2.  `AOF` 文件是一个只进行`追加`的日志文件，所以不需要写入 `seek`，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 `redis-check-aof` 工具修复这些问题
 3.  `Redis` 可以在 `AOF` 文件体积变得过大时，自动地在后台对 `AOF` 进行重写： 重写后的`新 AOF` 文件包含了`恢复当前数据`所需的最小命令集合。 整个重写操作是`绝对安全`的，因为 `Redis` 在创建新 `AOF` 文件的过程中，会继续将命令`追加`到现有的 `AOF` 文件里面，即使`重写过程中发生宕机`，`现有的 AOF` 文件也不会丢失。 而一旦`新 AOF` 文件创建完毕，`Redis` 就会从`旧 AOF` 文件切换到`新 AOF` 文件，并开始对`新 AOF` 文件进行`追加`操作
 4.  `AOF` 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 `Redis` 协议的格式保存， 因此 `AOF` 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） `AOF` 文件也非常简单： 举个例子， 如果你不小心执行了 `FLUSHALL` 命令， 但只要 `AOF` 文件未被重写， 那么只要停止服务器， 移除 `AOF` 文件末尾的 `FLUSHALL` 命令， 并重启 `Redis` ， 就可以将数据集恢复到 `FLUSHALL` 执行之前的状态

**缺点：**

 1. 对于`相同`的数据来说，`AOF` 文件通常要大于 `RDB` 文件
 2. 根据`同步策略`的`不同`，`AOF` 的`运行效率`可能会慢于 `RDB` 。总之，`每秒同步`策略的效率是比较高的，`同步禁用`策略的效率和 `RDB` 一样高效。不过在处理`巨大的写入载入`时，`RDB` 可以提供更有保证的最大延迟时间（latency）

从RDB方式切换为AOF方式
----------------
在 `Redis 2.2` 或以上版本，可以在`不重启`的情况下，从 `RDB` 切换到 `AOF` ：

 - 为最新的 dump.rdb 文件创建一个备份
 - 将备份放到一个安全的地方
 - 执行以下两条命令：
```
# 开启 AOF 功能，Redis 会阻塞直到初始 AOF 文件创建完成为止 
# 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾
$ redis-cli config set appendonly yes
# 关闭 RDB 功能
$ redis-cli config set save

```
 - 确保`写命令`会被`正确`地`追加`到 `AOF` 文件的末尾
`注：` 在`redis.conf` 中打开 `AOF` 功能，否则服务器重启之后， 之前通过 `CONFIG SET` 设置的配置就会被`遗忘`， 程序会按`原来`的`配置`来`启动`服务器。

总结：
----------------

 - 如果你对`数据安全性非常重视`的话，你应该同时使用`两种持久化`功能
 - 如果你承受`数分钟以内的数据丢失`，你可以只使用 `RDB 持久化`

二者选择的标准，就是看是否愿意牺牲`一些性能`，换取更高的`缓存一致性`（AOF），还是愿意`写`操作`频繁`的时候，`不启用备份`来换取`更高的性能`，待手动运行 `save` 的时候，再做备份（RDB）。
`注：` 未来 `Redis` 可能会将 `AOF` 和 `RDB` 整合成`单个持久化模型`.


----------
**相关文档：**
英文：https://redis.io/topics/persistence
中文：http://www.redis.cn/topics/persistence.html


----------

**相关链接：**
[Linux下PHP安装Redis扩展（二） ][13]
[Redis主从配置（三）][14]
[Redis集群搭建与简单使用（四）][15]


  [1]: http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-1.png
  [2]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-1.png
  [3]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-2.png
  [4]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-3.png
  [5]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-4.png
  [6]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-5.png
  [7]: http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-2.png
  [8]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-7.png
  [9]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-8.png
  [10]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-9.png
  [11]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-10.png
  [12]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-11.png
  [13]: https://segmentfault.com/a/1190000008420258
  [14]: https://segmentfault.com/a/1190000008469182
  [15]: https://segmentfault.com/a/1190000008448919