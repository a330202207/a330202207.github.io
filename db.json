{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Tinnypp/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/css/多说自定义.css","path":"css/多说自定义.css","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/img/blueprint-dark.png","path":"img/blueprint-dark.png","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/img/dots-2x.png","path":"img/dots-2x.png","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/js/embed.js","path":"js/embed.js","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/js/jquery-2.1.0.min.js","path":"js/jquery-2.1.0.min.js","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/Tinnypp/source/img/myLogo.png","path":"img/myLogo.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/Tinnypp/.gitignore","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1514946767682},{"_id":"themes/Tinnypp/README.md","hash":"85b391d4be7da28e00899eee7a819274a1da4258","modified":1514946582563},{"_id":"themes/Tinnypp/_config.yml","hash":"7a51f0348438b75215b9cec590716cfd39112eac","modified":1515032464073},{"_id":"themes/Tinnypp/package.json","hash":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1514946582660},{"_id":"source/_posts/CentOS-7-安装-LNMP-环境（PHP7-MySQL5-7-Nginx1-10）.md","hash":"0136ab9a73f2fc5aa77a75dd706ad1e8ca6e4e07","modified":1515034331745},{"_id":"source/_posts/CentOS下三种PHP拓展安装方法.md","hash":"0b8ea94d4288eb588552d8e5e2d4f900196ef897","modified":1514945107979},{"_id":"source/_posts/CentOS更改yum源与更新系统.md","hash":"baa9da9e30556df1fe21ec2559364dc66cfdaf6c","modified":1515029861111},{"_id":"source/_posts/Git的简单命令.md","hash":"bf30c065117eed3cd4fa0b0c065fae47c9de4afd","modified":1514945107984},{"_id":"source/_posts/Linux-CentOS-下安装Redis（一）.md","hash":"c1785265b89a0a973fc24043825b142c90ed4770","modified":1515034447523},{"_id":"source/_posts/Linux下PHP安装Redis扩展（二）.md","hash":"18748ebd008098570d71b680bbf90a8c2270686f","modified":1515034447495},{"_id":"source/_posts/Linux下定时备份Mysql数据库.md","hash":"47a0254f47222a3d13496ae2d2cc483b63d76c0a","modified":1515033497429},{"_id":"source/_posts/MongoDB 简单介绍以及安装(一).md","hash":"196627096677b64d729fc07c31dcfdf25bb8838c","modified":1515033233841},{"_id":"source/_posts/MongoDB-的基本命令（二）.md","hash":"be2546d441b82c3a1d3a0decffab52179c7579b3","modified":1515029861132},{"_id":"source/_posts/MongoDB-的常用操作（三）.md","hash":"bbd31f523ecd53cac6f4f12fc09fcaad740a23f8","modified":1515029861136},{"_id":"source/_posts/MongoDB的索引(四).md","hash":"c27b7abb3bb79189a531e27e403597a279955405","modified":1515029861141},{"_id":"source/_posts/MySQL5-7-主从复制配置.md","hash":"864bced1239d17aa77078490bf99dda55f024139","modified":1514947036850},{"_id":"source/_posts/PHP中的自动加载.md","hash":"62c1d620681c9218f5e3d6ff0cf37b24489e2540","modified":1514945108002},{"_id":"source/_posts/PHP多维数组去重.md","hash":"eac3ced28806e2f3807d51de94b576fa6843af4a","modified":1515029861145},{"_id":"source/_posts/PHP汉字转拼音.md","hash":"0b895960d717194b496aa397e019e18a0d7f4408","modified":1515029861148},{"_id":"source/_posts/PHP知识结构图.md","hash":"4dd816378bb5bd1edfc168ddb4a1983ca144d030","modified":1515029861152},{"_id":"source/_posts/PHP高效导出Excel-CSV.md","hash":"0643c29e4313e931bf8b8c2898dba8e0a9f7807e","modified":1515029861156},{"_id":"source/_posts/PhpStorm-中简单使用-PHP-CodeSniffer-规范-PHP-代码-Windows.md","hash":"ff912cade4b2cb3fc8dbae91f3496108d602322e","modified":1514945108006},{"_id":"source/_posts/Redis主从配置（三）.md","hash":"ea08c6e20d24ed925c51b302bfd26b2d34a02e65","modified":1515029861159},{"_id":"source/_posts/Redis持久化（五）.md","hash":"9cb6b64633309b66a91af5135e7c80dd0a34a2df","modified":1515029861163},{"_id":"source/_posts/Redis集群搭建与简单使用（四）.md","hash":"915d39f174c07d9f30250c83fffae7a6aa62724a","modified":1515029861168},{"_id":"source/_posts/Sublime一些问题的解决方法.md","hash":"d992f52a2dacd4b2f64793cc257c32489258a169","modified":1515029861173},{"_id":"source/_posts/hello-world.md","hash":"c9f2c8c0bd3452fe1a61545d42394e580e29f2f6","modified":1515029861178},{"_id":"source/_posts/yum-简单介绍.md","hash":"024fe7b02e22fe1e4aa712e66ff40518d74fdcbe","modified":1514947036829},{"_id":"source/_posts/什么是Trait-性状-？.md","hash":"4a07dccea79bb2b498b53cefcc1223ad29279edf","modified":1515029861183},{"_id":"source/_posts/什么是接口？.md","hash":"6cc22abb31cfdaad6a51b749d76e0ef5a119f5d8","modified":1515029861187},{"_id":"source/_posts/推荐一款好用的LNMP、LAMP、LANMP一键安装脚本-Linxu.md","hash":"325d4e7ddc83c76e111b10c5fff55b989d5b2f1e","modified":1515033343995},{"_id":"source/_posts/整理一个自己知识体系.md","hash":"072ae48761295b386d3e55359621afd9eec2b8c4","modified":1515029861196},{"_id":"source/_posts/解决向github提交代码不用输入帐号密码.md","hash":"1867d135d0f47ef6a03a331015deff113802804b","modified":1514945108030},{"_id":"themes/Tinnypp/languages/default.yml","hash":"19935fd15f0ba067d5355ceaff0d4b17a1cdfeb3","modified":1514946582569},{"_id":"themes/Tinnypp/languages/zh-CN.yml","hash":"b100c69a085fce4c85422507390b1d2acb15c2f7","modified":1514946582571},{"_id":"themes/Tinnypp/languages/zh-TW.yml","hash":"d00740d05b70e4ef469662d594ae17252d7ea5a7","modified":1514946582574},{"_id":"themes/Tinnypp/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1514946582648},{"_id":"themes/Tinnypp/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1514946582649},{"_id":"themes/Tinnypp/layout/index.ejs","hash":"7c247133b47686768764dcc883908b3c752d3f8c","modified":1514946582651},{"_id":"themes/Tinnypp/layout/layout.ejs","hash":"b6e59993e4427326136beaf36422a924a769c5dc","modified":1514946582653},{"_id":"themes/Tinnypp/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1514946582655},{"_id":"themes/Tinnypp/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1514946582657},{"_id":"themes/Tinnypp/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1514946582658},{"_id":"themes/Tinnypp/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1514946582663},{"_id":"themes/Tinnypp/scripts/highlight.pack.js","hash":"0813d386edbe80ee9a47391564002ad52a50c039","modified":1514946582665},{"_id":"themes/Tinnypp/layout/_partial/after_footer.ejs","hash":"f1c893461b5ae59c436a9599e2e0e0ea23f32478","modified":1514946582579},{"_id":"themes/Tinnypp/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1514946582582},{"_id":"themes/Tinnypp/layout/_partial/article.ejs","hash":"19638d0ef2b90b55d04c403fff6ada623165ba36","modified":1514946582586},{"_id":"themes/Tinnypp/layout/_partial/archive.ejs","hash":"fe03fa81bb8dfa7a618853d8f47c4d7991783734","modified":1514946582584},{"_id":"themes/Tinnypp/layout/_partial/categories.ejs","hash":"b6e67d3b777a2a8125a0d58541a4d2c2f259a92a","modified":1514946582588},{"_id":"themes/Tinnypp/layout/_partial/footer.ejs","hash":"a73adfbcf3c3d6fa488ddabe42805a7d54273d75","modified":1514946582590},{"_id":"themes/Tinnypp/layout/_partial/google_analytics.ejs","hash":"7ebccafcfdaca5cb5b8f4f06548f1d50958726ef","modified":1514946582595},{"_id":"themes/Tinnypp/layout/_partial/head.ejs","hash":"9120fccff325577b1a2785d7645b9921cb90badc","modified":1514946582597},{"_id":"themes/Tinnypp/layout/_partial/header.ejs","hash":"26486dfc6f1e24be2abaa82446b417eb16ac8bb6","modified":1514946582599},{"_id":"themes/Tinnypp/layout/_partial/mobile-nav.ejs","hash":"7907a34f30f33ccb66c814539c90c5f6c02b5331","modified":1514946582601},{"_id":"themes/Tinnypp/layout/_partial/pagination.ejs","hash":"6cf37f844f150af4bbe212610da61e5140317de9","modified":1514946582603},{"_id":"themes/Tinnypp/layout/_partial/search.ejs","hash":"21b3ca7c5934c4ec4064af72a21aad9a4bb900e3","modified":1514946582623},{"_id":"themes/Tinnypp/layout/_partial/sidebar.ejs","hash":"d8ac1a578845d4204506a929793d4a1460b18247","modified":1514946582625},{"_id":"themes/Tinnypp/layout/_partial/tags.ejs","hash":"c5c858742b29e6364da2e1d098e7d6cd8cef038f","modified":1514946582627},{"_id":"themes/Tinnypp/layout/_partial/toc.ejs","hash":"379b55d5e1c2af23ff936def8d43f3f5d9920efe","modified":1514946582629},{"_id":"themes/Tinnypp/layout/_widget/archive.ejs","hash":"b82d7fb0d1119738a9f9bb747d415e8c99e454ae","modified":1514946582633},{"_id":"themes/Tinnypp/layout/_widget/author.ejs","hash":"ab647b97f55e550af54598dee0c4bb132ef43c46","modified":1514946582635},{"_id":"themes/Tinnypp/layout/_widget/category.ejs","hash":"ab647b97f55e550af54598dee0c4bb132ef43c46","modified":1514946582637},{"_id":"themes/Tinnypp/layout/_widget/links.ejs","hash":"68ae29594b5df094612c4f7c8ab9068ced112495","modified":1514946582639},{"_id":"themes/Tinnypp/layout/_widget/recent_posts.ejs","hash":"267c34c67abf0ca71bd0736268f39778b52d5e0c","modified":1514946582641},{"_id":"themes/Tinnypp/layout/_widget/rss.ejs","hash":"ebfb11bdd603cd6e4dcf3949cc52e38009615c25","modified":1514946582642},{"_id":"themes/Tinnypp/layout/_widget/tag.ejs","hash":"b994f8c43b190b852568e355944d5af151dcefe6","modified":1514946582644},{"_id":"themes/Tinnypp/layout/_widget/tagcloud.ejs","hash":"317d420f5448c7452290e37f0ed8516cb73f4068","modified":1514946582646},{"_id":"themes/Tinnypp/source/css/font-awesome.min.css","hash":"2ad9b14b0f69436cfbd3cb8f46aaad6ecf742269","modified":1514946582699},{"_id":"themes/Tinnypp/source/css/style.styl","hash":"60f734e92e9a7900f4e355b2ff8488107fe375fb","modified":1514946582701},{"_id":"themes/Tinnypp/source/css/多说自定义.css","hash":"0f85feb8799a91a87801ea77600cd66d1cba0b30","modified":1514946582703},{"_id":"themes/Tinnypp/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1514946582706},{"_id":"themes/Tinnypp/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1514946582708},{"_id":"themes/Tinnypp/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1514946582710},{"_id":"themes/Tinnypp/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1514946582711},{"_id":"themes/Tinnypp/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1514946582713},{"_id":"themes/Tinnypp/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1514946582716},{"_id":"themes/Tinnypp/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1514946582729},{"_id":"themes/Tinnypp/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1514946582731},{"_id":"themes/Tinnypp/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1514946582733},{"_id":"themes/Tinnypp/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1514946582737},{"_id":"themes/Tinnypp/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1514946582739},{"_id":"themes/Tinnypp/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1514946582744},{"_id":"themes/Tinnypp/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1514946582747},{"_id":"themes/Tinnypp/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1514946582749},{"_id":"themes/Tinnypp/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1514946582757},{"_id":"themes/Tinnypp/source/img/blueprint-dark.png","hash":"fe154fcccb513b9626048e45f835da99e4e134b8","modified":1514946582760},{"_id":"themes/Tinnypp/source/img/dots-2x.png","hash":"2d900f9f8a0b53067401138d8cb411c83e747e8e","modified":1514946582761},{"_id":"themes/Tinnypp/source/img/favicon.ico","hash":"279150a15a1b6a9fa370b70a89e3dd621a68b500","modified":1514902544818},{"_id":"themes/Tinnypp/source/img/logo.svg","hash":"cef3f0bb4bf3661dd3a58c81b9a7be79601a0bfb","modified":1514946582765},{"_id":"themes/Tinnypp/source/font/coveredbyyourgrace-webfont.svg","hash":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1514946582741},{"_id":"themes/Tinnypp/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1514946582755},{"_id":"themes/Tinnypp/source/js/embed.js","hash":"c04df21ee3f2963a65d415ccdb9112a79f6d0927","modified":1514946582770},{"_id":"themes/Tinnypp/source/js/jquery-2.1.0.min.js","hash":"0faaa0c56f563693cdeafa299f97e3d5bd6fcdd8","modified":1514946582772},{"_id":"themes/Tinnypp/layout/_partial/post/article.ejs","hash":"07c47aaa2d370d624f5becccf5b78f261a7efbdc","modified":1514946582606},{"_id":"themes/Tinnypp/layout/_partial/post/catetags.ejs","hash":"fa03892b35dc344de7a722b9393978286c0376fe","modified":1514946582608},{"_id":"themes/Tinnypp/layout/_partial/post/comment.ejs","hash":"34f2670b9ec160b0cf46d1262d57484802eb4b30","modified":1514946582610},{"_id":"themes/Tinnypp/layout/_partial/post/footer.ejs","hash":"a4dc14cd47d22f1b73860bc3c7f424eae3d282dd","modified":1514946582612},{"_id":"themes/Tinnypp/layout/_partial/post/gallery.ejs","hash":"6bd8723f24b192158e6e840bf14028503ad50045","modified":1514946582614},{"_id":"themes/Tinnypp/layout/_partial/post/header.ejs","hash":"a7ed2c6cf87deae595bfb85a95cbd282ba2bb71b","modified":1514946582616},{"_id":"themes/Tinnypp/layout/_partial/post/jiathis.ejs","hash":"5043a5058887cf6ad15182cfde345d36cb6ab323","modified":1514946582618},{"_id":"themes/Tinnypp/layout/_partial/post/pagination.ejs","hash":"69612e9daa4b32e61050cf820d61e520600f6c1c","modified":1514946582620},{"_id":"themes/Tinnypp/source/css/_base/code.styl","hash":"09da5216f0bb37b7a1ff7265a2862f0d2dbbe2d2","modified":1514946582670},{"_id":"themes/Tinnypp/source/css/_base/font.styl","hash":"772749cc7c6a47410bb667f8127b37767d029283","modified":1514946582672},{"_id":"themes/Tinnypp/source/css/_base/public.styl","hash":"e2d4eb2645091b8210b3656e12803f0195f91249","modified":1514946582675},{"_id":"themes/Tinnypp/source/css/_base/variable.styl","hash":"465a2718f7c0432958bdd431ffc0376c3dfb3acc","modified":1514946582677},{"_id":"themes/Tinnypp/source/css/_partial/addByMe.styl","hash":"59b77aef57ab13547618f58243c216861be59b6a","modified":1514946582680},{"_id":"themes/Tinnypp/source/css/_partial/article.styl","hash":"5230d866da7dbff9a4ab83cef6f6d511982c7d13","modified":1514946582682},{"_id":"themes/Tinnypp/source/css/_partial/aside.styl","hash":"46631da20e6f05b8ae54c5da757265c0c4bf96b7","modified":1514946582684},{"_id":"themes/Tinnypp/source/css/_partial/duoshuo.styl","hash":"3ec423b734639614fbd11ec2c3445d3a03f5231d","modified":1514946582686},{"_id":"themes/Tinnypp/source/css/_partial/footer.styl","hash":"e36b1b28558bf2b6d9d71c52ad085ef3f89c92eb","modified":1514946582688},{"_id":"themes/Tinnypp/source/css/_partial/gallery.styl","hash":"b85a32c4bc71f720d74143a17a202fe8fa067950","modified":1514946582690},{"_id":"themes/Tinnypp/source/css/_partial/header.styl","hash":"574dda1fc11f81e1b6537b9d1b41d833c0c3895c","modified":1514946582691},{"_id":"themes/Tinnypp/source/css/_partial/helper.styl","hash":"110f684415ed5cd38baec1c40d35abe264bc5ff8","modified":1514946582693},{"_id":"themes/Tinnypp/source/css/_partial/index.styl","hash":"f5f86b6f3037b1c94afabcca52d43426ae791d05","modified":1514946582696},{"_id":"themes/Tinnypp/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1514946582718},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1514946582720},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1514946582721},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1514946582723},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1514946582725},{"_id":"themes/Tinnypp/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1514946582727},{"_id":"themes/Tinnypp/source/font/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1514946582752},{"_id":"themes/Tinnypp/source/img/myLogo.png","hash":"de14b2ab5106a6c563968545b08b19cf0c9eb48c","modified":1514902631076}],"Category":[{"name":"Linux","_id":"cjbzyyepe0002u8w69y5xacqj"},{"name":"Git","_id":"cjbzyyeqm000hu8w6616zipyu"},{"name":"NoSQL","_id":"cjbzyyeqs000pu8w6f719cyap"},{"name":"MySQL","_id":"cjbzyyer50012u8w6p1g01goe"},{"name":"PHP","_id":"cjbzyyesc0025u8w6drezpx8t"}],"Data":[],"Page":[],"Post":[{"title":"CentOS 7 安装 LNMP 环境（PHP7 + MySQL5.7 + Nginx1.10）","date":"2017-04-09T21:54:08.000Z","_content":"\n工具\n----------------\n - VMware版本号 ： 12.0.0 \n - CentOS版本   ： 7.0\n一、修改 yum 源\n----------------\n```\n[root@localhost ~]# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n[root@localhost ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\n[root@localhost ~]# rpm -Uvh  http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm\n```\nwebtatic：https://webtatic.com\nMySQL:https://dev.mysql.com/downloads/repo/yum/\n\n二、安装 Nginx、MySQL、PHP\n----------------\n```\n[root@localhost ~]# yum -y install nginx\n[root@localhost ~]# yum -y install mysql-community-server\n[root@localhost ~]# yum -y install php70w-devel php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64  php70w-pdo.x86_64   php70w-mysqlnd  php70w-fpm php70w-opcache php70w-pecl-redis php70w-pecl-mongo\n```\n三、配置\n----------------\n1、配置 MySQL\n`MySQL` 安装完成之后，在 `/var/log/mysqld.log `文件中给 `root` 生成了一个`默认密码`。通过下面的方式找到`root 默认密码`，然后登录 `MySQL` 进行修改：\n```\n[root@localhost ~]# systemctl start mysqld    # 启动 MySQL\n[root@localhost ~]# grep 'temporary password' /var/log/mysqld.log  # 查找默认密码\n2017-04-10T02:58:16.806931Z 1 [Note] A temporary password is generated for root@localhost: iacFXpWt-6gJ\n```\n登录 `MySQL`:\n```\n[root@localhost ~]# mysql -uroot -p'iacFXpWt-6gJ'  \n```\n修改`root 默认密码`:\n```\nmysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyPass1!';\n```\n或者：\n```\nmysql> set password for 'root'@'localhost'=password('123abc'); \n```\n`注`：`MySQL5.7` 默认安装了`密码安全检查插件（validate_password）`，默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。\n否则会提示ERROR 1819 (HY000): `Your password does not satisfy the current policy requirements`错误\n![此处输入图片的描述][3]\n详见 MySQL 官网密码策略详细说明：https://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy\n配置默认编码为 `utf8`：\n修改 `/etc/my.cnf` 配置文件，在 `[mysqld]` 下添加编码配置，配置完成后重启：\n```\n[root@localhost ~]# vim /etc/my.cnf\n[mysqld]\ncharacter_set_server=utf8\ninit_connect='SET NAMES utf8'\n[root@localhost ~]# systemctl restart mysqld    # 重启 MySQL\n```\n![此处输入图片的描述][6]\n设置开机启动：\n```\n[root@localhost ~]# systemctl enable mysqld\n```\n默认配置文件路径：\n配置文件：`/etc/my.cnf`\n日志文件：`/var/log//var/log/mysqld.log`\n服务启动脚本：`/usr/lib/systemd/system/mysqld.service`\nsocket 文件：`/var/run/mysqld/mysqld.pid`\n\n2、配置 Nginx\n安装完成以后查看自己`防火墙`是否开启，如果已开启，我们需要`修改`防火墙`配置`，开启 `Nginx` 外网端口访问。\n```\n[root@localhost ~]# systemctl status firewalld\n```\n![此处输入图片的描述][1]\n如果显示 `active (running)`，则需要调整防火墙规则的配置。\n\n修改 `/etc/firewalld/zones/public.xml`文件，在zone一节中增加\n保存后重新加载 `firewalld` 服务：\n```\n[root@localhost ~]# vim /etc/firewalld/zones/public.xml\n<zone>\n    ...\n    <service name=\"nginx\"/>\n<zone>\n[root@localhost ~]# systemctl reload firewalld\n```\n![此处输入图片的描述][2]\n修改 `Nginx` 配置：\n```\n[root@localhost ~]# vim /etc/nginx/nginx.conf\n```\n在 `server {}` 里添加：\n```\nlocation / {\n    #定义首页索引文件的名称\n    index index.php index.html index.htm;   \n}\n\n# PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\nlocation ~ .php$ {\n    fastcgi_pass 127.0.0.1:9000;\n    fastcgi_index index.php;\n    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n    include fastcgi_params;\n}\n```\n![此处输入图片的描述][4]\n配置完成重启 `Nginx`：\n```\n[root@localhost ~]# systemctl start nginx    # 启动 Nginx\n```\n`注`：本文只是简单配置 `Nginx`，具体更多配置请自行百度。\n设置开机启动:\n```\n[root@localhost ~]# systemctl enable nginx\n```\n\n3、设置开机启动 `php-fpm`：\n```\n[root@localhost ~]# systemctl enable php-fpm\n[root@localhost ~]# systemctl start php-fpm    # 启动 php-fpm\n```\n\n四、测试：\n\n - 在 `/usr/share/nginx/html` 文件下创建php文件，输出 `phpinfo` 信息\n - 浏览器访问 `http://<内网IP地址>/phpinfo.php`，如果看到 PHP 信息，说明`安装成功`\n ![此处输入图片的描述][5]\n  [1]: http://olln3wpar.bkt.clouddn.com/LNMP_1.png\n  [2]: http://olln3wpar.bkt.clouddn.com/LNMP_2.png\n  [3]: http://olln3wpar.bkt.clouddn.com/LNMP_11.png\n  [4]: http://olln3wpar.bkt.clouddn.com/LNMP_12.png\n  [5]: http://olln3wpar.bkt.clouddn.com/LNMP_13.png\n  [6]: http://olln3wpar.bkt.clouddn.com/LNMP_15.png","source":"_posts/CentOS-7-安装-LNMP-环境（PHP7-MySQL5-7-Nginx1-10）.md","raw":"---\ntitle: CentOS 7 安装 LNMP 环境（PHP7 + MySQL5.7 + Nginx1.10）\ndate: 2017-04-10 05:54:08\ntags:\n- yum\ncategories:\n- Linux\n---\n\n工具\n----------------\n - VMware版本号 ： 12.0.0 \n - CentOS版本   ： 7.0\n一、修改 yum 源\n----------------\n```\n[root@localhost ~]# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n[root@localhost ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\n[root@localhost ~]# rpm -Uvh  http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm\n```\nwebtatic：https://webtatic.com\nMySQL:https://dev.mysql.com/downloads/repo/yum/\n\n二、安装 Nginx、MySQL、PHP\n----------------\n```\n[root@localhost ~]# yum -y install nginx\n[root@localhost ~]# yum -y install mysql-community-server\n[root@localhost ~]# yum -y install php70w-devel php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64  php70w-pdo.x86_64   php70w-mysqlnd  php70w-fpm php70w-opcache php70w-pecl-redis php70w-pecl-mongo\n```\n三、配置\n----------------\n1、配置 MySQL\n`MySQL` 安装完成之后，在 `/var/log/mysqld.log `文件中给 `root` 生成了一个`默认密码`。通过下面的方式找到`root 默认密码`，然后登录 `MySQL` 进行修改：\n```\n[root@localhost ~]# systemctl start mysqld    # 启动 MySQL\n[root@localhost ~]# grep 'temporary password' /var/log/mysqld.log  # 查找默认密码\n2017-04-10T02:58:16.806931Z 1 [Note] A temporary password is generated for root@localhost: iacFXpWt-6gJ\n```\n登录 `MySQL`:\n```\n[root@localhost ~]# mysql -uroot -p'iacFXpWt-6gJ'  \n```\n修改`root 默认密码`:\n```\nmysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyPass1!';\n```\n或者：\n```\nmysql> set password for 'root'@'localhost'=password('123abc'); \n```\n`注`：`MySQL5.7` 默认安装了`密码安全检查插件（validate_password）`，默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。\n否则会提示ERROR 1819 (HY000): `Your password does not satisfy the current policy requirements`错误\n![此处输入图片的描述][3]\n详见 MySQL 官网密码策略详细说明：https://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy\n配置默认编码为 `utf8`：\n修改 `/etc/my.cnf` 配置文件，在 `[mysqld]` 下添加编码配置，配置完成后重启：\n```\n[root@localhost ~]# vim /etc/my.cnf\n[mysqld]\ncharacter_set_server=utf8\ninit_connect='SET NAMES utf8'\n[root@localhost ~]# systemctl restart mysqld    # 重启 MySQL\n```\n![此处输入图片的描述][6]\n设置开机启动：\n```\n[root@localhost ~]# systemctl enable mysqld\n```\n默认配置文件路径：\n配置文件：`/etc/my.cnf`\n日志文件：`/var/log//var/log/mysqld.log`\n服务启动脚本：`/usr/lib/systemd/system/mysqld.service`\nsocket 文件：`/var/run/mysqld/mysqld.pid`\n\n2、配置 Nginx\n安装完成以后查看自己`防火墙`是否开启，如果已开启，我们需要`修改`防火墙`配置`，开启 `Nginx` 外网端口访问。\n```\n[root@localhost ~]# systemctl status firewalld\n```\n![此处输入图片的描述][1]\n如果显示 `active (running)`，则需要调整防火墙规则的配置。\n\n修改 `/etc/firewalld/zones/public.xml`文件，在zone一节中增加\n保存后重新加载 `firewalld` 服务：\n```\n[root@localhost ~]# vim /etc/firewalld/zones/public.xml\n<zone>\n    ...\n    <service name=\"nginx\"/>\n<zone>\n[root@localhost ~]# systemctl reload firewalld\n```\n![此处输入图片的描述][2]\n修改 `Nginx` 配置：\n```\n[root@localhost ~]# vim /etc/nginx/nginx.conf\n```\n在 `server {}` 里添加：\n```\nlocation / {\n    #定义首页索引文件的名称\n    index index.php index.html index.htm;   \n}\n\n# PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\nlocation ~ .php$ {\n    fastcgi_pass 127.0.0.1:9000;\n    fastcgi_index index.php;\n    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n    include fastcgi_params;\n}\n```\n![此处输入图片的描述][4]\n配置完成重启 `Nginx`：\n```\n[root@localhost ~]# systemctl start nginx    # 启动 Nginx\n```\n`注`：本文只是简单配置 `Nginx`，具体更多配置请自行百度。\n设置开机启动:\n```\n[root@localhost ~]# systemctl enable nginx\n```\n\n3、设置开机启动 `php-fpm`：\n```\n[root@localhost ~]# systemctl enable php-fpm\n[root@localhost ~]# systemctl start php-fpm    # 启动 php-fpm\n```\n\n四、测试：\n\n - 在 `/usr/share/nginx/html` 文件下创建php文件，输出 `phpinfo` 信息\n - 浏览器访问 `http://<内网IP地址>/phpinfo.php`，如果看到 PHP 信息，说明`安装成功`\n ![此处输入图片的描述][5]\n  [1]: http://olln3wpar.bkt.clouddn.com/LNMP_1.png\n  [2]: http://olln3wpar.bkt.clouddn.com/LNMP_2.png\n  [3]: http://olln3wpar.bkt.clouddn.com/LNMP_11.png\n  [4]: http://olln3wpar.bkt.clouddn.com/LNMP_12.png\n  [5]: http://olln3wpar.bkt.clouddn.com/LNMP_13.png\n  [6]: http://olln3wpar.bkt.clouddn.com/LNMP_15.png","slug":"CentOS-7-安装-LNMP-环境（PHP7-MySQL5-7-Nginx1-10）","published":1,"updated":"2018-01-04T02:52:11.745Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeoy0000u8w6hdal84m9","content":"<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>VMware版本号 ： 12.0.0 </li>\n<li>CentOS版本   ： 7.0<br>一、修改 yum 源</li>\n</ul>\n<hr>\n<pre><code>[root@localhost ~]# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n[root@localhost ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\n[root@localhost ~]# rpm -Uvh  http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm\n</code></pre><p>webtatic：<a href=\"https://webtatic.com\" target=\"_blank\" rel=\"noopener\">https://webtatic.com</a><br>MySQL:<a href=\"https://dev.mysql.com/downloads/repo/yum/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/repo/yum/</a></p>\n<h2 id=\"二、安装-Nginx、MySQL、PHP\"><a href=\"#二、安装-Nginx、MySQL、PHP\" class=\"headerlink\" title=\"二、安装 Nginx、MySQL、PHP\"></a>二、安装 Nginx、MySQL、PHP</h2><pre><code>[root@localhost ~]# yum -y install nginx\n[root@localhost ~]# yum -y install mysql-community-server\n[root@localhost ~]# yum -y install php70w-devel php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64  php70w-pdo.x86_64   php70w-mysqlnd  php70w-fpm php70w-opcache php70w-pecl-redis php70w-pecl-mongo\n</code></pre><h2 id=\"三、配置\"><a href=\"#三、配置\" class=\"headerlink\" title=\"三、配置\"></a>三、配置</h2><p>1、配置 MySQL<br><code>MySQL</code> 安装完成之后，在 <code>/var/log/mysqld.log</code>文件中给 <code>root</code> 生成了一个<code>默认密码</code>。通过下面的方式找到<code>root 默认密码</code>，然后登录 <code>MySQL</code> 进行修改：</p>\n<pre><code>[root@localhost ~]# systemctl start mysqld    # 启动 MySQL\n[root@localhost ~]# grep &#39;temporary password&#39; /var/log/mysqld.log  # 查找默认密码\n2017-04-10T02:58:16.806931Z 1 [Note] A temporary password is generated for root@localhost: iacFXpWt-6gJ\n</code></pre><p>登录 <code>MySQL</code>:</p>\n<pre><code>[root@localhost ~]# mysql -uroot -p&#39;iacFXpWt-6gJ&#39;\n</code></pre><p>修改<code>root 默认密码</code>:</p>\n<pre><code>mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyPass1!&#39;;\n</code></pre><p>或者：</p>\n<pre><code>mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;=password(&#39;123abc&#39;);\n</code></pre><p><code>注</code>：<code>MySQL5.7</code> 默认安装了<code>密码安全检查插件（validate_password）</code>，默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。<br>否则会提示ERROR 1819 (HY000): <code>Your password does not satisfy the current policy requirements</code>错误<br><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_11.png\" alt=\"此处输入图片的描述\"><br>详见 MySQL 官网密码策略详细说明：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy</a><br>配置默认编码为 <code>utf8</code>：<br>修改 <code>/etc/my.cnf</code> 配置文件，在 <code>[mysqld]</code> 下添加编码配置，配置完成后重启：</p>\n<pre><code>[root@localhost ~]# vim /etc/my.cnf\n[mysqld]\ncharacter_set_server=utf8\ninit_connect=&#39;SET NAMES utf8&#39;\n[root@localhost ~]# systemctl restart mysqld    # 重启 MySQL\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_15.png\" alt=\"此处输入图片的描述\"><br>设置开机启动：</p>\n<pre><code>[root@localhost ~]# systemctl enable mysqld\n</code></pre><p>默认配置文件路径：<br>配置文件：<code>/etc/my.cnf</code><br>日志文件：<code>/var/log//var/log/mysqld.log</code><br>服务启动脚本：<code>/usr/lib/systemd/system/mysqld.service</code><br>socket 文件：<code>/var/run/mysqld/mysqld.pid</code></p>\n<p>2、配置 Nginx<br>安装完成以后查看自己<code>防火墙</code>是否开启，如果已开启，我们需要<code>修改</code>防火墙<code>配置</code>，开启 <code>Nginx</code> 外网端口访问。</p>\n<pre><code>[root@localhost ~]# systemctl status firewalld\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_1.png\" alt=\"此处输入图片的描述\"><br>如果显示 <code>active (running)</code>，则需要调整防火墙规则的配置。</p>\n<p>修改 <code>/etc/firewalld/zones/public.xml</code>文件，在zone一节中增加<br>保存后重新加载 <code>firewalld</code> 服务：</p>\n<pre><code>[root@localhost ~]# vim /etc/firewalld/zones/public.xml\n&lt;zone&gt;\n    ...\n    &lt;service name=&quot;nginx&quot;/&gt;\n&lt;zone&gt;\n[root@localhost ~]# systemctl reload firewalld\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_2.png\" alt=\"此处输入图片的描述\"><br>修改 <code>Nginx</code> 配置：</p>\n<pre><code>[root@localhost ~]# vim /etc/nginx/nginx.conf\n</code></pre><p>在 <code>server {}</code> 里添加：</p>\n<pre><code>location / {\n    #定义首页索引文件的名称\n    index index.php index.html index.htm;   \n}\n\n# PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\nlocation ~ .php$ {\n    fastcgi_pass 127.0.0.1:9000;\n    fastcgi_index index.php;\n    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n    include fastcgi_params;\n}\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_12.png\" alt=\"此处输入图片的描述\"><br>配置完成重启 <code>Nginx</code>：</p>\n<pre><code>[root@localhost ~]# systemctl start nginx    # 启动 Nginx\n</code></pre><p><code>注</code>：本文只是简单配置 <code>Nginx</code>，具体更多配置请自行百度。<br>设置开机启动:</p>\n<pre><code>[root@localhost ~]# systemctl enable nginx\n</code></pre><p>3、设置开机启动 <code>php-fpm</code>：</p>\n<pre><code>[root@localhost ~]# systemctl enable php-fpm\n[root@localhost ~]# systemctl start php-fpm    # 启动 php-fpm\n</code></pre><p>四、测试：</p>\n<ul>\n<li>在 <code>/usr/share/nginx/html</code> 文件下创建php文件，输出 <code>phpinfo</code> 信息</li>\n<li>浏览器访问 <code>http://&lt;内网IP地址&gt;/phpinfo.php</code>，如果看到 PHP 信息，说明<code>安装成功</code><br><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_13.png\" alt=\"此处输入图片的描述\"></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>VMware版本号 ： 12.0.0 </li>\n<li>CentOS版本   ： 7.0<br>一、修改 yum 源</li>\n</ul>\n<hr>\n<pre><code>[root@localhost ~]# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\n[root@localhost ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm\n[root@localhost ~]# rpm -Uvh  http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm\n</code></pre><p>webtatic：<a href=\"https://webtatic.com\" target=\"_blank\" rel=\"noopener\">https://webtatic.com</a><br>MySQL:<a href=\"https://dev.mysql.com/downloads/repo/yum/\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/downloads/repo/yum/</a></p>\n<h2 id=\"二、安装-Nginx、MySQL、PHP\"><a href=\"#二、安装-Nginx、MySQL、PHP\" class=\"headerlink\" title=\"二、安装 Nginx、MySQL、PHP\"></a>二、安装 Nginx、MySQL、PHP</h2><pre><code>[root@localhost ~]# yum -y install nginx\n[root@localhost ~]# yum -y install mysql-community-server\n[root@localhost ~]# yum -y install php70w-devel php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64  php70w-pdo.x86_64   php70w-mysqlnd  php70w-fpm php70w-opcache php70w-pecl-redis php70w-pecl-mongo\n</code></pre><h2 id=\"三、配置\"><a href=\"#三、配置\" class=\"headerlink\" title=\"三、配置\"></a>三、配置</h2><p>1、配置 MySQL<br><code>MySQL</code> 安装完成之后，在 <code>/var/log/mysqld.log</code>文件中给 <code>root</code> 生成了一个<code>默认密码</code>。通过下面的方式找到<code>root 默认密码</code>，然后登录 <code>MySQL</code> 进行修改：</p>\n<pre><code>[root@localhost ~]# systemctl start mysqld    # 启动 MySQL\n[root@localhost ~]# grep &#39;temporary password&#39; /var/log/mysqld.log  # 查找默认密码\n2017-04-10T02:58:16.806931Z 1 [Note] A temporary password is generated for root@localhost: iacFXpWt-6gJ\n</code></pre><p>登录 <code>MySQL</code>:</p>\n<pre><code>[root@localhost ~]# mysql -uroot -p&#39;iacFXpWt-6gJ&#39;\n</code></pre><p>修改<code>root 默认密码</code>:</p>\n<pre><code>mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;MyPass1!&#39;;\n</code></pre><p>或者：</p>\n<pre><code>mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;=password(&#39;123abc&#39;);\n</code></pre><p><code>注</code>：<code>MySQL5.7</code> 默认安装了<code>密码安全检查插件（validate_password）</code>，默认密码检查策略要求密码必须包含：大小写字母、数字和特殊符号，并且长度不能少于8位。<br>否则会提示ERROR 1819 (HY000): <code>Your password does not satisfy the current policy requirements</code>错误<br><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_11.png\" alt=\"此处输入图片的描述\"><br>详见 MySQL 官网密码策略详细说明：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/validate-password-options-variables.html#sysvar_validate_password_policy</a><br>配置默认编码为 <code>utf8</code>：<br>修改 <code>/etc/my.cnf</code> 配置文件，在 <code>[mysqld]</code> 下添加编码配置，配置完成后重启：</p>\n<pre><code>[root@localhost ~]# vim /etc/my.cnf\n[mysqld]\ncharacter_set_server=utf8\ninit_connect=&#39;SET NAMES utf8&#39;\n[root@localhost ~]# systemctl restart mysqld    # 重启 MySQL\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_15.png\" alt=\"此处输入图片的描述\"><br>设置开机启动：</p>\n<pre><code>[root@localhost ~]# systemctl enable mysqld\n</code></pre><p>默认配置文件路径：<br>配置文件：<code>/etc/my.cnf</code><br>日志文件：<code>/var/log//var/log/mysqld.log</code><br>服务启动脚本：<code>/usr/lib/systemd/system/mysqld.service</code><br>socket 文件：<code>/var/run/mysqld/mysqld.pid</code></p>\n<p>2、配置 Nginx<br>安装完成以后查看自己<code>防火墙</code>是否开启，如果已开启，我们需要<code>修改</code>防火墙<code>配置</code>，开启 <code>Nginx</code> 外网端口访问。</p>\n<pre><code>[root@localhost ~]# systemctl status firewalld\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_1.png\" alt=\"此处输入图片的描述\"><br>如果显示 <code>active (running)</code>，则需要调整防火墙规则的配置。</p>\n<p>修改 <code>/etc/firewalld/zones/public.xml</code>文件，在zone一节中增加<br>保存后重新加载 <code>firewalld</code> 服务：</p>\n<pre><code>[root@localhost ~]# vim /etc/firewalld/zones/public.xml\n&lt;zone&gt;\n    ...\n    &lt;service name=&quot;nginx&quot;/&gt;\n&lt;zone&gt;\n[root@localhost ~]# systemctl reload firewalld\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_2.png\" alt=\"此处输入图片的描述\"><br>修改 <code>Nginx</code> 配置：</p>\n<pre><code>[root@localhost ~]# vim /etc/nginx/nginx.conf\n</code></pre><p>在 <code>server {}</code> 里添加：</p>\n<pre><code>location / {\n    #定义首页索引文件的名称\n    index index.php index.html index.htm;   \n}\n\n# PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.\nlocation ~ .php$ {\n    fastcgi_pass 127.0.0.1:9000;\n    fastcgi_index index.php;\n    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;\n    include fastcgi_params;\n}\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_12.png\" alt=\"此处输入图片的描述\"><br>配置完成重启 <code>Nginx</code>：</p>\n<pre><code>[root@localhost ~]# systemctl start nginx    # 启动 Nginx\n</code></pre><p><code>注</code>：本文只是简单配置 <code>Nginx</code>，具体更多配置请自行百度。<br>设置开机启动:</p>\n<pre><code>[root@localhost ~]# systemctl enable nginx\n</code></pre><p>3、设置开机启动 <code>php-fpm</code>：</p>\n<pre><code>[root@localhost ~]# systemctl enable php-fpm\n[root@localhost ~]# systemctl start php-fpm    # 启动 php-fpm\n</code></pre><p>四、测试：</p>\n<ul>\n<li>在 <code>/usr/share/nginx/html</code> 文件下创建php文件，输出 <code>phpinfo</code> 信息</li>\n<li>浏览器访问 <code>http://&lt;内网IP地址&gt;/phpinfo.php</code>，如果看到 PHP 信息，说明<code>安装成功</code><br><img src=\"http://olln3wpar.bkt.clouddn.com/LNMP_13.png\" alt=\"此处输入图片的描述\"></li>\n</ul>\n"},{"title":"CentOS下三种PHP拓展安装方法","date":"2017-04-08T15:15:06.000Z","_content":"\n> `CentOS` 下，PHP有多种方式来安装拓展， 主要有 `包管理式`的 `yum 安装`、`pecl 安装`， 以及`源码编译安装`。\n> `包管理式`的安装卸载尤为方便，而`源码编译式`的安装则方便参数调优。\n> 一般的搭建本机开发环境推荐`包管理式`的安装，节约时间。而`线上部署`环境则推荐`编译安装`， 方便调优。 \n> 本文以 `MongoDB` 扩展`安装举例。\n\n工具\n----------------\n - PHP版本      ： 7.0.17\n - Nginx        ： 1.10.2\n - VMware版本号 ： 12.0.0 \n - CentOS版本   ： 7.0\n\n\n一、yum 安装\n----------------\n`yum 方式`安装能自动安装拓展的.so动态库，并配置好 `php.ini`\n注：\n - 请确保自己 `yum 源` 里面有对应扩展\n - 安装完成后重启服务器 `Nginx` 或者 `Apache`\n - 浏览器访问 `index.php` 文件,输出 `phpinfo` 信息，如果有 `MongoDB` 信息，则安装成功\n\n```\n[root@localhost ~]yum search mongodb|grep php        # 搜索 yum 源里面 MongoDB 拓展\n[root@localhost ~]yum -y install php70w-pecl-mongo   # 安装 PHP 对应版本的 MongoDB 扩展\n[root@localhost ~]systemctl restart nginx            # 重新启动 Nginx\n```\n![此处输入图片的描述][1]\n![此处输入图片的描述][2]\n\n\n二、pecl 安装\n----------------\n官方文档：http://php.net/manual/zh/mongodb.installation.pecl.php\n\n```\n[root@localhost ~]# pecl install mongodb\n-bash: pecl: 未找到命令\n```\n直接输入 `pecl install mongodb` 会报错，说明 `pecl` 我们没有安装，安装 `pecl`\n```\n[root@localhost ~]# yum -y install php70w-pear\n[root@localhost ~]# pecl install mongodb\nconfigure: error: Cannot find OpenSSL's <evp.h>\nERROR: `/var/tmp/mongodb/configure --with-php-config=/usr/bin/php-config' failed\n```\n到这一步又会`报错`，需要我们安装 `openssl `，安装完成后继续执行上次`未执行成功`的命令\n![此处输入图片的描述][7]\n\n```\n[root@localhost ~]# yum -y install openssl openssl-devel\n[root@localhost ~]# pecl install mongodb\n[root@localhost ~]# systemctl restart nginx             # 重新启动 Nginx\n```\n安装完成后在 `PHP` 配置文件 `php.ini` 里面加载 `MongoDB` 扩展\n![此处输入图片的描述][5]\n - 安装完成后重启服务器 `Nginx` 或者 `Apache`\n - 浏览器访问 `index.php` 文件,输出 `phpinfo` 信息，如果有 `MongoDB` 信息，则安装成功\n\n\n![此处输入图片的描述][6]\n\n\n三、源码编译安装\n----------------\n源码编译包下载列表：https://pecl.php.net/packages.php\nMongodb包下载地址：https://pecl.php.net/package/mongodb\n```\n[root@localhost ~]# wget http://pecl.php.net/get/mongodb-1.2.8.tgz  #下载源码包\n[root@localhost ~]# tar zxf mongodb-1.2.8.tgz  #解压\n[root@localhost ~]# cd mongodb-1.2.8\n# 可能是 /usr/local/php/bin/phpize 找到自己的 phpize 文件，php-config 同理\n[root@localhost mongodb-1.2.8]# /usr/bin/phpize    \nConfiguring for:\nPHP Api Version:         20151012\nZend Module Api No:      20151012\nZend Extension Api No:   320151012\n[root@localhost mongodb-1.2.8]# ./configure --with-php-config=/usr/bin/php-config\nconfigure: error: Cannot find OpenSSL's <evp.h>\n```\n到了这步`又是熟悉的味道又是熟悉的感觉`，需要我们安装 `openssl `，安装完成后继续执行上次`未执行成功`的命令\n![此处输入图片的描述][3]\n\n```\n[root@localhost mongodb-1.2.8]# yum -y install openssl openssl-devel\n[root@localhost mongodb-1.2.8]# ./configure --with-php-config=/usr/bin/php-config\n# 确保自己安装了 gcc gcc++ 如果没有安装 yum -y install gcc gcc++\n[root@localhost mongodb-1.2.8]# make && make install # 编译\n```\n说明：`php-config` 是一个简单的命令行脚本用于`获取`所安装的 `PHP 配置`的信息。\n\n在编译扩展时，如果安装有多个 PHP 版本，可以在配置时用 `--with-php-config` 选项来指定使用哪一个版本编译，该选项指定了相对应的 `php-config` 脚本的路径。\n\n`编译成功`如下图\n![此处输入图片的描述][4]\n此时在 `PHP` 配置文件 `php.ini` 里面加载 `MongoDB` 扩展\n![此处输入图片的描述][5]\n\n - 重启服务器 `Nginx` 或者 `Apache`\n - 浏览器访问 `index.php` 文件,输出 `phpinfo` 信息，如果有 `MongoDB` 信息，则安装成功\n\n\n ```\n [root@localhost mongodb-1.2.8]# systemctl restart nginx   # 重新启动 Nginx\n ```\n![此处输入图片的描述][6]\n\n\n**总结：**\n - `pecl 安装`和`源码编译安装`区别就是：方便参数调优。\n - 在选择 `Mongo 扩展`的时候，官方提供了两种：`mongo` 和 `mongodb`\n\n第一种： https://pecl.php.net/package/mongo\n第二种： https://pecl.php.net/package/mongodb\n第一种官方提示：`This package has been superseded, but is still maintained for bugs and security fixes`，已经废弃了，不过 `bug` 和 `security` 方面的问题还会继续修复，不支持 `PHP7` \n\n**建议：**\n - PHP 版本为 5.x 建议使用 `mongo` 扩展\n - PHP 版本为 7.x 建议使用 `mongodb` 扩展\nPHP5.x 可以使用 `mongodb` 扩展。但是 PHP7.x  不可以使用 `mongo` 扩展。\n\n**写在最后：**\n如果是自己学习的话还是推荐 `yum 安装`，因为在你安装过程中会出现`缺少各种依赖`的`报错`。\n\n  [1]: http://olln3wpar.bkt.clouddn.com/php_extension_1.png\n  [2]: http://olln3wpar.bkt.clouddn.com/php_extension_2.png\n  [3]: http://olln3wpar.bkt.clouddn.com/php_extension_4.png\n  [4]: http://olln3wpar.bkt.clouddn.com/php_extension_7.png\n  [5]: http://olln3wpar.bkt.clouddn.com/php_extension_5.png\n  [6]: http://olln3wpar.bkt.clouddn.com/php_extension_6.png\n  [7]: http://olln3wpar.bkt.clouddn.com/php_extension_3_1.png","source":"_posts/CentOS下三种PHP拓展安装方法.md","raw":"---\ntitle: CentOS下三种PHP拓展安装方法\ndate: 2017-04-08 23:15:06\ntags:\n- MongoDB\n- yum\ncategories:\n- Linux\n---\n\n> `CentOS` 下，PHP有多种方式来安装拓展， 主要有 `包管理式`的 `yum 安装`、`pecl 安装`， 以及`源码编译安装`。\n> `包管理式`的安装卸载尤为方便，而`源码编译式`的安装则方便参数调优。\n> 一般的搭建本机开发环境推荐`包管理式`的安装，节约时间。而`线上部署`环境则推荐`编译安装`， 方便调优。 \n> 本文以 `MongoDB` 扩展`安装举例。\n\n工具\n----------------\n - PHP版本      ： 7.0.17\n - Nginx        ： 1.10.2\n - VMware版本号 ： 12.0.0 \n - CentOS版本   ： 7.0\n\n\n一、yum 安装\n----------------\n`yum 方式`安装能自动安装拓展的.so动态库，并配置好 `php.ini`\n注：\n - 请确保自己 `yum 源` 里面有对应扩展\n - 安装完成后重启服务器 `Nginx` 或者 `Apache`\n - 浏览器访问 `index.php` 文件,输出 `phpinfo` 信息，如果有 `MongoDB` 信息，则安装成功\n\n```\n[root@localhost ~]yum search mongodb|grep php        # 搜索 yum 源里面 MongoDB 拓展\n[root@localhost ~]yum -y install php70w-pecl-mongo   # 安装 PHP 对应版本的 MongoDB 扩展\n[root@localhost ~]systemctl restart nginx            # 重新启动 Nginx\n```\n![此处输入图片的描述][1]\n![此处输入图片的描述][2]\n\n\n二、pecl 安装\n----------------\n官方文档：http://php.net/manual/zh/mongodb.installation.pecl.php\n\n```\n[root@localhost ~]# pecl install mongodb\n-bash: pecl: 未找到命令\n```\n直接输入 `pecl install mongodb` 会报错，说明 `pecl` 我们没有安装，安装 `pecl`\n```\n[root@localhost ~]# yum -y install php70w-pear\n[root@localhost ~]# pecl install mongodb\nconfigure: error: Cannot find OpenSSL's <evp.h>\nERROR: `/var/tmp/mongodb/configure --with-php-config=/usr/bin/php-config' failed\n```\n到这一步又会`报错`，需要我们安装 `openssl `，安装完成后继续执行上次`未执行成功`的命令\n![此处输入图片的描述][7]\n\n```\n[root@localhost ~]# yum -y install openssl openssl-devel\n[root@localhost ~]# pecl install mongodb\n[root@localhost ~]# systemctl restart nginx             # 重新启动 Nginx\n```\n安装完成后在 `PHP` 配置文件 `php.ini` 里面加载 `MongoDB` 扩展\n![此处输入图片的描述][5]\n - 安装完成后重启服务器 `Nginx` 或者 `Apache`\n - 浏览器访问 `index.php` 文件,输出 `phpinfo` 信息，如果有 `MongoDB` 信息，则安装成功\n\n\n![此处输入图片的描述][6]\n\n\n三、源码编译安装\n----------------\n源码编译包下载列表：https://pecl.php.net/packages.php\nMongodb包下载地址：https://pecl.php.net/package/mongodb\n```\n[root@localhost ~]# wget http://pecl.php.net/get/mongodb-1.2.8.tgz  #下载源码包\n[root@localhost ~]# tar zxf mongodb-1.2.8.tgz  #解压\n[root@localhost ~]# cd mongodb-1.2.8\n# 可能是 /usr/local/php/bin/phpize 找到自己的 phpize 文件，php-config 同理\n[root@localhost mongodb-1.2.8]# /usr/bin/phpize    \nConfiguring for:\nPHP Api Version:         20151012\nZend Module Api No:      20151012\nZend Extension Api No:   320151012\n[root@localhost mongodb-1.2.8]# ./configure --with-php-config=/usr/bin/php-config\nconfigure: error: Cannot find OpenSSL's <evp.h>\n```\n到了这步`又是熟悉的味道又是熟悉的感觉`，需要我们安装 `openssl `，安装完成后继续执行上次`未执行成功`的命令\n![此处输入图片的描述][3]\n\n```\n[root@localhost mongodb-1.2.8]# yum -y install openssl openssl-devel\n[root@localhost mongodb-1.2.8]# ./configure --with-php-config=/usr/bin/php-config\n# 确保自己安装了 gcc gcc++ 如果没有安装 yum -y install gcc gcc++\n[root@localhost mongodb-1.2.8]# make && make install # 编译\n```\n说明：`php-config` 是一个简单的命令行脚本用于`获取`所安装的 `PHP 配置`的信息。\n\n在编译扩展时，如果安装有多个 PHP 版本，可以在配置时用 `--with-php-config` 选项来指定使用哪一个版本编译，该选项指定了相对应的 `php-config` 脚本的路径。\n\n`编译成功`如下图\n![此处输入图片的描述][4]\n此时在 `PHP` 配置文件 `php.ini` 里面加载 `MongoDB` 扩展\n![此处输入图片的描述][5]\n\n - 重启服务器 `Nginx` 或者 `Apache`\n - 浏览器访问 `index.php` 文件,输出 `phpinfo` 信息，如果有 `MongoDB` 信息，则安装成功\n\n\n ```\n [root@localhost mongodb-1.2.8]# systemctl restart nginx   # 重新启动 Nginx\n ```\n![此处输入图片的描述][6]\n\n\n**总结：**\n - `pecl 安装`和`源码编译安装`区别就是：方便参数调优。\n - 在选择 `Mongo 扩展`的时候，官方提供了两种：`mongo` 和 `mongodb`\n\n第一种： https://pecl.php.net/package/mongo\n第二种： https://pecl.php.net/package/mongodb\n第一种官方提示：`This package has been superseded, but is still maintained for bugs and security fixes`，已经废弃了，不过 `bug` 和 `security` 方面的问题还会继续修复，不支持 `PHP7` \n\n**建议：**\n - PHP 版本为 5.x 建议使用 `mongo` 扩展\n - PHP 版本为 7.x 建议使用 `mongodb` 扩展\nPHP5.x 可以使用 `mongodb` 扩展。但是 PHP7.x  不可以使用 `mongo` 扩展。\n\n**写在最后：**\n如果是自己学习的话还是推荐 `yum 安装`，因为在你安装过程中会出现`缺少各种依赖`的`报错`。\n\n  [1]: http://olln3wpar.bkt.clouddn.com/php_extension_1.png\n  [2]: http://olln3wpar.bkt.clouddn.com/php_extension_2.png\n  [3]: http://olln3wpar.bkt.clouddn.com/php_extension_4.png\n  [4]: http://olln3wpar.bkt.clouddn.com/php_extension_7.png\n  [5]: http://olln3wpar.bkt.clouddn.com/php_extension_5.png\n  [6]: http://olln3wpar.bkt.clouddn.com/php_extension_6.png\n  [7]: http://olln3wpar.bkt.clouddn.com/php_extension_3_1.png","slug":"CentOS下三种PHP拓展安装方法","published":1,"updated":"2018-01-03T02:05:07.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyep60001u8w6l0ssi6x7","content":"<blockquote>\n<p><code>CentOS</code> 下，PHP有多种方式来安装拓展， 主要有 <code>包管理式</code>的 <code>yum 安装</code>、<code>pecl 安装</code>， 以及<code>源码编译安装</code>。<br><code>包管理式</code>的安装卸载尤为方便，而<code>源码编译式</code>的安装则方便参数调优。<br>一般的搭建本机开发环境推荐<code>包管理式</code>的安装，节约时间。而<code>线上部署</code>环境则推荐<code>编译安装</code>， 方便调优。<br>本文以 <code>MongoDB</code> 扩展`安装举例。</p>\n</blockquote>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>PHP版本      ： 7.0.17</li>\n<li>Nginx        ： 1.10.2</li>\n<li>VMware版本号 ： 12.0.0 </li>\n<li>CentOS版本   ： 7.0</li>\n</ul>\n<h2 id=\"一、yum-安装\"><a href=\"#一、yum-安装\" class=\"headerlink\" title=\"一、yum 安装\"></a>一、yum 安装</h2><p><code>yum 方式</code>安装能自动安装拓展的.so动态库，并配置好 <code>php.ini</code><br>注：</p>\n<ul>\n<li>请确保自己 <code>yum 源</code> 里面有对应扩展</li>\n<li>安装完成后重启服务器 <code>Nginx</code> 或者 <code>Apache</code></li>\n<li>浏览器访问 <code>index.php</code> 文件,输出 <code>phpinfo</code> 信息，如果有 <code>MongoDB</code> 信息，则安装成功</li>\n</ul>\n<pre><code>[root@localhost ~]yum search mongodb|grep php        # 搜索 yum 源里面 MongoDB 拓展\n[root@localhost ~]yum -y install php70w-pecl-mongo   # 安装 PHP 对应版本的 MongoDB 扩展\n[root@localhost ~]systemctl restart nginx            # 重新启动 Nginx\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_1.png\" alt=\"此处输入图片的描述\"><br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_2.png\" alt=\"此处输入图片的描述\"></p>\n<h2 id=\"二、pecl-安装\"><a href=\"#二、pecl-安装\" class=\"headerlink\" title=\"二、pecl 安装\"></a>二、pecl 安装</h2><p>官方文档：<a href=\"http://php.net/manual/zh/mongodb.installation.pecl.php\" target=\"_blank\" rel=\"noopener\">http://php.net/manual/zh/mongodb.installation.pecl.php</a></p>\n<pre><code>[root@localhost ~]# pecl install mongodb\n-bash: pecl: 未找到命令\n</code></pre><p>直接输入 <code>pecl install mongodb</code> 会报错，说明 <code>pecl</code> 我们没有安装，安装 <code>pecl</code></p>\n<pre><code>[root@localhost ~]# yum -y install php70w-pear\n[root@localhost ~]# pecl install mongodb\nconfigure: error: Cannot find OpenSSL&#39;s &lt;evp.h&gt;\nERROR: `/var/tmp/mongodb/configure --with-php-config=/usr/bin/php-config&#39; failed\n</code></pre><p>到这一步又会<code>报错</code>，需要我们安装 <code>openssl</code>，安装完成后继续执行上次<code>未执行成功</code>的命令<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_3_1.png\" alt=\"此处输入图片的描述\"></p>\n<pre><code>[root@localhost ~]# yum -y install openssl openssl-devel\n[root@localhost ~]# pecl install mongodb\n[root@localhost ~]# systemctl restart nginx             # 重新启动 Nginx\n</code></pre><p>安装完成后在 <code>PHP</code> 配置文件 <code>php.ini</code> 里面加载 <code>MongoDB</code> 扩展<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_5.png\" alt=\"此处输入图片的描述\"></p>\n<ul>\n<li>安装完成后重启服务器 <code>Nginx</code> 或者 <code>Apache</code></li>\n<li>浏览器访问 <code>index.php</code> 文件,输出 <code>phpinfo</code> 信息，如果有 <code>MongoDB</code> 信息，则安装成功</li>\n</ul>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_6.png\" alt=\"此处输入图片的描述\"></p>\n<h2 id=\"三、源码编译安装\"><a href=\"#三、源码编译安装\" class=\"headerlink\" title=\"三、源码编译安装\"></a>三、源码编译安装</h2><p>源码编译包下载列表：<a href=\"https://pecl.php.net/packages.php\" target=\"_blank\" rel=\"noopener\">https://pecl.php.net/packages.php</a><br>Mongodb包下载地址：<a href=\"https://pecl.php.net/package/mongodb\" target=\"_blank\" rel=\"noopener\">https://pecl.php.net/package/mongodb</a></p>\n<pre><code>[root@localhost ~]# wget http://pecl.php.net/get/mongodb-1.2.8.tgz  #下载源码包\n[root@localhost ~]# tar zxf mongodb-1.2.8.tgz  #解压\n[root@localhost ~]# cd mongodb-1.2.8\n# 可能是 /usr/local/php/bin/phpize 找到自己的 phpize 文件，php-config 同理\n[root@localhost mongodb-1.2.8]# /usr/bin/phpize    \nConfiguring for:\nPHP Api Version:         20151012\nZend Module Api No:      20151012\nZend Extension Api No:   320151012\n[root@localhost mongodb-1.2.8]# ./configure --with-php-config=/usr/bin/php-config\nconfigure: error: Cannot find OpenSSL&#39;s &lt;evp.h&gt;\n</code></pre><p>到了这步<code>又是熟悉的味道又是熟悉的感觉</code>，需要我们安装 <code>openssl</code>，安装完成后继续执行上次<code>未执行成功</code>的命令<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_4.png\" alt=\"此处输入图片的描述\"></p>\n<pre><code>[root@localhost mongodb-1.2.8]# yum -y install openssl openssl-devel\n[root@localhost mongodb-1.2.8]# ./configure --with-php-config=/usr/bin/php-config\n# 确保自己安装了 gcc gcc++ 如果没有安装 yum -y install gcc gcc++\n[root@localhost mongodb-1.2.8]# make &amp;&amp; make install # 编译\n</code></pre><p>说明：<code>php-config</code> 是一个简单的命令行脚本用于<code>获取</code>所安装的 <code>PHP 配置</code>的信息。</p>\n<p>在编译扩展时，如果安装有多个 PHP 版本，可以在配置时用 <code>--with-php-config</code> 选项来指定使用哪一个版本编译，该选项指定了相对应的 <code>php-config</code> 脚本的路径。</p>\n<p><code>编译成功</code>如下图<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_7.png\" alt=\"此处输入图片的描述\"><br>此时在 <code>PHP</code> 配置文件 <code>php.ini</code> 里面加载 <code>MongoDB</code> 扩展<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_5.png\" alt=\"此处输入图片的描述\"></p>\n<ul>\n<li>重启服务器 <code>Nginx</code> 或者 <code>Apache</code></li>\n<li>浏览器访问 <code>index.php</code> 文件,输出 <code>phpinfo</code> 信息，如果有 <code>MongoDB</code> 信息，则安装成功</li>\n</ul>\n<pre><code> [root@localhost mongodb-1.2.8]# systemctl restart nginx   # 重新启动 Nginx\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_6.png\" alt=\"此处输入图片的描述\"></p>\n<p><strong>总结：</strong></p>\n<ul>\n<li><code>pecl 安装</code>和<code>源码编译安装</code>区别就是：方便参数调优。</li>\n<li>在选择 <code>Mongo 扩展</code>的时候，官方提供了两种：<code>mongo</code> 和 <code>mongodb</code></li>\n</ul>\n<p>第一种： <a href=\"https://pecl.php.net/package/mongo\" target=\"_blank\" rel=\"noopener\">https://pecl.php.net/package/mongo</a><br>第二种： <a href=\"https://pecl.php.net/package/mongodb\" target=\"_blank\" rel=\"noopener\">https://pecl.php.net/package/mongodb</a><br>第一种官方提示：<code>This package has been superseded, but is still maintained for bugs and security fixes</code>，已经废弃了，不过 <code>bug</code> 和 <code>security</code> 方面的问题还会继续修复，不支持 <code>PHP7</code> </p>\n<p><strong>建议：</strong></p>\n<ul>\n<li>PHP 版本为 5.x 建议使用 <code>mongo</code> 扩展</li>\n<li>PHP 版本为 7.x 建议使用 <code>mongodb</code> 扩展<br>PHP5.x 可以使用 <code>mongodb</code> 扩展。但是 PHP7.x  不可以使用 <code>mongo</code> 扩展。</li>\n</ul>\n<p><strong>写在最后：</strong><br>如果是自己学习的话还是推荐 <code>yum 安装</code>，因为在你安装过程中会出现<code>缺少各种依赖</code>的<code>报错</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><code>CentOS</code> 下，PHP有多种方式来安装拓展， 主要有 <code>包管理式</code>的 <code>yum 安装</code>、<code>pecl 安装</code>， 以及<code>源码编译安装</code>。<br><code>包管理式</code>的安装卸载尤为方便，而<code>源码编译式</code>的安装则方便参数调优。<br>一般的搭建本机开发环境推荐<code>包管理式</code>的安装，节约时间。而<code>线上部署</code>环境则推荐<code>编译安装</code>， 方便调优。<br>本文以 <code>MongoDB</code> 扩展`安装举例。</p>\n</blockquote>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>PHP版本      ： 7.0.17</li>\n<li>Nginx        ： 1.10.2</li>\n<li>VMware版本号 ： 12.0.0 </li>\n<li>CentOS版本   ： 7.0</li>\n</ul>\n<h2 id=\"一、yum-安装\"><a href=\"#一、yum-安装\" class=\"headerlink\" title=\"一、yum 安装\"></a>一、yum 安装</h2><p><code>yum 方式</code>安装能自动安装拓展的.so动态库，并配置好 <code>php.ini</code><br>注：</p>\n<ul>\n<li>请确保自己 <code>yum 源</code> 里面有对应扩展</li>\n<li>安装完成后重启服务器 <code>Nginx</code> 或者 <code>Apache</code></li>\n<li>浏览器访问 <code>index.php</code> 文件,输出 <code>phpinfo</code> 信息，如果有 <code>MongoDB</code> 信息，则安装成功</li>\n</ul>\n<pre><code>[root@localhost ~]yum search mongodb|grep php        # 搜索 yum 源里面 MongoDB 拓展\n[root@localhost ~]yum -y install php70w-pecl-mongo   # 安装 PHP 对应版本的 MongoDB 扩展\n[root@localhost ~]systemctl restart nginx            # 重新启动 Nginx\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_1.png\" alt=\"此处输入图片的描述\"><br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_2.png\" alt=\"此处输入图片的描述\"></p>\n<h2 id=\"二、pecl-安装\"><a href=\"#二、pecl-安装\" class=\"headerlink\" title=\"二、pecl 安装\"></a>二、pecl 安装</h2><p>官方文档：<a href=\"http://php.net/manual/zh/mongodb.installation.pecl.php\" target=\"_blank\" rel=\"noopener\">http://php.net/manual/zh/mongodb.installation.pecl.php</a></p>\n<pre><code>[root@localhost ~]# pecl install mongodb\n-bash: pecl: 未找到命令\n</code></pre><p>直接输入 <code>pecl install mongodb</code> 会报错，说明 <code>pecl</code> 我们没有安装，安装 <code>pecl</code></p>\n<pre><code>[root@localhost ~]# yum -y install php70w-pear\n[root@localhost ~]# pecl install mongodb\nconfigure: error: Cannot find OpenSSL&#39;s &lt;evp.h&gt;\nERROR: `/var/tmp/mongodb/configure --with-php-config=/usr/bin/php-config&#39; failed\n</code></pre><p>到这一步又会<code>报错</code>，需要我们安装 <code>openssl</code>，安装完成后继续执行上次<code>未执行成功</code>的命令<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_3_1.png\" alt=\"此处输入图片的描述\"></p>\n<pre><code>[root@localhost ~]# yum -y install openssl openssl-devel\n[root@localhost ~]# pecl install mongodb\n[root@localhost ~]# systemctl restart nginx             # 重新启动 Nginx\n</code></pre><p>安装完成后在 <code>PHP</code> 配置文件 <code>php.ini</code> 里面加载 <code>MongoDB</code> 扩展<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_5.png\" alt=\"此处输入图片的描述\"></p>\n<ul>\n<li>安装完成后重启服务器 <code>Nginx</code> 或者 <code>Apache</code></li>\n<li>浏览器访问 <code>index.php</code> 文件,输出 <code>phpinfo</code> 信息，如果有 <code>MongoDB</code> 信息，则安装成功</li>\n</ul>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_6.png\" alt=\"此处输入图片的描述\"></p>\n<h2 id=\"三、源码编译安装\"><a href=\"#三、源码编译安装\" class=\"headerlink\" title=\"三、源码编译安装\"></a>三、源码编译安装</h2><p>源码编译包下载列表：<a href=\"https://pecl.php.net/packages.php\" target=\"_blank\" rel=\"noopener\">https://pecl.php.net/packages.php</a><br>Mongodb包下载地址：<a href=\"https://pecl.php.net/package/mongodb\" target=\"_blank\" rel=\"noopener\">https://pecl.php.net/package/mongodb</a></p>\n<pre><code>[root@localhost ~]# wget http://pecl.php.net/get/mongodb-1.2.8.tgz  #下载源码包\n[root@localhost ~]# tar zxf mongodb-1.2.8.tgz  #解压\n[root@localhost ~]# cd mongodb-1.2.8\n# 可能是 /usr/local/php/bin/phpize 找到自己的 phpize 文件，php-config 同理\n[root@localhost mongodb-1.2.8]# /usr/bin/phpize    \nConfiguring for:\nPHP Api Version:         20151012\nZend Module Api No:      20151012\nZend Extension Api No:   320151012\n[root@localhost mongodb-1.2.8]# ./configure --with-php-config=/usr/bin/php-config\nconfigure: error: Cannot find OpenSSL&#39;s &lt;evp.h&gt;\n</code></pre><p>到了这步<code>又是熟悉的味道又是熟悉的感觉</code>，需要我们安装 <code>openssl</code>，安装完成后继续执行上次<code>未执行成功</code>的命令<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_4.png\" alt=\"此处输入图片的描述\"></p>\n<pre><code>[root@localhost mongodb-1.2.8]# yum -y install openssl openssl-devel\n[root@localhost mongodb-1.2.8]# ./configure --with-php-config=/usr/bin/php-config\n# 确保自己安装了 gcc gcc++ 如果没有安装 yum -y install gcc gcc++\n[root@localhost mongodb-1.2.8]# make &amp;&amp; make install # 编译\n</code></pre><p>说明：<code>php-config</code> 是一个简单的命令行脚本用于<code>获取</code>所安装的 <code>PHP 配置</code>的信息。</p>\n<p>在编译扩展时，如果安装有多个 PHP 版本，可以在配置时用 <code>--with-php-config</code> 选项来指定使用哪一个版本编译，该选项指定了相对应的 <code>php-config</code> 脚本的路径。</p>\n<p><code>编译成功</code>如下图<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_7.png\" alt=\"此处输入图片的描述\"><br>此时在 <code>PHP</code> 配置文件 <code>php.ini</code> 里面加载 <code>MongoDB</code> 扩展<br><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_5.png\" alt=\"此处输入图片的描述\"></p>\n<ul>\n<li>重启服务器 <code>Nginx</code> 或者 <code>Apache</code></li>\n<li>浏览器访问 <code>index.php</code> 文件,输出 <code>phpinfo</code> 信息，如果有 <code>MongoDB</code> 信息，则安装成功</li>\n</ul>\n<pre><code> [root@localhost mongodb-1.2.8]# systemctl restart nginx   # 重新启动 Nginx\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/php_extension_6.png\" alt=\"此处输入图片的描述\"></p>\n<p><strong>总结：</strong></p>\n<ul>\n<li><code>pecl 安装</code>和<code>源码编译安装</code>区别就是：方便参数调优。</li>\n<li>在选择 <code>Mongo 扩展</code>的时候，官方提供了两种：<code>mongo</code> 和 <code>mongodb</code></li>\n</ul>\n<p>第一种： <a href=\"https://pecl.php.net/package/mongo\" target=\"_blank\" rel=\"noopener\">https://pecl.php.net/package/mongo</a><br>第二种： <a href=\"https://pecl.php.net/package/mongodb\" target=\"_blank\" rel=\"noopener\">https://pecl.php.net/package/mongodb</a><br>第一种官方提示：<code>This package has been superseded, but is still maintained for bugs and security fixes</code>，已经废弃了，不过 <code>bug</code> 和 <code>security</code> 方面的问题还会继续修复，不支持 <code>PHP7</code> </p>\n<p><strong>建议：</strong></p>\n<ul>\n<li>PHP 版本为 5.x 建议使用 <code>mongo</code> 扩展</li>\n<li>PHP 版本为 7.x 建议使用 <code>mongodb</code> 扩展<br>PHP5.x 可以使用 <code>mongodb</code> 扩展。但是 PHP7.x  不可以使用 <code>mongo</code> 扩展。</li>\n</ul>\n<p><strong>写在最后：</strong><br>如果是自己学习的话还是推荐 <code>yum 安装</code>，因为在你安装过程中会出现<code>缺少各种依赖</code>的<code>报错</code>。</p>\n"},{"title":"CentOS更改yum源与更新系统","date":"2017-03-05T22:43:42.000Z","_content":">  - VMware版本号：12.0.0  \n>  - CentOS版本：7.0\n\n一、更换之前确保自己安装wget\n-------\n\n``` \n[root@localhost ~]# yum list wget\n```\n没有安装：\n```\n[root@localhost ~]# yum -y install wget\n```\n二、首先备份`/etc/yum.repos.d/CentOS-Base.repo`\n-------\n```\n[root@localhost ~]# cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n三、进入`yum源`配置文件所在文件夹\n-------\n\n```\n[root@localhost yum.repos.d]# cd /etc/yum.repos.d/\n```\n\n四、下载163的`yum源`配置文件，放入`/etc/yum.repos.d/`(操作前做好相应备份)\n-------\n\n```\n[root@localhost yum.repos.d]# wget http://mirrors.163.com/.help/CentOS6-Base-163.repo\n```\n\n五、运行yum makecache生成缓存\n-------\n\n```\n[root@localhost yum.repos.d]# yum makecache\n```\n\n六、运行yum makecache生成缓存\n-------\n\n```\n[root@localhost yum.repos.d]# yum -y update\n```\n\n\n\n\n","source":"_posts/CentOS更改yum源与更新系统.md","raw":"---\ntitle: CentOS更改yum源与更新系统\ndate: 2017-03-06 06:43:42\ntags:\n- yum\ncategories:\n- Linux\n---\n>  - VMware版本号：12.0.0  \n>  - CentOS版本：7.0\n\n一、更换之前确保自己安装wget\n-------\n\n``` \n[root@localhost ~]# yum list wget\n```\n没有安装：\n```\n[root@localhost ~]# yum -y install wget\n```\n二、首先备份`/etc/yum.repos.d/CentOS-Base.repo`\n-------\n```\n[root@localhost ~]# cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n```\n\n三、进入`yum源`配置文件所在文件夹\n-------\n\n```\n[root@localhost yum.repos.d]# cd /etc/yum.repos.d/\n```\n\n四、下载163的`yum源`配置文件，放入`/etc/yum.repos.d/`(操作前做好相应备份)\n-------\n\n```\n[root@localhost yum.repos.d]# wget http://mirrors.163.com/.help/CentOS6-Base-163.repo\n```\n\n五、运行yum makecache生成缓存\n-------\n\n```\n[root@localhost yum.repos.d]# yum makecache\n```\n\n六、运行yum makecache生成缓存\n-------\n\n```\n[root@localhost yum.repos.d]# yum -y update\n```\n\n\n\n\n","slug":"CentOS更改yum源与更新系统","published":1,"updated":"2018-01-04T01:37:41.111Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyepi0004u8w6wn2lupuk","content":"<blockquote>\n<ul>\n<li>VMware版本号：12.0.0  </li>\n<li>CentOS版本：7.0</li>\n</ul>\n</blockquote>\n<h2 id=\"一、更换之前确保自己安装wget\"><a href=\"#一、更换之前确保自己安装wget\" class=\"headerlink\" title=\"一、更换之前确保自己安装wget\"></a>一、更换之前确保自己安装wget</h2><pre><code>[root@localhost ~]# yum list wget\n</code></pre><p>没有安装：</p>\n<pre><code>[root@localhost ~]# yum -y install wget\n</code></pre><h2 id=\"二、首先备份-etc-yum-repos-d-CentOS-Base-repo\"><a href=\"#二、首先备份-etc-yum-repos-d-CentOS-Base-repo\" class=\"headerlink\" title=\"二、首先备份/etc/yum.repos.d/CentOS-Base.repo\"></a>二、首先备份<code>/etc/yum.repos.d/CentOS-Base.repo</code></h2><pre><code>[root@localhost ~]# cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n</code></pre><h2 id=\"三、进入yum源配置文件所在文件夹\"><a href=\"#三、进入yum源配置文件所在文件夹\" class=\"headerlink\" title=\"三、进入yum源配置文件所在文件夹\"></a>三、进入<code>yum源</code>配置文件所在文件夹</h2><pre><code>[root@localhost yum.repos.d]# cd /etc/yum.repos.d/\n</code></pre><h2 id=\"四、下载163的yum源配置文件，放入-etc-yum-repos-d-操作前做好相应备份\"><a href=\"#四、下载163的yum源配置文件，放入-etc-yum-repos-d-操作前做好相应备份\" class=\"headerlink\" title=\"四、下载163的yum源配置文件，放入/etc/yum.repos.d/(操作前做好相应备份)\"></a>四、下载163的<code>yum源</code>配置文件，放入<code>/etc/yum.repos.d/</code>(操作前做好相应备份)</h2><pre><code>[root@localhost yum.repos.d]# wget http://mirrors.163.com/.help/CentOS6-Base-163.repo\n</code></pre><h2 id=\"五、运行yum-makecache生成缓存\"><a href=\"#五、运行yum-makecache生成缓存\" class=\"headerlink\" title=\"五、运行yum makecache生成缓存\"></a>五、运行yum makecache生成缓存</h2><pre><code>[root@localhost yum.repos.d]# yum makecache\n</code></pre><h2 id=\"六、运行yum-makecache生成缓存\"><a href=\"#六、运行yum-makecache生成缓存\" class=\"headerlink\" title=\"六、运行yum makecache生成缓存\"></a>六、运行yum makecache生成缓存</h2><pre><code>[root@localhost yum.repos.d]# yum -y update\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<ul>\n<li>VMware版本号：12.0.0  </li>\n<li>CentOS版本：7.0</li>\n</ul>\n</blockquote>\n<h2 id=\"一、更换之前确保自己安装wget\"><a href=\"#一、更换之前确保自己安装wget\" class=\"headerlink\" title=\"一、更换之前确保自己安装wget\"></a>一、更换之前确保自己安装wget</h2><pre><code>[root@localhost ~]# yum list wget\n</code></pre><p>没有安装：</p>\n<pre><code>[root@localhost ~]# yum -y install wget\n</code></pre><h2 id=\"二、首先备份-etc-yum-repos-d-CentOS-Base-repo\"><a href=\"#二、首先备份-etc-yum-repos-d-CentOS-Base-repo\" class=\"headerlink\" title=\"二、首先备份/etc/yum.repos.d/CentOS-Base.repo\"></a>二、首先备份<code>/etc/yum.repos.d/CentOS-Base.repo</code></h2><pre><code>[root@localhost ~]# cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup\n</code></pre><h2 id=\"三、进入yum源配置文件所在文件夹\"><a href=\"#三、进入yum源配置文件所在文件夹\" class=\"headerlink\" title=\"三、进入yum源配置文件所在文件夹\"></a>三、进入<code>yum源</code>配置文件所在文件夹</h2><pre><code>[root@localhost yum.repos.d]# cd /etc/yum.repos.d/\n</code></pre><h2 id=\"四、下载163的yum源配置文件，放入-etc-yum-repos-d-操作前做好相应备份\"><a href=\"#四、下载163的yum源配置文件，放入-etc-yum-repos-d-操作前做好相应备份\" class=\"headerlink\" title=\"四、下载163的yum源配置文件，放入/etc/yum.repos.d/(操作前做好相应备份)\"></a>四、下载163的<code>yum源</code>配置文件，放入<code>/etc/yum.repos.d/</code>(操作前做好相应备份)</h2><pre><code>[root@localhost yum.repos.d]# wget http://mirrors.163.com/.help/CentOS6-Base-163.repo\n</code></pre><h2 id=\"五、运行yum-makecache生成缓存\"><a href=\"#五、运行yum-makecache生成缓存\" class=\"headerlink\" title=\"五、运行yum makecache生成缓存\"></a>五、运行yum makecache生成缓存</h2><pre><code>[root@localhost yum.repos.d]# yum makecache\n</code></pre><h2 id=\"六、运行yum-makecache生成缓存\"><a href=\"#六、运行yum-makecache生成缓存\" class=\"headerlink\" title=\"六、运行yum makecache生成缓存\"></a>六、运行yum makecache生成缓存</h2><pre><code>[root@localhost yum.repos.d]# yum -y update\n</code></pre>"},{"title":"Git的简单命令","date":"2017-07-22T15:12:51.000Z","_content":"\n**Git 是一款`免费、开源`的`分布式版本控制系统`，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。**\n\n工作原理：\n----------------\n![](http://olln3wpar.bkt.clouddn.com/image/Git/git.png)\n\n**Workspace（`工作区`）：**\n执行 `git add *` 命令就把改动提交到了`暂存区`，执行 `git pull` 命令将远程仓库的数据拉到当前分支并合并，执行 `git checkout [branch-name]` 切换分支\n\n**Index（`暂存区`）：**\n执行 `git commit -m` '说明' 命令就把改动提交到了`仓库区`（当前分支）\n\n\n**Repository（`仓库区`或`本地仓库`）：**\n执行 `git push origin master` 提交到远程仓库，执行 `git clone` 地址将克隆远程仓库到本地\n\n**Remote（`远程仓库`）：**\n\n就是类似 `github`，`coding` 等网站所提供的仓库\n\n**`Git` 术语：**\n\n**仓库（`Repository`）：**\n一个仓库包括了所有的`版本信息`、所有的`分支和标记信息`。在 `Git` 中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本\n\n\n**分支（`Branches`）：**\n一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫 `master`。用户可以选择一个分支，选择一个分支执行命令 `git checkout branch`\n\n\n**标记（`Tags`）：**\n一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2016年11月17号在testing分支上的代码状态\n\n\n**提交（`Commit`）：**\n提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人\n\n\n**修订（`Revision`）：**\n用来表示代码的一个版本状态。`Git` 通过用 `SHA1 hash `算法表示的 `id` 来标识不同的版本。每一个 `SHA1 id` 都是160位长，16进制标识的字符串.。最新的版本可以通过 `HEAD` 来获取。之前的版本可以通 `HEAD~1` 来获取，以此类推\n\n一、创建仓库\n----------------\n```\n# 在当前目录新建一个Git代码库\n$ git init\n \n# 新建一个目录，将其初始化为 Git 代码库\n$ git init [project-name]\n \n# 下载一个项目和它的整个代码历史（各个分支提交记录等）\n$ git clone [url]\n```\n`git init` 后会出现 `.git` 文件夹，里面有配置文件，如果没有 `git bash` 里面输入 `ls -lah` 就可以看到了\n\n\n二、配置\n----------------\n`Git` 的设置文件为 `.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）\n```\n# 显示当前的Git配置\n$ git config --list\n \n# 编辑 Git 配置文件，只是配置用户信息的话直接看下面两行命令即可\n$ git config -e [--global]\n \n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n三、增加/删除文件\n----------------\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n \n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n \n# 添加当前目录的所有文件到暂存区\n$ git add .\n \n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n \n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n \n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n \n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n四、提交文件\n----------------\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n \n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n \n# 提交工作区自上次 commit 之后的变化，直接到仓库区\n$ git commit -a\n \n# 提交时显示所有 diff 信息\n$ git commit -v\n \n# 使用一次新的 commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息\n$ git commit --amend -m [message]\n \n# 重做上一次 commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n五、推送远程服务器\n----------------\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n \n# 显示所有远程仓库\n$ git remote -v\n \n# 显示某个远程仓库的信息\n$ git remote show [remote]\n \n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n \n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n \n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n \n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n \n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n六、撤销\n----------------\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n \n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n \n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n \n# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n$ git reset [file]\n \n# 重置暂存区与工作区，与上一次 commit 保持一致\n$ git reset --hard\n \n# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n \n# 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致\n$ git reset --hard [commit]\n \n# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n \n# 新建一个 commit，用来撤销指定 commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n \n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n七、分支\n----------------\n```\n# 列出所有本地分支\n$ git branch\n \n# 列出所有远程分支\n$ git branch -r\n \n# 列出所有本地分支和远程分支\n$ git branch -a\n \n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n \n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n \n# 新建一个分支，指向指定 commit\n$ git branch [branch] [commit]\n \n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n \n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n \n# 切换到上一个分支\n$ git checkout -\n \n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n \n# 合并指定分支到当前分支\n$ git merge [branch]\n \n# 选择一个 commit，合并进当前分支\n$ git cherry-pick [commit]\n \n# 删除分支\n$ git branch -d [branch-name]\n \n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n八、标签\n----------------\n```\n# 列出所有 tag\n$ git tag\n \n# 新建一个 tag 在当前 commit\n$ git tag [tag]\n \n# 新建一个 tag 在指定 commit\n$ git tag [tag] [commit]\n \n# 删除本地 tag\n$ git tag -d [tag]\n \n# 删除远程 tag\n$ git push origin :refs/tags/[tagName]\n \n# 查看 tag 信息\n$ git show [tag]\n \n# 提交指定 tag\n$ git push [remote] [tag]\n \n# 提交所有 tag\n$ git push [remote] --tags\n \n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n九、查看信息\n----------------\n```\n# 显示有变更的文件\n$ git status\n \n# 显示当前分支的版本历史\n$ git log\n \n# 显示 commit 历史，以及每次 commit 发生变更的文件\n$ git log --stat\n \n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n \n# 显示某个 commit 之后的所有变动，每个 commit 占据一行\n$ git log [tag] HEAD --pretty=format:%s\n \n# 显示某个 commit 之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n \n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n \n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n \n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n \n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n \n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n$ git blame [file]\n \n# 显示暂存区和工作区的差异\n$ git diff\n \n# 显示暂存区和上一个 commit 的差异\n$ git diff --cached [file]\n \n# 显示工作区与当前分支最新 commit 之间的差异\n$ git diff HEAD\n \n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n \n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n \n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n \n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n \n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n \n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n十、其他\n----------------\n```\n# 生成一个可供发布的压缩包\n$ git archive\n```\n\n十一、参考文章：\n----------------","source":"_posts/Git的简单命令.md","raw":"---\ntitle: Git的简单命令\ndate: 2017-07-22 23:12:51\ncategories:\n- Git\n---\n\n**Git 是一款`免费、开源`的`分布式版本控制系统`，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。**\n\n工作原理：\n----------------\n![](http://olln3wpar.bkt.clouddn.com/image/Git/git.png)\n\n**Workspace（`工作区`）：**\n执行 `git add *` 命令就把改动提交到了`暂存区`，执行 `git pull` 命令将远程仓库的数据拉到当前分支并合并，执行 `git checkout [branch-name]` 切换分支\n\n**Index（`暂存区`）：**\n执行 `git commit -m` '说明' 命令就把改动提交到了`仓库区`（当前分支）\n\n\n**Repository（`仓库区`或`本地仓库`）：**\n执行 `git push origin master` 提交到远程仓库，执行 `git clone` 地址将克隆远程仓库到本地\n\n**Remote（`远程仓库`）：**\n\n就是类似 `github`，`coding` 等网站所提供的仓库\n\n**`Git` 术语：**\n\n**仓库（`Repository`）：**\n一个仓库包括了所有的`版本信息`、所有的`分支和标记信息`。在 `Git` 中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本\n\n\n**分支（`Branches`）：**\n一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫 `master`。用户可以选择一个分支，选择一个分支执行命令 `git checkout branch`\n\n\n**标记（`Tags`）：**\n一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2016年11月17号在testing分支上的代码状态\n\n\n**提交（`Commit`）：**\n提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人\n\n\n**修订（`Revision`）：**\n用来表示代码的一个版本状态。`Git` 通过用 `SHA1 hash `算法表示的 `id` 来标识不同的版本。每一个 `SHA1 id` 都是160位长，16进制标识的字符串.。最新的版本可以通过 `HEAD` 来获取。之前的版本可以通 `HEAD~1` 来获取，以此类推\n\n一、创建仓库\n----------------\n```\n# 在当前目录新建一个Git代码库\n$ git init\n \n# 新建一个目录，将其初始化为 Git 代码库\n$ git init [project-name]\n \n# 下载一个项目和它的整个代码历史（各个分支提交记录等）\n$ git clone [url]\n```\n`git init` 后会出现 `.git` 文件夹，里面有配置文件，如果没有 `git bash` 里面输入 `ls -lah` 就可以看到了\n\n\n二、配置\n----------------\n`Git` 的设置文件为 `.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）\n```\n# 显示当前的Git配置\n$ git config --list\n \n# 编辑 Git 配置文件，只是配置用户信息的话直接看下面两行命令即可\n$ git config -e [--global]\n \n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n三、增加/删除文件\n----------------\n```\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n \n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n \n# 添加当前目录的所有文件到暂存区\n$ git add .\n \n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n \n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n \n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n \n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n四、提交文件\n----------------\n```\n# 提交暂存区到仓库区\n$ git commit -m [message]\n \n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n \n# 提交工作区自上次 commit 之后的变化，直接到仓库区\n$ git commit -a\n \n# 提交时显示所有 diff 信息\n$ git commit -v\n \n# 使用一次新的 commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息\n$ git commit --amend -m [message]\n \n# 重做上一次 commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n五、推送远程服务器\n----------------\n```\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n \n# 显示所有远程仓库\n$ git remote -v\n \n# 显示某个远程仓库的信息\n$ git remote show [remote]\n \n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n \n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n \n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n \n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n \n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n六、撤销\n----------------\n```\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n \n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n \n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n \n# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n$ git reset [file]\n \n# 重置暂存区与工作区，与上一次 commit 保持一致\n$ git reset --hard\n \n# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n \n# 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致\n$ git reset --hard [commit]\n \n# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n \n# 新建一个 commit，用来撤销指定 commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n \n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n七、分支\n----------------\n```\n# 列出所有本地分支\n$ git branch\n \n# 列出所有远程分支\n$ git branch -r\n \n# 列出所有本地分支和远程分支\n$ git branch -a\n \n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n \n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n \n# 新建一个分支，指向指定 commit\n$ git branch [branch] [commit]\n \n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n \n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n \n# 切换到上一个分支\n$ git checkout -\n \n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n \n# 合并指定分支到当前分支\n$ git merge [branch]\n \n# 选择一个 commit，合并进当前分支\n$ git cherry-pick [commit]\n \n# 删除分支\n$ git branch -d [branch-name]\n \n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n八、标签\n----------------\n```\n# 列出所有 tag\n$ git tag\n \n# 新建一个 tag 在当前 commit\n$ git tag [tag]\n \n# 新建一个 tag 在指定 commit\n$ git tag [tag] [commit]\n \n# 删除本地 tag\n$ git tag -d [tag]\n \n# 删除远程 tag\n$ git push origin :refs/tags/[tagName]\n \n# 查看 tag 信息\n$ git show [tag]\n \n# 提交指定 tag\n$ git push [remote] [tag]\n \n# 提交所有 tag\n$ git push [remote] --tags\n \n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n九、查看信息\n----------------\n```\n# 显示有变更的文件\n$ git status\n \n# 显示当前分支的版本历史\n$ git log\n \n# 显示 commit 历史，以及每次 commit 发生变更的文件\n$ git log --stat\n \n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n \n# 显示某个 commit 之后的所有变动，每个 commit 占据一行\n$ git log [tag] HEAD --pretty=format:%s\n \n# 显示某个 commit 之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n \n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n \n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n \n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n \n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n \n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n$ git blame [file]\n \n# 显示暂存区和工作区的差异\n$ git diff\n \n# 显示暂存区和上一个 commit 的差异\n$ git diff --cached [file]\n \n# 显示工作区与当前分支最新 commit 之间的差异\n$ git diff HEAD\n \n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n \n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n \n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n \n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n \n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n \n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n十、其他\n----------------\n```\n# 生成一个可供发布的压缩包\n$ git archive\n```\n\n十一、参考文章：\n----------------","slug":"Git的简单命令","published":1,"updated":"2018-01-03T02:05:07.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyepl0005u8w61yqerdmh","content":"<p><strong>Git 是一款<code>免费、开源</code>的<code>分布式版本控制系统</code>，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</strong></p>\n<h2 id=\"工作原理：\"><a href=\"#工作原理：\" class=\"headerlink\" title=\"工作原理：\"></a>工作原理：</h2><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/Git/git.png\" alt=\"\"></p>\n<p><strong>Workspace（<code>工作区</code>）：</strong><br>执行 <code>git add *</code> 命令就把改动提交到了<code>暂存区</code>，执行 <code>git pull</code> 命令将远程仓库的数据拉到当前分支并合并，执行 <code>git checkout [branch-name]</code> 切换分支</p>\n<p><strong>Index（<code>暂存区</code>）：</strong><br>执行 <code>git commit -m</code> ‘说明’ 命令就把改动提交到了<code>仓库区</code>（当前分支）</p>\n<p><strong>Repository（<code>仓库区</code>或<code>本地仓库</code>）：</strong><br>执行 <code>git push origin master</code> 提交到远程仓库，执行 <code>git clone</code> 地址将克隆远程仓库到本地</p>\n<p><strong>Remote（<code>远程仓库</code>）：</strong></p>\n<p>就是类似 <code>github</code>，<code>coding</code> 等网站所提供的仓库</p>\n<p><strong><code>Git</code> 术语：</strong></p>\n<p><strong>仓库（<code>Repository</code>）：</strong><br>一个仓库包括了所有的<code>版本信息</code>、所有的<code>分支和标记信息</code>。在 <code>Git</code> 中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本</p>\n<p><strong>分支（<code>Branches</code>）：</strong><br>一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫 <code>master</code>。用户可以选择一个分支，选择一个分支执行命令 <code>git checkout branch</code></p>\n<p><strong>标记（<code>Tags</code>）：</strong><br>一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2016年11月17号在testing分支上的代码状态</p>\n<p><strong>提交（<code>Commit</code>）：</strong><br>提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人</p>\n<p><strong>修订（<code>Revision</code>）：</strong><br>用来表示代码的一个版本状态。<code>Git</code> 通过用 <code>SHA1 hash</code>算法表示的 <code>id</code> 来标识不同的版本。每一个 <code>SHA1 id</code> 都是160位长，16进制标识的字符串.。最新的版本可以通过 <code>HEAD</code> 来获取。之前的版本可以通 <code>HEAD~1</code> 来获取，以此类推</p>\n<h2 id=\"一、创建仓库\"><a href=\"#一、创建仓库\" class=\"headerlink\" title=\"一、创建仓库\"></a>一、创建仓库</h2><pre><code># 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为 Git 代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史（各个分支提交记录等）\n$ git clone [url]\n</code></pre><p><code>git init</code> 后会出现 <code>.git</code> 文件夹，里面有配置文件，如果没有 <code>git bash</code> 里面输入 <code>ls -lah</code> 就可以看到了</p>\n<h2 id=\"二、配置\"><a href=\"#二、配置\" class=\"headerlink\" title=\"二、配置\"></a>二、配置</h2><p><code>Git</code> 的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）</p>\n<pre><code># 显示当前的Git配置\n$ git config --list\n\n# 编辑 Git 配置文件，只是配置用户信息的话直接看下面两行命令即可\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n</code></pre><h2 id=\"三、增加-删除文件\"><a href=\"#三、增加-删除文件\" class=\"headerlink\" title=\"三、增加/删除文件\"></a>三、增加/删除文件</h2><pre><code># 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n</code></pre><h2 id=\"四、提交文件\"><a href=\"#四、提交文件\" class=\"headerlink\" title=\"四、提交文件\"></a>四、提交文件</h2><pre><code># 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次 commit 之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有 diff 信息\n$ git commit -v\n\n# 使用一次新的 commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次 commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n</code></pre><h2 id=\"五、推送远程服务器\"><a href=\"#五、推送远程服务器\" class=\"headerlink\" title=\"五、推送远程服务器\"></a>五、推送远程服务器</h2><pre><code># 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n</code></pre><h2 id=\"六、撤销\"><a href=\"#六、撤销\" class=\"headerlink\" title=\"六、撤销\"></a>六、撤销</h2><pre><code># 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次 commit 保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致\n$ git reset --hard [commit]\n\n# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个 commit，用来撤销指定 commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n</code></pre><h2 id=\"七、分支\"><a href=\"#七、分支\" class=\"headerlink\" title=\"七、分支\"></a>七、分支</h2><pre><code># 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定 commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个 commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n</code></pre><h2 id=\"八、标签\"><a href=\"#八、标签\" class=\"headerlink\" title=\"八、标签\"></a>八、标签</h2><pre><code># 列出所有 tag\n$ git tag\n\n# 新建一个 tag 在当前 commit\n$ git tag [tag]\n\n# 新建一个 tag 在指定 commit\n$ git tag [tag] [commit]\n\n# 删除本地 tag\n$ git tag -d [tag]\n\n# 删除远程 tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看 tag 信息\n$ git show [tag]\n\n# 提交指定 tag\n$ git push [remote] [tag]\n\n# 提交所有 tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n</code></pre><h2 id=\"九、查看信息\"><a href=\"#九、查看信息\" class=\"headerlink\" title=\"九、查看信息\"></a>九、查看信息</h2><pre><code># 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示 commit 历史，以及每次 commit 发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个 commit 之后的所有变动，每个 commit 占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个 commit 的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新 commit 之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat &quot;@{0 day ago}&quot;\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n</code></pre><h2 id=\"十、其他\"><a href=\"#十、其他\" class=\"headerlink\" title=\"十、其他\"></a>十、其他</h2><pre><code># 生成一个可供发布的压缩包\n$ git archive\n</code></pre><h2 id=\"十一、参考文章：\"><a href=\"#十一、参考文章：\" class=\"headerlink\" title=\"十一、参考文章：\"></a>十一、参考文章：</h2>","site":{"data":{}},"excerpt":"","more":"<p><strong>Git 是一款<code>免费、开源</code>的<code>分布式版本控制系统</code>，用于敏捷高效地处理任何或小或大的项目。Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。</strong></p>\n<h2 id=\"工作原理：\"><a href=\"#工作原理：\" class=\"headerlink\" title=\"工作原理：\"></a>工作原理：</h2><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/Git/git.png\" alt=\"\"></p>\n<p><strong>Workspace（<code>工作区</code>）：</strong><br>执行 <code>git add *</code> 命令就把改动提交到了<code>暂存区</code>，执行 <code>git pull</code> 命令将远程仓库的数据拉到当前分支并合并，执行 <code>git checkout [branch-name]</code> 切换分支</p>\n<p><strong>Index（<code>暂存区</code>）：</strong><br>执行 <code>git commit -m</code> ‘说明’ 命令就把改动提交到了<code>仓库区</code>（当前分支）</p>\n<p><strong>Repository（<code>仓库区</code>或<code>本地仓库</code>）：</strong><br>执行 <code>git push origin master</code> 提交到远程仓库，执行 <code>git clone</code> 地址将克隆远程仓库到本地</p>\n<p><strong>Remote（<code>远程仓库</code>）：</strong></p>\n<p>就是类似 <code>github</code>，<code>coding</code> 等网站所提供的仓库</p>\n<p><strong><code>Git</code> 术语：</strong></p>\n<p><strong>仓库（<code>Repository</code>）：</strong><br>一个仓库包括了所有的<code>版本信息</code>、所有的<code>分支和标记信息</code>。在 <code>Git</code> 中仓库的每份拷贝都是完整的。仓库让你可以从中取得你的工作副本</p>\n<p><strong>分支（<code>Branches</code>）：</strong><br>一个分支意味着一个独立的、拥有自己历史信息的代码线（code line）。你可以从已有的代码中生成一个新的分支，这个分支与剩余的分支完全独立。默认的分支往往是叫 <code>master</code>。用户可以选择一个分支，选择一个分支执行命令 <code>git checkout branch</code></p>\n<p><strong>标记（<code>Tags</code>）：</strong><br>一个标记指的是某个分支某个特定时间点的状态。通过标记，可以很方便的切换到标记时的状态，例如2016年11月17号在testing分支上的代码状态</p>\n<p><strong>提交（<code>Commit</code>）：</strong><br>提交代码后，仓库会创建一个新的版本。这个版本可以在后续被重新获得。每次提交都包括作者和提交者，作者和提交者可以是不同的人</p>\n<p><strong>修订（<code>Revision</code>）：</strong><br>用来表示代码的一个版本状态。<code>Git</code> 通过用 <code>SHA1 hash</code>算法表示的 <code>id</code> 来标识不同的版本。每一个 <code>SHA1 id</code> 都是160位长，16进制标识的字符串.。最新的版本可以通过 <code>HEAD</code> 来获取。之前的版本可以通 <code>HEAD~1</code> 来获取，以此类推</p>\n<h2 id=\"一、创建仓库\"><a href=\"#一、创建仓库\" class=\"headerlink\" title=\"一、创建仓库\"></a>一、创建仓库</h2><pre><code># 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为 Git 代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史（各个分支提交记录等）\n$ git clone [url]\n</code></pre><p><code>git init</code> 后会出现 <code>.git</code> 文件夹，里面有配置文件，如果没有 <code>git bash</code> 里面输入 <code>ls -lah</code> 就可以看到了</p>\n<h2 id=\"二、配置\"><a href=\"#二、配置\" class=\"headerlink\" title=\"二、配置\"></a>二、配置</h2><p><code>Git</code> 的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）</p>\n<pre><code># 显示当前的Git配置\n$ git config --list\n\n# 编辑 Git 配置文件，只是配置用户信息的话直接看下面两行命令即可\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n</code></pre><h2 id=\"三、增加-删除文件\"><a href=\"#三、增加-删除文件\" class=\"headerlink\" title=\"三、增加/删除文件\"></a>三、增加/删除文件</h2><pre><code># 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n</code></pre><h2 id=\"四、提交文件\"><a href=\"#四、提交文件\" class=\"headerlink\" title=\"四、提交文件\"></a>四、提交文件</h2><pre><code># 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次 commit 之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有 diff 信息\n$ git commit -v\n\n# 使用一次新的 commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次 commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n</code></pre><h2 id=\"五、推送远程服务器\"><a href=\"#五、推送远程服务器\" class=\"headerlink\" title=\"五、推送远程服务器\"></a>五、推送远程服务器</h2><pre><code># 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n</code></pre><h2 id=\"六、撤销\"><a href=\"#六、撤销\" class=\"headerlink\" title=\"六、撤销\"></a>六、撤销</h2><pre><code># 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次 commit 保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定 commit，同时重置暂存区和工作区，与指定 commit 一致\n$ git reset --hard [commit]\n\n# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个 commit，用来撤销指定 commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n</code></pre><h2 id=\"七、分支\"><a href=\"#七、分支\" class=\"headerlink\" title=\"七、分支\"></a>七、分支</h2><pre><code># 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定 commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个 commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n</code></pre><h2 id=\"八、标签\"><a href=\"#八、标签\" class=\"headerlink\" title=\"八、标签\"></a>八、标签</h2><pre><code># 列出所有 tag\n$ git tag\n\n# 新建一个 tag 在当前 commit\n$ git tag [tag]\n\n# 新建一个 tag 在指定 commit\n$ git tag [tag] [commit]\n\n# 删除本地 tag\n$ git tag -d [tag]\n\n# 删除远程 tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看 tag 信息\n$ git show [tag]\n\n# 提交指定 tag\n$ git push [remote] [tag]\n\n# 提交所有 tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n</code></pre><h2 id=\"九、查看信息\"><a href=\"#九、查看信息\" class=\"headerlink\" title=\"九、查看信息\"></a>九、查看信息</h2><pre><code># 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示 commit 历史，以及每次 commit 发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个 commit 之后的所有变动，每个 commit 占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个 commit 的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新 commit 之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat &quot;@{0 day ago}&quot;\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n</code></pre><h2 id=\"十、其他\"><a href=\"#十、其他\" class=\"headerlink\" title=\"十、其他\"></a>十、其他</h2><pre><code># 生成一个可供发布的压缩包\n$ git archive\n</code></pre><h2 id=\"十一、参考文章：\"><a href=\"#十一、参考文章：\" class=\"headerlink\" title=\"十一、参考文章：\"></a>十一、参考文章：</h2>"},{"title":"Linux(CentOS)下安装Redis（一）","date":"2017-02-12T22:19:19.000Z","_content":"整理一下最近学习Redis的心得\n----------------\n\n - VMware版本号：11.1.2 \n - CentOS版本：6.6\n \n\n\n----------\n\n\n下载redis\n-------\n\n    wget http://download.redis.io/releases/redis-3.0.0.tar.gz\n    \n\n\n----------\n\n编译源程序\n-----\n\n    tar zxvf redis-3.0.0.tar.gz \n    cd redis-3.0.0 \n    make\n    cd src\n    make install\n   \n\n\n----------\n\n\n创建redis目录，移动文件，为了便于管理\n---------------------\n\n```\nmkdir -p /usr/local/redis/bin \nmkdir -p /usr/local/redis/etc\nmv /src/redis-3.0.0/redis.conf /usr/local/redis/etc\ncd /src/redis-3.0.0/src\nmv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis/bin\n```\n\n\n----------\n\n\n启动redis服务（redis服务端的默认连接端口是`6379`）\n-------------------------------\n\n```\n/usr/local/redis/bin/redis-server\n/usr/local/redis/etc/redis.conf\n```\n默认情况下，redis不是在后台运行的，我们需要把开启的redis后台运行\n\n```\nvi /usr/local/redis/etc/redis.conf \n```\n将`daemonize`的值改为`yes`\n \n查看是否启动\n\n```\nps -ef | grep redis\n```\n\n查看是否占用6379端口号\n\n```\nnetstat -tunpl | grep 6379\n```\n\n再启动redis\n\n```\n/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf\n```\n\n\n----------\n\n客户端连接\n-----\n\n```\n /usr/local/redis/bin/redis-cli\n```\n退出客户端\n\n```\nexit\n```\n或者\n\n```\nquit\n```\n再或者`Ctrl`+`C`\n\n\n----------\n\n停止redis\n-------\n\n```\n/usr/local/redis/bin/redis-cli shutdown\n```\n或者\n\n```\npkill redis-server\n```\n\n\n----------\n## redis的一些配置 ##\n`daemonize`如果需要在后台运行，把该项改为yes\n`pidfile`配置多个pid的地质，默认在/var/ren/redis.pid\n`bind`绑定ip,设置后只接受来自该ip的请求\n`port`监听端口，默认为6379 \n`timeout`设置客户端连接时的超时时间，单位为秒 \n`loglevel`分为4级，debug、verbose、notice、warning\n`logfile`配置log文件地址 databases 设置数据库的个数，默认使用的数据库为0 \n`save`设置redis进行数据库镜像的频率 \n`rdbcompression`在进行镜像备份时，是否进行压缩\n`Dbfilename`镜像备份文件的文件名\n`Dir`数据库镜像备份的文件放置路径 \n`Slaveof`设置数据库为其他数据库的从数据库\n`Masteauth`主数据库连接需要的密码验证 \n`Requirepass`设置登陆时需要的使用的密码 \n`Maxclients`限制同时连接的客户数量\n`Maxmemory`设置redis能够使用的最大内存 \n`Appendonly`开启append only模式 \n`Appendfsync`设置对appendonly.aof文件同步的频率\n`vm-enabled`是否开启虚拟内存支持\n`vm-swap-file`设置虚拟内存的交换文件路径\n`vm-max-memory`设置redis使用的最大物理内存大小\n`vm-page-size`设置虚拟内存的页大小\n`vm-pages`设置交换文件的总的page数量\n`vm-max-threads`设置VMIO同时使用的线程数量\n`Glueoutputbuf`设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n`hash-max-zipmap-entries`设置hash的临界值\n`Activerehashing`重置hash，默认为开启\n\n\n----------\n\n\n**相关链接：**\n[Linux下PHP安装Redis扩展（二）][1]\n[Redis主从配置（三）][2]\n[Redis集群搭建与简单使用（四）][3]\n[Redis持久化（五）][4]\n\n\n  [1]: https://segmentfault.com/a/1190000008420258\n  [2]: https://segmentfault.com/a/1190000008469182\n  [3]: https://segmentfault.com/a/1190000008448919\n  [4]: https://segmentfault.com/a/1190000008639459","source":"_posts/Linux-CentOS-下安装Redis（一）.md","raw":"---\ntitle: Linux(CentOS)下安装Redis（一）\ndate: 2017-02-13 06:19:19\ntags:\n- Redis\n- yum\ncategories:\n- NoSQL\n---\n整理一下最近学习Redis的心得\n----------------\n\n - VMware版本号：11.1.2 \n - CentOS版本：6.6\n \n\n\n----------\n\n\n下载redis\n-------\n\n    wget http://download.redis.io/releases/redis-3.0.0.tar.gz\n    \n\n\n----------\n\n编译源程序\n-----\n\n    tar zxvf redis-3.0.0.tar.gz \n    cd redis-3.0.0 \n    make\n    cd src\n    make install\n   \n\n\n----------\n\n\n创建redis目录，移动文件，为了便于管理\n---------------------\n\n```\nmkdir -p /usr/local/redis/bin \nmkdir -p /usr/local/redis/etc\nmv /src/redis-3.0.0/redis.conf /usr/local/redis/etc\ncd /src/redis-3.0.0/src\nmv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis/bin\n```\n\n\n----------\n\n\n启动redis服务（redis服务端的默认连接端口是`6379`）\n-------------------------------\n\n```\n/usr/local/redis/bin/redis-server\n/usr/local/redis/etc/redis.conf\n```\n默认情况下，redis不是在后台运行的，我们需要把开启的redis后台运行\n\n```\nvi /usr/local/redis/etc/redis.conf \n```\n将`daemonize`的值改为`yes`\n \n查看是否启动\n\n```\nps -ef | grep redis\n```\n\n查看是否占用6379端口号\n\n```\nnetstat -tunpl | grep 6379\n```\n\n再启动redis\n\n```\n/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf\n```\n\n\n----------\n\n客户端连接\n-----\n\n```\n /usr/local/redis/bin/redis-cli\n```\n退出客户端\n\n```\nexit\n```\n或者\n\n```\nquit\n```\n再或者`Ctrl`+`C`\n\n\n----------\n\n停止redis\n-------\n\n```\n/usr/local/redis/bin/redis-cli shutdown\n```\n或者\n\n```\npkill redis-server\n```\n\n\n----------\n## redis的一些配置 ##\n`daemonize`如果需要在后台运行，把该项改为yes\n`pidfile`配置多个pid的地质，默认在/var/ren/redis.pid\n`bind`绑定ip,设置后只接受来自该ip的请求\n`port`监听端口，默认为6379 \n`timeout`设置客户端连接时的超时时间，单位为秒 \n`loglevel`分为4级，debug、verbose、notice、warning\n`logfile`配置log文件地址 databases 设置数据库的个数，默认使用的数据库为0 \n`save`设置redis进行数据库镜像的频率 \n`rdbcompression`在进行镜像备份时，是否进行压缩\n`Dbfilename`镜像备份文件的文件名\n`Dir`数据库镜像备份的文件放置路径 \n`Slaveof`设置数据库为其他数据库的从数据库\n`Masteauth`主数据库连接需要的密码验证 \n`Requirepass`设置登陆时需要的使用的密码 \n`Maxclients`限制同时连接的客户数量\n`Maxmemory`设置redis能够使用的最大内存 \n`Appendonly`开启append only模式 \n`Appendfsync`设置对appendonly.aof文件同步的频率\n`vm-enabled`是否开启虚拟内存支持\n`vm-swap-file`设置虚拟内存的交换文件路径\n`vm-max-memory`设置redis使用的最大物理内存大小\n`vm-page-size`设置虚拟内存的页大小\n`vm-pages`设置交换文件的总的page数量\n`vm-max-threads`设置VMIO同时使用的线程数量\n`Glueoutputbuf`设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启\n`hash-max-zipmap-entries`设置hash的临界值\n`Activerehashing`重置hash，默认为开启\n\n\n----------\n\n\n**相关链接：**\n[Linux下PHP安装Redis扩展（二）][1]\n[Redis主从配置（三）][2]\n[Redis集群搭建与简单使用（四）][3]\n[Redis持久化（五）][4]\n\n\n  [1]: https://segmentfault.com/a/1190000008420258\n  [2]: https://segmentfault.com/a/1190000008469182\n  [3]: https://segmentfault.com/a/1190000008448919\n  [4]: https://segmentfault.com/a/1190000008639459","slug":"Linux-CentOS-下安装Redis（一）","published":1,"updated":"2018-01-04T02:54:07.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyepu0006u8w6rivqvxmk","content":"<h2 id=\"整理一下最近学习Redis的心得\"><a href=\"#整理一下最近学习Redis的心得\" class=\"headerlink\" title=\"整理一下最近学习Redis的心得\"></a>整理一下最近学习Redis的心得</h2><ul>\n<li>VMware版本号：11.1.2 </li>\n<li>CentOS版本：6.6</li>\n</ul>\n<hr>\n<h2 id=\"下载redis\"><a href=\"#下载redis\" class=\"headerlink\" title=\"下载redis\"></a>下载redis</h2><pre><code>wget http://download.redis.io/releases/redis-3.0.0.tar.gz\n</code></pre><hr>\n<h2 id=\"编译源程序\"><a href=\"#编译源程序\" class=\"headerlink\" title=\"编译源程序\"></a>编译源程序</h2><pre><code>tar zxvf redis-3.0.0.tar.gz \ncd redis-3.0.0 \nmake\ncd src\nmake install\n</code></pre><hr>\n<h2 id=\"创建redis目录，移动文件，为了便于管理\"><a href=\"#创建redis目录，移动文件，为了便于管理\" class=\"headerlink\" title=\"创建redis目录，移动文件，为了便于管理\"></a>创建redis目录，移动文件，为了便于管理</h2><pre><code>mkdir -p /usr/local/redis/bin \nmkdir -p /usr/local/redis/etc\nmv /src/redis-3.0.0/redis.conf /usr/local/redis/etc\ncd /src/redis-3.0.0/src\nmv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis/bin\n</code></pre><hr>\n<h2 id=\"启动redis服务（redis服务端的默认连接端口是6379）\"><a href=\"#启动redis服务（redis服务端的默认连接端口是6379）\" class=\"headerlink\" title=\"启动redis服务（redis服务端的默认连接端口是6379）\"></a>启动redis服务（redis服务端的默认连接端口是<code>6379</code>）</h2><pre><code>/usr/local/redis/bin/redis-server\n/usr/local/redis/etc/redis.conf\n</code></pre><p>默认情况下，redis不是在后台运行的，我们需要把开启的redis后台运行</p>\n<pre><code>vi /usr/local/redis/etc/redis.conf\n</code></pre><p>将<code>daemonize</code>的值改为<code>yes</code></p>\n<p>查看是否启动</p>\n<pre><code>ps -ef | grep redis\n</code></pre><p>查看是否占用6379端口号</p>\n<pre><code>netstat -tunpl | grep 6379\n</code></pre><p>再启动redis</p>\n<pre><code>/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf\n</code></pre><hr>\n<h2 id=\"客户端连接\"><a href=\"#客户端连接\" class=\"headerlink\" title=\"客户端连接\"></a>客户端连接</h2><pre><code> /usr/local/redis/bin/redis-cli\n</code></pre><p>退出客户端</p>\n<pre><code>exit\n</code></pre><p>或者</p>\n<pre><code>quit\n</code></pre><p>再或者<code>Ctrl</code>+<code>C</code></p>\n<hr>\n<h2 id=\"停止redis\"><a href=\"#停止redis\" class=\"headerlink\" title=\"停止redis\"></a>停止redis</h2><pre><code>/usr/local/redis/bin/redis-cli shutdown\n</code></pre><p>或者</p>\n<pre><code>pkill redis-server\n</code></pre><hr>\n<h2 id=\"redis的一些配置\"><a href=\"#redis的一些配置\" class=\"headerlink\" title=\"redis的一些配置\"></a>redis的一些配置</h2><p><code>daemonize</code>如果需要在后台运行，把该项改为yes<br><code>pidfile</code>配置多个pid的地质，默认在/var/ren/redis.pid<br><code>bind</code>绑定ip,设置后只接受来自该ip的请求<br><code>port</code>监听端口，默认为6379<br><code>timeout</code>设置客户端连接时的超时时间，单位为秒<br><code>loglevel</code>分为4级，debug、verbose、notice、warning<br><code>logfile</code>配置log文件地址 databases 设置数据库的个数，默认使用的数据库为0<br><code>save</code>设置redis进行数据库镜像的频率<br><code>rdbcompression</code>在进行镜像备份时，是否进行压缩<br><code>Dbfilename</code>镜像备份文件的文件名<br><code>Dir</code>数据库镜像备份的文件放置路径<br><code>Slaveof</code>设置数据库为其他数据库的从数据库<br><code>Masteauth</code>主数据库连接需要的密码验证<br><code>Requirepass</code>设置登陆时需要的使用的密码<br><code>Maxclients</code>限制同时连接的客户数量<br><code>Maxmemory</code>设置redis能够使用的最大内存<br><code>Appendonly</code>开启append only模式<br><code>Appendfsync</code>设置对appendonly.aof文件同步的频率<br><code>vm-enabled</code>是否开启虚拟内存支持<br><code>vm-swap-file</code>设置虚拟内存的交换文件路径<br><code>vm-max-memory</code>设置redis使用的最大物理内存大小<br><code>vm-page-size</code>设置虚拟内存的页大小<br><code>vm-pages</code>设置交换文件的总的page数量<br><code>vm-max-threads</code>设置VMIO同时使用的线程数量<br><code>Glueoutputbuf</code>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启<br><code>hash-max-zipmap-entries</code>设置hash的临界值<br><code>Activerehashing</code>重置hash，默认为开启</p>\n<hr>\n<p><strong>相关链接：</strong><br><a href=\"https://segmentfault.com/a/1190000008420258\" target=\"_blank\" rel=\"noopener\">Linux下PHP安装Redis扩展（二）</a><br><a href=\"https://segmentfault.com/a/1190000008469182\" target=\"_blank\" rel=\"noopener\">Redis主从配置（三）</a><br><a href=\"https://segmentfault.com/a/1190000008448919\" target=\"_blank\" rel=\"noopener\">Redis集群搭建与简单使用（四）</a><br><a href=\"https://segmentfault.com/a/1190000008639459\" target=\"_blank\" rel=\"noopener\">Redis持久化（五）</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"整理一下最近学习Redis的心得\"><a href=\"#整理一下最近学习Redis的心得\" class=\"headerlink\" title=\"整理一下最近学习Redis的心得\"></a>整理一下最近学习Redis的心得</h2><ul>\n<li>VMware版本号：11.1.2 </li>\n<li>CentOS版本：6.6</li>\n</ul>\n<hr>\n<h2 id=\"下载redis\"><a href=\"#下载redis\" class=\"headerlink\" title=\"下载redis\"></a>下载redis</h2><pre><code>wget http://download.redis.io/releases/redis-3.0.0.tar.gz\n</code></pre><hr>\n<h2 id=\"编译源程序\"><a href=\"#编译源程序\" class=\"headerlink\" title=\"编译源程序\"></a>编译源程序</h2><pre><code>tar zxvf redis-3.0.0.tar.gz \ncd redis-3.0.0 \nmake\ncd src\nmake install\n</code></pre><hr>\n<h2 id=\"创建redis目录，移动文件，为了便于管理\"><a href=\"#创建redis目录，移动文件，为了便于管理\" class=\"headerlink\" title=\"创建redis目录，移动文件，为了便于管理\"></a>创建redis目录，移动文件，为了便于管理</h2><pre><code>mkdir -p /usr/local/redis/bin \nmkdir -p /usr/local/redis/etc\nmv /src/redis-3.0.0/redis.conf /usr/local/redis/etc\ncd /src/redis-3.0.0/src\nmv mkreleasehdr.sh redis-benchmark redis-check-aof redis-check-dump redis-cli redis-server /usr/local/redis/bin\n</code></pre><hr>\n<h2 id=\"启动redis服务（redis服务端的默认连接端口是6379）\"><a href=\"#启动redis服务（redis服务端的默认连接端口是6379）\" class=\"headerlink\" title=\"启动redis服务（redis服务端的默认连接端口是6379）\"></a>启动redis服务（redis服务端的默认连接端口是<code>6379</code>）</h2><pre><code>/usr/local/redis/bin/redis-server\n/usr/local/redis/etc/redis.conf\n</code></pre><p>默认情况下，redis不是在后台运行的，我们需要把开启的redis后台运行</p>\n<pre><code>vi /usr/local/redis/etc/redis.conf\n</code></pre><p>将<code>daemonize</code>的值改为<code>yes</code></p>\n<p>查看是否启动</p>\n<pre><code>ps -ef | grep redis\n</code></pre><p>查看是否占用6379端口号</p>\n<pre><code>netstat -tunpl | grep 6379\n</code></pre><p>再启动redis</p>\n<pre><code>/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf\n</code></pre><hr>\n<h2 id=\"客户端连接\"><a href=\"#客户端连接\" class=\"headerlink\" title=\"客户端连接\"></a>客户端连接</h2><pre><code> /usr/local/redis/bin/redis-cli\n</code></pre><p>退出客户端</p>\n<pre><code>exit\n</code></pre><p>或者</p>\n<pre><code>quit\n</code></pre><p>再或者<code>Ctrl</code>+<code>C</code></p>\n<hr>\n<h2 id=\"停止redis\"><a href=\"#停止redis\" class=\"headerlink\" title=\"停止redis\"></a>停止redis</h2><pre><code>/usr/local/redis/bin/redis-cli shutdown\n</code></pre><p>或者</p>\n<pre><code>pkill redis-server\n</code></pre><hr>\n<h2 id=\"redis的一些配置\"><a href=\"#redis的一些配置\" class=\"headerlink\" title=\"redis的一些配置\"></a>redis的一些配置</h2><p><code>daemonize</code>如果需要在后台运行，把该项改为yes<br><code>pidfile</code>配置多个pid的地质，默认在/var/ren/redis.pid<br><code>bind</code>绑定ip,设置后只接受来自该ip的请求<br><code>port</code>监听端口，默认为6379<br><code>timeout</code>设置客户端连接时的超时时间，单位为秒<br><code>loglevel</code>分为4级，debug、verbose、notice、warning<br><code>logfile</code>配置log文件地址 databases 设置数据库的个数，默认使用的数据库为0<br><code>save</code>设置redis进行数据库镜像的频率<br><code>rdbcompression</code>在进行镜像备份时，是否进行压缩<br><code>Dbfilename</code>镜像备份文件的文件名<br><code>Dir</code>数据库镜像备份的文件放置路径<br><code>Slaveof</code>设置数据库为其他数据库的从数据库<br><code>Masteauth</code>主数据库连接需要的密码验证<br><code>Requirepass</code>设置登陆时需要的使用的密码<br><code>Maxclients</code>限制同时连接的客户数量<br><code>Maxmemory</code>设置redis能够使用的最大内存<br><code>Appendonly</code>开启append only模式<br><code>Appendfsync</code>设置对appendonly.aof文件同步的频率<br><code>vm-enabled</code>是否开启虚拟内存支持<br><code>vm-swap-file</code>设置虚拟内存的交换文件路径<br><code>vm-max-memory</code>设置redis使用的最大物理内存大小<br><code>vm-page-size</code>设置虚拟内存的页大小<br><code>vm-pages</code>设置交换文件的总的page数量<br><code>vm-max-threads</code>设置VMIO同时使用的线程数量<br><code>Glueoutputbuf</code>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启<br><code>hash-max-zipmap-entries</code>设置hash的临界值<br><code>Activerehashing</code>重置hash，默认为开启</p>\n<hr>\n<p><strong>相关链接：</strong><br><a href=\"https://segmentfault.com/a/1190000008420258\" target=\"_blank\" rel=\"noopener\">Linux下PHP安装Redis扩展（二）</a><br><a href=\"https://segmentfault.com/a/1190000008469182\" target=\"_blank\" rel=\"noopener\">Redis主从配置（三）</a><br><a href=\"https://segmentfault.com/a/1190000008448919\" target=\"_blank\" rel=\"noopener\">Redis集群搭建与简单使用（四）</a><br><a href=\"https://segmentfault.com/a/1190000008639459\" target=\"_blank\" rel=\"noopener\">Redis持久化（五）</a></p>\n"},{"title":"Linux下PHP安装Redis扩展（二）","date":"2017-02-22T22:26:43.000Z","_content":"> `PECL库`是一个`PHP扩展`，提供一个目录的所有已知的扩展和托管设备下载PHP扩展，PHP很多扩展都可以在这里面找到。\n\n一、PHP Redis下载\n----------------\n下载地址：http://pecl.php.net/package/redis \n\n```\n[root@localhost ~]# wget http://pecl.php.net/get/redis-3.1.0.tgz\n```\n二、解压安装并进入Redis目录\n----------------\n```\n[root@localhost ~]# tar zxf redis-3.1.0.tgz \n[root@localhost ~]# cd redis-3.1.0\n\n``` \n三、在Redis文件夹下，生成configure配置文件\n----------------\n```\n[root@localhost redis-3.1.0]# /usr/local/php/bin/phpize\nConfiguring for:\nPHP Api Version:         20160303\nZend Module Api No:      20160303\nZend Extension Api No:   320160303\n[root@localhost redis-3.1.0]# ./configure --with-php-config=/usr/local/php/bin/php-config\n[root@localhost redis-3.1.0]# make && make install\n\n```\n![图片描述][1]\n![图片描述][2]\n![图片描述][3]\n\n`redis.so`扩展存放在`/usr/local/php/lib/php/extensions/no-debug-non-zts-20160303/`目录下。\n\n四、在PHP配置文件php.ini里面加载Redis扩展 \n----------------\n```\nextension=redis.so\n```\n![图片描述][4]\n\n五、重启服务器(Apache或者Nginx)\n----------------\n\n```\n[root@localhost redis-3.1.0]# service httpd restart\n```\n\n或者\n\n```\n[root@localhost redis-3.1.0]# service nginx start\n```\n六、测试\n----------------\n浏览器访问`index.php`文件,输出`phpinfo`信息，如果有Redis信息，则`安装成功`\n![图片描述][5]\n\n七、其他\n----------------\n`windows`下安装`Redis扩展`就更加简单了，找到对应的版本，下载`dll文件`，放到`PHP目录`下面的`ext`，修改PHP的配置文件`php.ini`，加载`extension=php_redis.dll`，重启`Apache`或者`Nginx`，查看`phpinfo`是否有`Redis`，如果有就`安装成功`。\n----------\n**相关链接：**\n[Redis主从配置（三）][6]\n[Redis集群搭建与简单使用（四）][7]\n[Redis持久化（五）][8]\n\n\n  [1]: /img/bVJuAv\n  [2]: /img/bVJuA4\n  [3]: /img/bVJuA9\n  [4]: /img/bVJuCr\n  [5]: http://olln3wpar.bkt.clouddn.com/redis_so.png\n  [6]: https://segmentfault.com/a/1190000008469182\n  [7]: https://segmentfault.com/a/1190000008448919\n  [8]: https://segmentfault.com/a/1190000008639459","source":"_posts/Linux下PHP安装Redis扩展（二）.md","raw":"---\ntitle: Linux下PHP安装Redis扩展（二）\ndate: 2017-02-23 06:26:43\ntags:\n- Redis\n- yum\ncategories:\n- NoSQL\n---\n> `PECL库`是一个`PHP扩展`，提供一个目录的所有已知的扩展和托管设备下载PHP扩展，PHP很多扩展都可以在这里面找到。\n\n一、PHP Redis下载\n----------------\n下载地址：http://pecl.php.net/package/redis \n\n```\n[root@localhost ~]# wget http://pecl.php.net/get/redis-3.1.0.tgz\n```\n二、解压安装并进入Redis目录\n----------------\n```\n[root@localhost ~]# tar zxf redis-3.1.0.tgz \n[root@localhost ~]# cd redis-3.1.0\n\n``` \n三、在Redis文件夹下，生成configure配置文件\n----------------\n```\n[root@localhost redis-3.1.0]# /usr/local/php/bin/phpize\nConfiguring for:\nPHP Api Version:         20160303\nZend Module Api No:      20160303\nZend Extension Api No:   320160303\n[root@localhost redis-3.1.0]# ./configure --with-php-config=/usr/local/php/bin/php-config\n[root@localhost redis-3.1.0]# make && make install\n\n```\n![图片描述][1]\n![图片描述][2]\n![图片描述][3]\n\n`redis.so`扩展存放在`/usr/local/php/lib/php/extensions/no-debug-non-zts-20160303/`目录下。\n\n四、在PHP配置文件php.ini里面加载Redis扩展 \n----------------\n```\nextension=redis.so\n```\n![图片描述][4]\n\n五、重启服务器(Apache或者Nginx)\n----------------\n\n```\n[root@localhost redis-3.1.0]# service httpd restart\n```\n\n或者\n\n```\n[root@localhost redis-3.1.0]# service nginx start\n```\n六、测试\n----------------\n浏览器访问`index.php`文件,输出`phpinfo`信息，如果有Redis信息，则`安装成功`\n![图片描述][5]\n\n七、其他\n----------------\n`windows`下安装`Redis扩展`就更加简单了，找到对应的版本，下载`dll文件`，放到`PHP目录`下面的`ext`，修改PHP的配置文件`php.ini`，加载`extension=php_redis.dll`，重启`Apache`或者`Nginx`，查看`phpinfo`是否有`Redis`，如果有就`安装成功`。\n----------\n**相关链接：**\n[Redis主从配置（三）][6]\n[Redis集群搭建与简单使用（四）][7]\n[Redis持久化（五）][8]\n\n\n  [1]: /img/bVJuAv\n  [2]: /img/bVJuA4\n  [3]: /img/bVJuA9\n  [4]: /img/bVJuCr\n  [5]: http://olln3wpar.bkt.clouddn.com/redis_so.png\n  [6]: https://segmentfault.com/a/1190000008469182\n  [7]: https://segmentfault.com/a/1190000008448919\n  [8]: https://segmentfault.com/a/1190000008639459","slug":"Linux下PHP安装Redis扩展（二）","published":1,"updated":"2018-01-04T02:54:07.495Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeq1000au8w6n43p2mqc","content":"<blockquote>\n<p><code>PECL库</code>是一个<code>PHP扩展</code>，提供一个目录的所有已知的扩展和托管设备下载PHP扩展，PHP很多扩展都可以在这里面找到。</p>\n</blockquote>\n<h2 id=\"一、PHP-Redis下载\"><a href=\"#一、PHP-Redis下载\" class=\"headerlink\" title=\"一、PHP Redis下载\"></a>一、PHP Redis下载</h2><p>下载地址：<a href=\"http://pecl.php.net/package/redis\" target=\"_blank\" rel=\"noopener\">http://pecl.php.net/package/redis</a> </p>\n<pre><code>[root@localhost ~]# wget http://pecl.php.net/get/redis-3.1.0.tgz\n</code></pre><h2 id=\"二、解压安装并进入Redis目录\"><a href=\"#二、解压安装并进入Redis目录\" class=\"headerlink\" title=\"二、解压安装并进入Redis目录\"></a>二、解压安装并进入Redis目录</h2><pre><code>[root@localhost ~]# tar zxf redis-3.1.0.tgz \n[root@localhost ~]# cd redis-3.1.0\n</code></pre><h2 id=\"三、在Redis文件夹下，生成configure配置文件\"><a href=\"#三、在Redis文件夹下，生成configure配置文件\" class=\"headerlink\" title=\"三、在Redis文件夹下，生成configure配置文件\"></a>三、在Redis文件夹下，生成configure配置文件</h2><pre><code>[root@localhost redis-3.1.0]# /usr/local/php/bin/phpize\nConfiguring for:\nPHP Api Version:         20160303\nZend Module Api No:      20160303\nZend Extension Api No:   320160303\n[root@localhost redis-3.1.0]# ./configure --with-php-config=/usr/local/php/bin/php-config\n[root@localhost redis-3.1.0]# make &amp;&amp; make install\n</code></pre><p><img src=\"/img/bVJuAv\" alt=\"图片描述\"><br><img src=\"/img/bVJuA4\" alt=\"图片描述\"><br><img src=\"/img/bVJuA9\" alt=\"图片描述\"></p>\n<p><code>redis.so</code>扩展存放在<code>/usr/local/php/lib/php/extensions/no-debug-non-zts-20160303/</code>目录下。</p>\n<h2 id=\"四、在PHP配置文件php-ini里面加载Redis扩展\"><a href=\"#四、在PHP配置文件php-ini里面加载Redis扩展\" class=\"headerlink\" title=\"四、在PHP配置文件php.ini里面加载Redis扩展 \"></a>四、在PHP配置文件php.ini里面加载Redis扩展 </h2><pre><code>extension=redis.so\n</code></pre><p><img src=\"/img/bVJuCr\" alt=\"图片描述\"></p>\n<h2 id=\"五、重启服务器-Apache或者Nginx\"><a href=\"#五、重启服务器-Apache或者Nginx\" class=\"headerlink\" title=\"五、重启服务器(Apache或者Nginx)\"></a>五、重启服务器(Apache或者Nginx)</h2><pre><code>[root@localhost redis-3.1.0]# service httpd restart\n</code></pre><p>或者</p>\n<pre><code>[root@localhost redis-3.1.0]# service nginx start\n</code></pre><h2 id=\"六、测试\"><a href=\"#六、测试\" class=\"headerlink\" title=\"六、测试\"></a>六、测试</h2><p>浏览器访问<code>index.php</code>文件,输出<code>phpinfo</code>信息，如果有Redis信息，则<code>安装成功</code><br><img src=\"http://olln3wpar.bkt.clouddn.com/redis_so.png\" alt=\"图片描述\"></p>\n<h2 id=\"七、其他\"><a href=\"#七、其他\" class=\"headerlink\" title=\"七、其他\"></a>七、其他</h2><h2 id=\"windows下安装Redis扩展就更加简单了，找到对应的版本，下载dll文件，放到PHP目录下面的ext，修改PHP的配置文件php-ini，加载extension-php-redis-dll，重启Apache或者Nginx，查看phpinfo是否有Redis，如果有就安装成功。\"><a href=\"#windows下安装Redis扩展就更加简单了，找到对应的版本，下载dll文件，放到PHP目录下面的ext，修改PHP的配置文件php-ini，加载extension-php-redis-dll，重启Apache或者Nginx，查看phpinfo是否有Redis，如果有就安装成功。\" class=\"headerlink\" title=\"windows下安装Redis扩展就更加简单了，找到对应的版本，下载dll文件，放到PHP目录下面的ext，修改PHP的配置文件php.ini，加载extension=php_redis.dll，重启Apache或者Nginx，查看phpinfo是否有Redis，如果有就安装成功。\"></a><code>windows</code>下安装<code>Redis扩展</code>就更加简单了，找到对应的版本，下载<code>dll文件</code>，放到<code>PHP目录</code>下面的<code>ext</code>，修改PHP的配置文件<code>php.ini</code>，加载<code>extension=php_redis.dll</code>，重启<code>Apache</code>或者<code>Nginx</code>，查看<code>phpinfo</code>是否有<code>Redis</code>，如果有就<code>安装成功</code>。</h2><p><strong>相关链接：</strong><br><a href=\"https://segmentfault.com/a/1190000008469182\" target=\"_blank\" rel=\"noopener\">Redis主从配置（三）</a><br><a href=\"https://segmentfault.com/a/1190000008448919\" target=\"_blank\" rel=\"noopener\">Redis集群搭建与简单使用（四）</a><br><a href=\"https://segmentfault.com/a/1190000008639459\" target=\"_blank\" rel=\"noopener\">Redis持久化（五）</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><code>PECL库</code>是一个<code>PHP扩展</code>，提供一个目录的所有已知的扩展和托管设备下载PHP扩展，PHP很多扩展都可以在这里面找到。</p>\n</blockquote>\n<h2 id=\"一、PHP-Redis下载\"><a href=\"#一、PHP-Redis下载\" class=\"headerlink\" title=\"一、PHP Redis下载\"></a>一、PHP Redis下载</h2><p>下载地址：<a href=\"http://pecl.php.net/package/redis\" target=\"_blank\" rel=\"noopener\">http://pecl.php.net/package/redis</a> </p>\n<pre><code>[root@localhost ~]# wget http://pecl.php.net/get/redis-3.1.0.tgz\n</code></pre><h2 id=\"二、解压安装并进入Redis目录\"><a href=\"#二、解压安装并进入Redis目录\" class=\"headerlink\" title=\"二、解压安装并进入Redis目录\"></a>二、解压安装并进入Redis目录</h2><pre><code>[root@localhost ~]# tar zxf redis-3.1.0.tgz \n[root@localhost ~]# cd redis-3.1.0\n</code></pre><h2 id=\"三、在Redis文件夹下，生成configure配置文件\"><a href=\"#三、在Redis文件夹下，生成configure配置文件\" class=\"headerlink\" title=\"三、在Redis文件夹下，生成configure配置文件\"></a>三、在Redis文件夹下，生成configure配置文件</h2><pre><code>[root@localhost redis-3.1.0]# /usr/local/php/bin/phpize\nConfiguring for:\nPHP Api Version:         20160303\nZend Module Api No:      20160303\nZend Extension Api No:   320160303\n[root@localhost redis-3.1.0]# ./configure --with-php-config=/usr/local/php/bin/php-config\n[root@localhost redis-3.1.0]# make &amp;&amp; make install\n</code></pre><p><img src=\"/img/bVJuAv\" alt=\"图片描述\"><br><img src=\"/img/bVJuA4\" alt=\"图片描述\"><br><img src=\"/img/bVJuA9\" alt=\"图片描述\"></p>\n<p><code>redis.so</code>扩展存放在<code>/usr/local/php/lib/php/extensions/no-debug-non-zts-20160303/</code>目录下。</p>\n<h2 id=\"四、在PHP配置文件php-ini里面加载Redis扩展\"><a href=\"#四、在PHP配置文件php-ini里面加载Redis扩展\" class=\"headerlink\" title=\"四、在PHP配置文件php.ini里面加载Redis扩展 \"></a>四、在PHP配置文件php.ini里面加载Redis扩展 </h2><pre><code>extension=redis.so\n</code></pre><p><img src=\"/img/bVJuCr\" alt=\"图片描述\"></p>\n<h2 id=\"五、重启服务器-Apache或者Nginx\"><a href=\"#五、重启服务器-Apache或者Nginx\" class=\"headerlink\" title=\"五、重启服务器(Apache或者Nginx)\"></a>五、重启服务器(Apache或者Nginx)</h2><pre><code>[root@localhost redis-3.1.0]# service httpd restart\n</code></pre><p>或者</p>\n<pre><code>[root@localhost redis-3.1.0]# service nginx start\n</code></pre><h2 id=\"六、测试\"><a href=\"#六、测试\" class=\"headerlink\" title=\"六、测试\"></a>六、测试</h2><p>浏览器访问<code>index.php</code>文件,输出<code>phpinfo</code>信息，如果有Redis信息，则<code>安装成功</code><br><img src=\"http://olln3wpar.bkt.clouddn.com/redis_so.png\" alt=\"图片描述\"></p>\n<h2 id=\"七、其他\"><a href=\"#七、其他\" class=\"headerlink\" title=\"七、其他\"></a>七、其他</h2><h2 id=\"windows下安装Redis扩展就更加简单了，找到对应的版本，下载dll文件，放到PHP目录下面的ext，修改PHP的配置文件php-ini，加载extension-php-redis-dll，重启Apache或者Nginx，查看phpinfo是否有Redis，如果有就安装成功。\"><a href=\"#windows下安装Redis扩展就更加简单了，找到对应的版本，下载dll文件，放到PHP目录下面的ext，修改PHP的配置文件php-ini，加载extension-php-redis-dll，重启Apache或者Nginx，查看phpinfo是否有Redis，如果有就安装成功。\" class=\"headerlink\" title=\"windows下安装Redis扩展就更加简单了，找到对应的版本，下载dll文件，放到PHP目录下面的ext，修改PHP的配置文件php.ini，加载extension=php_redis.dll，重启Apache或者Nginx，查看phpinfo是否有Redis，如果有就安装成功。\"></a><code>windows</code>下安装<code>Redis扩展</code>就更加简单了，找到对应的版本，下载<code>dll文件</code>，放到<code>PHP目录</code>下面的<code>ext</code>，修改PHP的配置文件<code>php.ini</code>，加载<code>extension=php_redis.dll</code>，重启<code>Apache</code>或者<code>Nginx</code>，查看<code>phpinfo</code>是否有<code>Redis</code>，如果有就<code>安装成功</code>。</h2><p><strong>相关链接：</strong><br><a href=\"https://segmentfault.com/a/1190000008469182\" target=\"_blank\" rel=\"noopener\">Redis主从配置（三）</a><br><a href=\"https://segmentfault.com/a/1190000008448919\" target=\"_blank\" rel=\"noopener\">Redis集群搭建与简单使用（四）</a><br><a href=\"https://segmentfault.com/a/1190000008639459\" target=\"_blank\" rel=\"noopener\">Redis持久化（五）</a></p>\n"},{"title":"Linux下定时备份MySQL数据库","date":"2017-02-17T22:25:18.000Z","_content":"## 首先连接数据库，查看数据库是否连接成功##\n\n    mysql -u 用户名 -h 脚本中地址 -p密码\n    \n## 创建脚本server_mysql_bak.sh ##\n\n    #!/bin/sh\n    # Database info\n    DB_HOST=\"127.0.0.1\"\n    DB_NAME=\"db_test\"\n    DB_USER=\"root\"\n    DB_PASS=\"root\"\n    \n    # Others vars\n    BCK_DIR=\"/data/backup/data/\"\n    DATE=`date +%F`\n    \n    # TODO\n    mysqldump --opt -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME | gzip > $BCK_DIR/$DB_NAME-$DATE.gz\n\n\n\n## 计划任务 ##\n\n    //编辑用户目前的crontab任务列表\n    crontab -e\n    //分钟 小时 日 月 天 执行目录的脚本(代码)\n    00 03 * * * sh /data/shell/server_mysql_bak.sh\n\n每天`凌晨3点`开始执行(/data/shell/)目录下这个脚本\n    \n## 重启脚本 ##    \n\n    service crond restart\n\n    ","source":"_posts/Linux下定时备份Mysql数据库.md","raw":"---\ntitle: Linux下定时备份MySQL数据库\ndate: 2017-02-18 06:25:18\ntags:\ncategories:\n- MySQL\n\n---\n## 首先连接数据库，查看数据库是否连接成功##\n\n    mysql -u 用户名 -h 脚本中地址 -p密码\n    \n## 创建脚本server_mysql_bak.sh ##\n\n    #!/bin/sh\n    # Database info\n    DB_HOST=\"127.0.0.1\"\n    DB_NAME=\"db_test\"\n    DB_USER=\"root\"\n    DB_PASS=\"root\"\n    \n    # Others vars\n    BCK_DIR=\"/data/backup/data/\"\n    DATE=`date +%F`\n    \n    # TODO\n    mysqldump --opt -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME | gzip > $BCK_DIR/$DB_NAME-$DATE.gz\n\n\n\n## 计划任务 ##\n\n    //编辑用户目前的crontab任务列表\n    crontab -e\n    //分钟 小时 日 月 天 执行目录的脚本(代码)\n    00 03 * * * sh /data/shell/server_mysql_bak.sh\n\n每天`凌晨3点`开始执行(/data/shell/)目录下这个脚本\n    \n## 重启脚本 ##    \n\n    service crond restart\n\n    ","slug":"Linux下定时备份Mysql数据库","published":1,"updated":"2018-01-04T02:38:17.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeqb000bu8w6dgmjd6dy","content":"<h2 id=\"首先连接数据库，查看数据库是否连接成功\"><a href=\"#首先连接数据库，查看数据库是否连接成功\" class=\"headerlink\" title=\"首先连接数据库，查看数据库是否连接成功\"></a>首先连接数据库，查看数据库是否连接成功</h2><pre><code>mysql -u 用户名 -h 脚本中地址 -p密码\n</code></pre><h2 id=\"创建脚本server-mysql-bak-sh\"><a href=\"#创建脚本server-mysql-bak-sh\" class=\"headerlink\" title=\"创建脚本server_mysql_bak.sh\"></a>创建脚本server_mysql_bak.sh</h2><pre><code>#!/bin/sh\n# Database info\nDB_HOST=&quot;127.0.0.1&quot;\nDB_NAME=&quot;db_test&quot;\nDB_USER=&quot;root&quot;\nDB_PASS=&quot;root&quot;\n\n# Others vars\nBCK_DIR=&quot;/data/backup/data/&quot;\nDATE=`date +%F`\n\n# TODO\nmysqldump --opt -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME | gzip &gt; $BCK_DIR/$DB_NAME-$DATE.gz\n</code></pre><h2 id=\"计划任务\"><a href=\"#计划任务\" class=\"headerlink\" title=\"计划任务\"></a>计划任务</h2><pre><code>//编辑用户目前的crontab任务列表\ncrontab -e\n//分钟 小时 日 月 天 执行目录的脚本(代码)\n00 03 * * * sh /data/shell/server_mysql_bak.sh\n</code></pre><p>每天<code>凌晨3点</code>开始执行(/data/shell/)目录下这个脚本</p>\n<h2 id=\"重启脚本\"><a href=\"#重启脚本\" class=\"headerlink\" title=\"重启脚本\"></a>重启脚本</h2><pre><code>service crond restart\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"首先连接数据库，查看数据库是否连接成功\"><a href=\"#首先连接数据库，查看数据库是否连接成功\" class=\"headerlink\" title=\"首先连接数据库，查看数据库是否连接成功\"></a>首先连接数据库，查看数据库是否连接成功</h2><pre><code>mysql -u 用户名 -h 脚本中地址 -p密码\n</code></pre><h2 id=\"创建脚本server-mysql-bak-sh\"><a href=\"#创建脚本server-mysql-bak-sh\" class=\"headerlink\" title=\"创建脚本server_mysql_bak.sh\"></a>创建脚本server_mysql_bak.sh</h2><pre><code>#!/bin/sh\n# Database info\nDB_HOST=&quot;127.0.0.1&quot;\nDB_NAME=&quot;db_test&quot;\nDB_USER=&quot;root&quot;\nDB_PASS=&quot;root&quot;\n\n# Others vars\nBCK_DIR=&quot;/data/backup/data/&quot;\nDATE=`date +%F`\n\n# TODO\nmysqldump --opt -h$DB_HOST -u$DB_USER -p$DB_PASS $DB_NAME | gzip &gt; $BCK_DIR/$DB_NAME-$DATE.gz\n</code></pre><h2 id=\"计划任务\"><a href=\"#计划任务\" class=\"headerlink\" title=\"计划任务\"></a>计划任务</h2><pre><code>//编辑用户目前的crontab任务列表\ncrontab -e\n//分钟 小时 日 月 天 执行目录的脚本(代码)\n00 03 * * * sh /data/shell/server_mysql_bak.sh\n</code></pre><p>每天<code>凌晨3点</code>开始执行(/data/shell/)目录下这个脚本</p>\n<h2 id=\"重启脚本\"><a href=\"#重启脚本\" class=\"headerlink\" title=\"重启脚本\"></a>重启脚本</h2><pre><code>service crond restart\n</code></pre>"},{"title":"MongoDB 简单介绍以及安装(一)","date":"2017-03-30T15:08:15.000Z","_content":"\nMongoDB 介绍\n----------------\n`MongoDB` 是一种 `NoSQL` 数据库，它在`数据存储`的形态上和 `MySQL` 这类`关系数据库`有本质区别。`MongoDB` 存储的基本对象是 `Document`，所以我们把它称为一种`文档数据库`，而文档的`集合`则组成了 `Collection`。与 `SQL` 的概念类比，`Collection` 对应于 `Table` 而 `Document` 对应于 `Row`。`Document` 使用一种 `BSON（Binary JSON`）结构来表达，`JSON` 大家都熟悉，像下面这样。\n![此处输入图片的描述][1]\n\nMongoDB 应用场景\n----------------\n\n - 游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新\n - 物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来\n - 社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能\n - 物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析\n - 视频直播，使用 MongoDB 存储用户信息、礼物信息等\n\nMongoDB 安装\n----------------\n`MongoDB` 的安装方式比较简单，由于`源码安装`比较麻烦，我们的本意只是为了学习 `MongoDB` 而 `yum` 种傻瓜式安装是为了更方便现在学习，本文以 yum 方式安装。\n\n工具：\n\n - VMware版本号：12.0.0 \n\n - CentOS版本：7.0\n\n`注`： 3.4 版本 `MongoDB` 不再为 `32` 位平台（Linux 和 Windows）提供商业支持，本文安装版本为3.4\n \n\n查看自己 `Linux` 版本：\n\n```\nuname –a\n```\n`x86_64` 表示 `64` 位机器\n`i686` 表示 `32` 位机器\n\n - 整个 `MongoDB`（社区版）包含如下软件\n```\n\n# 包含mongod守护程序和关联的配置和init脚本\nmongodb-org-server\t\n\n# 包含mongos守护程序\nmongodb-org-mongos\t\n\n# 包含mongo shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库\nmongodb-org-shell\t\n\n# 包含以下工具的MongoDB：数据导入、导出、备份、恢复等等\nmongodb-org-tools\t\n```\n\n\n - 创建 yum 源文件\n\n```\nvim /etc/yum.repos.d/mongodb-org-3.4.repo\n```\n\n - 将下面内容复制到源文件中\n\n```\n[mongodb-org-3.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc\n```\n\n![此处输入图片的描述][2]\n \n - 启动 yum 命令开始安装\n\n```\nyum install -y mongodb-org\n```\n\n - 如果使用 `SELinux`，则必须配置 `SELinux`，以允许在基于 `Red Hat Linux` 的系统（Red Hat Enterprise Linux 或 CentOS Linux）上启动 `MongoDB`\n\n```\nvim /etc/selinux/config\n```\n\n将 `SELINUX` 值设置为 `disabled`\n![此处输入图片的描述][3]\n\n - 启动 Mongodb (Mongodb 服务端的默认连接端口是 `27017`)\n\n```\n# Centos6 启动\n$ service mongod start\n\n# Centos7 启动\n$ systemctl start mongod\n```\n\n - 查看是否启动\n```\nnetstat -tlnup|grep mongod\n```\n - 查看是否占用 `27017` 端口号\n\n```\nnetstat -tlnup|grep 27017\n```\n\n - 其它控制命令\n\n```\n# 停止 Mongodb 服务\n$ service mongod stop\n\n# 重启 Mongodb\n$ service mongod restart\n\n```\n\n - 设置开机启动\n\n```\nchkconfig mongod on\n```\n\n - 找到 MongoDB 客户端\n\n```\nfind / -name mongo\n```\n![此处输入图片的描述][4]\n\n - 连接客户端\n\n```\n/usr/bin/mongo\n```\n输入测试命令 `show dbs` 查看当前数据库有哪些\n![此处输入图片的描述][5]\n\n - 停止 MongoDB 服务器\n可以使用 `Ctrl + c` 或者输入 `exit` 退出 `MongoDB` 界面。\n\n`注`：进入 `MongoDB` 界面会出现`警告`\n```\nServer has startup warnings: \n2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] \n2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.\n2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.\n2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] \n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] \n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is 'always'.\n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] **        We suggest setting it to 'never'\n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] \n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is 'always'.\n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] **        We suggest setting it to 'never'\n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] \n```\n这是因为没有配置 `MongoDB` 的`安全功能`，如`授权`和`身份验证`。当然只是为了学习的话，可以忽略它，但是生产环境`必须需要配置`。\n  [1]: http://olln3wpar.bkt.clouddn.com/MongoDB_JOSN.png\n  [2]: http://olln3wpar.bkt.clouddn.com/MongoDB_1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/MongoDB_2.png\n  [4]: http://olln3wpar.bkt.clouddn.com/MongoDB_3.png\n  [5]: http://olln3wpar.bkt.clouddn.com/MongoDB_4.png\n\n ","source":"_posts/MongoDB 简单介绍以及安装(一).md","raw":"---\ntitle: MongoDB 简单介绍以及安装(一)\ndate: 2017-03-30 23:08:15\ntags:\n- MongoDB\ncategories:\n- NoSQL\n---\n\nMongoDB 介绍\n----------------\n`MongoDB` 是一种 `NoSQL` 数据库，它在`数据存储`的形态上和 `MySQL` 这类`关系数据库`有本质区别。`MongoDB` 存储的基本对象是 `Document`，所以我们把它称为一种`文档数据库`，而文档的`集合`则组成了 `Collection`。与 `SQL` 的概念类比，`Collection` 对应于 `Table` 而 `Document` 对应于 `Row`。`Document` 使用一种 `BSON（Binary JSON`）结构来表达，`JSON` 大家都熟悉，像下面这样。\n![此处输入图片的描述][1]\n\nMongoDB 应用场景\n----------------\n\n - 游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新\n - 物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来\n - 社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能\n - 物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析\n - 视频直播，使用 MongoDB 存储用户信息、礼物信息等\n\nMongoDB 安装\n----------------\n`MongoDB` 的安装方式比较简单，由于`源码安装`比较麻烦，我们的本意只是为了学习 `MongoDB` 而 `yum` 种傻瓜式安装是为了更方便现在学习，本文以 yum 方式安装。\n\n工具：\n\n - VMware版本号：12.0.0 \n\n - CentOS版本：7.0\n\n`注`： 3.4 版本 `MongoDB` 不再为 `32` 位平台（Linux 和 Windows）提供商业支持，本文安装版本为3.4\n \n\n查看自己 `Linux` 版本：\n\n```\nuname –a\n```\n`x86_64` 表示 `64` 位机器\n`i686` 表示 `32` 位机器\n\n - 整个 `MongoDB`（社区版）包含如下软件\n```\n\n# 包含mongod守护程序和关联的配置和init脚本\nmongodb-org-server\t\n\n# 包含mongos守护程序\nmongodb-org-mongos\t\n\n# 包含mongo shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库\nmongodb-org-shell\t\n\n# 包含以下工具的MongoDB：数据导入、导出、备份、恢复等等\nmongodb-org-tools\t\n```\n\n\n - 创建 yum 源文件\n\n```\nvim /etc/yum.repos.d/mongodb-org-3.4.repo\n```\n\n - 将下面内容复制到源文件中\n\n```\n[mongodb-org-3.4]\nname=MongoDB Repository\nbaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\ngpgcheck=1\nenabled=1\ngpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc\n```\n\n![此处输入图片的描述][2]\n \n - 启动 yum 命令开始安装\n\n```\nyum install -y mongodb-org\n```\n\n - 如果使用 `SELinux`，则必须配置 `SELinux`，以允许在基于 `Red Hat Linux` 的系统（Red Hat Enterprise Linux 或 CentOS Linux）上启动 `MongoDB`\n\n```\nvim /etc/selinux/config\n```\n\n将 `SELINUX` 值设置为 `disabled`\n![此处输入图片的描述][3]\n\n - 启动 Mongodb (Mongodb 服务端的默认连接端口是 `27017`)\n\n```\n# Centos6 启动\n$ service mongod start\n\n# Centos7 启动\n$ systemctl start mongod\n```\n\n - 查看是否启动\n```\nnetstat -tlnup|grep mongod\n```\n - 查看是否占用 `27017` 端口号\n\n```\nnetstat -tlnup|grep 27017\n```\n\n - 其它控制命令\n\n```\n# 停止 Mongodb 服务\n$ service mongod stop\n\n# 重启 Mongodb\n$ service mongod restart\n\n```\n\n - 设置开机启动\n\n```\nchkconfig mongod on\n```\n\n - 找到 MongoDB 客户端\n\n```\nfind / -name mongo\n```\n![此处输入图片的描述][4]\n\n - 连接客户端\n\n```\n/usr/bin/mongo\n```\n输入测试命令 `show dbs` 查看当前数据库有哪些\n![此处输入图片的描述][5]\n\n - 停止 MongoDB 服务器\n可以使用 `Ctrl + c` 或者输入 `exit` 退出 `MongoDB` 界面。\n\n`注`：进入 `MongoDB` 界面会出现`警告`\n```\nServer has startup warnings: \n2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] \n2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.\n2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.\n2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] \n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] \n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is 'always'.\n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] **        We suggest setting it to 'never'\n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] \n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is 'always'.\n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] **        We suggest setting it to 'never'\n2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] \n```\n这是因为没有配置 `MongoDB` 的`安全功能`，如`授权`和`身份验证`。当然只是为了学习的话，可以忽略它，但是生产环境`必须需要配置`。\n  [1]: http://olln3wpar.bkt.clouddn.com/MongoDB_JOSN.png\n  [2]: http://olln3wpar.bkt.clouddn.com/MongoDB_1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/MongoDB_2.png\n  [4]: http://olln3wpar.bkt.clouddn.com/MongoDB_3.png\n  [5]: http://olln3wpar.bkt.clouddn.com/MongoDB_4.png\n\n ","slug":"MongoDB 简单介绍以及安装(一)","published":1,"updated":"2018-01-04T02:33:53.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeqh000fu8w6r6wv7dzg","content":"<h2 id=\"MongoDB-介绍\"><a href=\"#MongoDB-介绍\" class=\"headerlink\" title=\"MongoDB 介绍\"></a>MongoDB 介绍</h2><p><code>MongoDB</code> 是一种 <code>NoSQL</code> 数据库，它在<code>数据存储</code>的形态上和 <code>MySQL</code> 这类<code>关系数据库</code>有本质区别。<code>MongoDB</code> 存储的基本对象是 <code>Document</code>，所以我们把它称为一种<code>文档数据库</code>，而文档的<code>集合</code>则组成了 <code>Collection</code>。与 <code>SQL</code> 的概念类比，<code>Collection</code> 对应于 <code>Table</code> 而 <code>Document</code> 对应于 <code>Row</code>。<code>Document</code> 使用一种 <code>BSON（Binary JSON</code>）结构来表达，<code>JSON</code> 大家都熟悉，像下面这样。<br>![此处输入图片的描述][1]</p>\n<h2 id=\"MongoDB-应用场景\"><a href=\"#MongoDB-应用场景\" class=\"headerlink\" title=\"MongoDB 应用场景\"></a>MongoDB 应用场景</h2><ul>\n<li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新</li>\n<li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来</li>\n<li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能</li>\n<li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析</li>\n<li>视频直播，使用 MongoDB 存储用户信息、礼物信息等</li>\n</ul>\n<h2 id=\"MongoDB-安装\"><a href=\"#MongoDB-安装\" class=\"headerlink\" title=\"MongoDB 安装\"></a>MongoDB 安装</h2><p><code>MongoDB</code> 的安装方式比较简单，由于<code>源码安装</code>比较麻烦，我们的本意只是为了学习 <code>MongoDB</code> 而 <code>yum</code> 种傻瓜式安装是为了更方便现在学习，本文以 yum 方式安装。</p>\n<p>工具：</p>\n<ul>\n<li><p>VMware版本号：12.0.0 </p>\n</li>\n<li><p>CentOS版本：7.0</p>\n</li>\n</ul>\n<p><code>注</code>： 3.4 版本 <code>MongoDB</code> 不再为 <code>32</code> 位平台（Linux 和 Windows）提供商业支持，本文安装版本为3.4</p>\n<p>查看自己 <code>Linux</code> 版本：</p>\n<pre><code>uname –a\n</code></pre><p><code>x86_64</code> 表示 <code>64</code> 位机器<br><code>i686</code> 表示 <code>32</code> 位机器</p>\n<ul>\n<li>整个 <code>MongoDB</code>（社区版）包含如下软件<br>```</li>\n</ul>\n<h1 id=\"包含mongod守护程序和关联的配置和init脚本\"><a href=\"#包含mongod守护程序和关联的配置和init脚本\" class=\"headerlink\" title=\"包含mongod守护程序和关联的配置和init脚本\"></a>包含mongod守护程序和关联的配置和init脚本</h1><p>mongodb-org-server    </p>\n<h1 id=\"包含mongos守护程序\"><a href=\"#包含mongos守护程序\" class=\"headerlink\" title=\"包含mongos守护程序\"></a>包含mongos守护程序</h1><p>mongodb-org-mongos    </p>\n<h1 id=\"包含mongo-shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库\"><a href=\"#包含mongo-shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库\" class=\"headerlink\" title=\"包含mongo shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库\"></a>包含mongo shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库</h1><p>mongodb-org-shell    </p>\n<h1 id=\"包含以下工具的MongoDB：数据导入、导出、备份、恢复等等\"><a href=\"#包含以下工具的MongoDB：数据导入、导出、备份、恢复等等\" class=\"headerlink\" title=\"包含以下工具的MongoDB：数据导入、导出、备份、恢复等等\"></a>包含以下工具的MongoDB：数据导入、导出、备份、恢复等等</h1><p>mongodb-org-tools    </p>\n<pre><code>\n\n - 创建 yum 源文件\n</code></pre><p>vim /etc/yum.repos.d/mongodb-org-3.4.repo</p>\n<pre><code>\n - 将下面内容复制到源文件中\n</code></pre><p>[mongodb-org-3.4]<br>name=MongoDB Repository<br>baseurl=<a href=\"https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\" target=\"_blank\" rel=\"noopener\">https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href=\"https://www.mongodb.org/static/pgp/server-3.4.asc\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.org/static/pgp/server-3.4.asc</a></p>\n<pre><code>\n![此处输入图片的描述][2]\n\n - 启动 yum 命令开始安装\n</code></pre><p>yum install -y mongodb-org</p>\n<pre><code>\n - 如果使用 `SELinux`，则必须配置 `SELinux`，以允许在基于 `Red Hat Linux` 的系统（Red Hat Enterprise Linux 或 CentOS Linux）上启动 `MongoDB`\n</code></pre><p>vim /etc/selinux/config</p>\n<pre><code>\n将 `SELINUX` 值设置为 `disabled`\n![此处输入图片的描述][3]\n\n - 启动 Mongodb (Mongodb 服务端的默认连接端口是 `27017`)\n</code></pre><h1 id=\"Centos6-启动\"><a href=\"#Centos6-启动\" class=\"headerlink\" title=\"Centos6 启动\"></a>Centos6 启动</h1><p>$ service mongod start</p>\n<h1 id=\"Centos7-启动\"><a href=\"#Centos7-启动\" class=\"headerlink\" title=\"Centos7 启动\"></a>Centos7 启动</h1><p>$ systemctl start mongod</p>\n<pre><code>\n - 查看是否启动\n</code></pre><p>netstat -tlnup|grep mongod</p>\n<pre><code> - 查看是否占用 `27017` 端口号\n</code></pre><p>netstat -tlnup|grep 27017</p>\n<pre><code>\n - 其它控制命令\n</code></pre><h1 id=\"停止-Mongodb-服务\"><a href=\"#停止-Mongodb-服务\" class=\"headerlink\" title=\"停止 Mongodb 服务\"></a>停止 Mongodb 服务</h1><p>$ service mongod stop</p>\n<h1 id=\"重启-Mongodb\"><a href=\"#重启-Mongodb\" class=\"headerlink\" title=\"重启 Mongodb\"></a>重启 Mongodb</h1><p>$ service mongod restart</p>\n<pre><code>\n - 设置开机启动\n</code></pre><p>chkconfig mongod on</p>\n<pre><code>\n - 找到 MongoDB 客户端\n</code></pre><p>find / -name mongo</p>\n<pre><code>![此处输入图片的描述][4]\n\n - 连接客户端\n</code></pre><p>/usr/bin/mongo</p>\n<pre><code>输入测试命令 `show dbs` 查看当前数据库有哪些\n![此处输入图片的描述][5]\n\n - 停止 MongoDB 服务器\n可以使用 `Ctrl + c` 或者输入 `exit` 退出 `MongoDB` 界面。\n\n`注`：进入 `MongoDB` 界面会出现`警告`\n</code></pre><p>Server has startup warnings:<br>2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten]<br>2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] <strong> WARNING: Access control is not enabled for the database.<br>2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] </strong>          Read and write access to data and configuration is unrestricted.<br>2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten]<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten]<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] <strong> WARNING: /sys/kernel/mm/transparent_hugepage/enabled is ‘always’.<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] </strong>        We suggest setting it to ‘never’<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten]<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] <strong> WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’.<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] </strong>        We suggest setting it to ‘never’<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten]<br><code>``\n这是因为没有配置</code>MongoDB<code>的</code>安全功能<code>，如</code>授权<code>和</code>身份验证<code>。当然只是为了学习的话，可以忽略它，但是生产环境</code>必须需要配置`。<br>  [1]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_JOSN.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_JOSN.png</a><br>  [2]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_1.png</a><br>  [3]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_2.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_2.png</a><br>  [4]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_3.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_3.png</a><br>  [5]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_4.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_4.png</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MongoDB-介绍\"><a href=\"#MongoDB-介绍\" class=\"headerlink\" title=\"MongoDB 介绍\"></a>MongoDB 介绍</h2><p><code>MongoDB</code> 是一种 <code>NoSQL</code> 数据库，它在<code>数据存储</code>的形态上和 <code>MySQL</code> 这类<code>关系数据库</code>有本质区别。<code>MongoDB</code> 存储的基本对象是 <code>Document</code>，所以我们把它称为一种<code>文档数据库</code>，而文档的<code>集合</code>则组成了 <code>Collection</code>。与 <code>SQL</code> 的概念类比，<code>Collection</code> 对应于 <code>Table</code> 而 <code>Document</code> 对应于 <code>Row</code>。<code>Document</code> 使用一种 <code>BSON（Binary JSON</code>）结构来表达，<code>JSON</code> 大家都熟悉，像下面这样。<br>![此处输入图片的描述][1]</p>\n<h2 id=\"MongoDB-应用场景\"><a href=\"#MongoDB-应用场景\" class=\"headerlink\" title=\"MongoDB 应用场景\"></a>MongoDB 应用场景</h2><ul>\n<li>游戏场景，使用 MongoDB 存储游戏用户信息，用户的装备、积分等直接以内嵌文档的形式存储，方便查询、更新</li>\n<li>物流场景，使用 MongoDB 存储订单信息，订单状态在运送过程中会不断更新，以 MongoDB 内嵌数组的形式来存储，一次查询就能将订单所有的变更读取出来</li>\n<li>社交场景，使用 MongoDB 存储存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人、地点等功能</li>\n<li>物联网场景，使用 MongoDB 存储所有接入的智能设备信息，以及设备汇报的日志信息，并对这些信息进行多维度的分析</li>\n<li>视频直播，使用 MongoDB 存储用户信息、礼物信息等</li>\n</ul>\n<h2 id=\"MongoDB-安装\"><a href=\"#MongoDB-安装\" class=\"headerlink\" title=\"MongoDB 安装\"></a>MongoDB 安装</h2><p><code>MongoDB</code> 的安装方式比较简单，由于<code>源码安装</code>比较麻烦，我们的本意只是为了学习 <code>MongoDB</code> 而 <code>yum</code> 种傻瓜式安装是为了更方便现在学习，本文以 yum 方式安装。</p>\n<p>工具：</p>\n<ul>\n<li><p>VMware版本号：12.0.0 </p>\n</li>\n<li><p>CentOS版本：7.0</p>\n</li>\n</ul>\n<p><code>注</code>： 3.4 版本 <code>MongoDB</code> 不再为 <code>32</code> 位平台（Linux 和 Windows）提供商业支持，本文安装版本为3.4</p>\n<p>查看自己 <code>Linux</code> 版本：</p>\n<pre><code>uname –a\n</code></pre><p><code>x86_64</code> 表示 <code>64</code> 位机器<br><code>i686</code> 表示 <code>32</code> 位机器</p>\n<ul>\n<li>整个 <code>MongoDB</code>（社区版）包含如下软件<br>```</li>\n</ul>\n<h1 id=\"包含mongod守护程序和关联的配置和init脚本\"><a href=\"#包含mongod守护程序和关联的配置和init脚本\" class=\"headerlink\" title=\"包含mongod守护程序和关联的配置和init脚本\"></a>包含mongod守护程序和关联的配置和init脚本</h1><p>mongodb-org-server    </p>\n<h1 id=\"包含mongos守护程序\"><a href=\"#包含mongos守护程序\" class=\"headerlink\" title=\"包含mongos守护程序\"></a>包含mongos守护程序</h1><p>mongodb-org-mongos    </p>\n<h1 id=\"包含mongo-shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库\"><a href=\"#包含mongo-shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库\" class=\"headerlink\" title=\"包含mongo shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库\"></a>包含mongo shell，它是一个连接mongodb的命令行客户端，允许用户直接输入nosql语法管理数据库</h1><p>mongodb-org-shell    </p>\n<h1 id=\"包含以下工具的MongoDB：数据导入、导出、备份、恢复等等\"><a href=\"#包含以下工具的MongoDB：数据导入、导出、备份、恢复等等\" class=\"headerlink\" title=\"包含以下工具的MongoDB：数据导入、导出、备份、恢复等等\"></a>包含以下工具的MongoDB：数据导入、导出、备份、恢复等等</h1><p>mongodb-org-tools    </p>\n<pre><code>\n\n - 创建 yum 源文件\n</code></pre><p>vim /etc/yum.repos.d/mongodb-org-3.4.repo</p>\n<pre><code>\n - 将下面内容复制到源文件中\n</code></pre><p>[mongodb-org-3.4]<br>name=MongoDB Repository<br>baseurl=<a href=\"https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/\" target=\"_blank\" rel=\"noopener\">https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href=\"https://www.mongodb.org/static/pgp/server-3.4.asc\" target=\"_blank\" rel=\"noopener\">https://www.mongodb.org/static/pgp/server-3.4.asc</a></p>\n<pre><code>\n![此处输入图片的描述][2]\n\n - 启动 yum 命令开始安装\n</code></pre><p>yum install -y mongodb-org</p>\n<pre><code>\n - 如果使用 `SELinux`，则必须配置 `SELinux`，以允许在基于 `Red Hat Linux` 的系统（Red Hat Enterprise Linux 或 CentOS Linux）上启动 `MongoDB`\n</code></pre><p>vim /etc/selinux/config</p>\n<pre><code>\n将 `SELINUX` 值设置为 `disabled`\n![此处输入图片的描述][3]\n\n - 启动 Mongodb (Mongodb 服务端的默认连接端口是 `27017`)\n</code></pre><h1 id=\"Centos6-启动\"><a href=\"#Centos6-启动\" class=\"headerlink\" title=\"Centos6 启动\"></a>Centos6 启动</h1><p>$ service mongod start</p>\n<h1 id=\"Centos7-启动\"><a href=\"#Centos7-启动\" class=\"headerlink\" title=\"Centos7 启动\"></a>Centos7 启动</h1><p>$ systemctl start mongod</p>\n<pre><code>\n - 查看是否启动\n</code></pre><p>netstat -tlnup|grep mongod</p>\n<pre><code> - 查看是否占用 `27017` 端口号\n</code></pre><p>netstat -tlnup|grep 27017</p>\n<pre><code>\n - 其它控制命令\n</code></pre><h1 id=\"停止-Mongodb-服务\"><a href=\"#停止-Mongodb-服务\" class=\"headerlink\" title=\"停止 Mongodb 服务\"></a>停止 Mongodb 服务</h1><p>$ service mongod stop</p>\n<h1 id=\"重启-Mongodb\"><a href=\"#重启-Mongodb\" class=\"headerlink\" title=\"重启 Mongodb\"></a>重启 Mongodb</h1><p>$ service mongod restart</p>\n<pre><code>\n - 设置开机启动\n</code></pre><p>chkconfig mongod on</p>\n<pre><code>\n - 找到 MongoDB 客户端\n</code></pre><p>find / -name mongo</p>\n<pre><code>![此处输入图片的描述][4]\n\n - 连接客户端\n</code></pre><p>/usr/bin/mongo</p>\n<pre><code>输入测试命令 `show dbs` 查看当前数据库有哪些\n![此处输入图片的描述][5]\n\n - 停止 MongoDB 服务器\n可以使用 `Ctrl + c` 或者输入 `exit` 退出 `MongoDB` 界面。\n\n`注`：进入 `MongoDB` 界面会出现`警告`\n</code></pre><p>Server has startup warnings:<br>2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten]<br>2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] <strong> WARNING: Access control is not enabled for the database.<br>2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten] </strong>          Read and write access to data and configuration is unrestricted.<br>2017-03-30T06:40:26.039+0800 I CONTROL  [initandlisten]<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten]<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] <strong> WARNING: /sys/kernel/mm/transparent_hugepage/enabled is ‘always’.<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] </strong>        We suggest setting it to ‘never’<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten]<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] <strong> WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’.<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten] </strong>        We suggest setting it to ‘never’<br>2017-03-30T06:40:26.040+0800 I CONTROL  [initandlisten]<br><code>``\n这是因为没有配置</code>MongoDB<code>的</code>安全功能<code>，如</code>授权<code>和</code>身份验证<code>。当然只是为了学习的话，可以忽略它，但是生产环境</code>必须需要配置`。<br>  [1]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_JOSN.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_JOSN.png</a><br>  [2]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_1.png</a><br>  [3]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_2.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_2.png</a><br>  [4]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_3.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_3.png</a><br>  [5]: <a href=\"http://olln3wpar.bkt.clouddn.com/MongoDB_4.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/MongoDB_4.png</a></p>\n"},{"title":"MongoDB 的基本命令（二）","date":"2017-04-28T15:08:15.000Z","_content":"MongoDB 的基本命令\n----------------\n\n1.db.help()\n查看命令提示\n[][1]\n\n2.db\n查看当前所在数据库的名字\n[][2]\n\n3.use\n`use` + `数据库名`，表示`切换`或是`创建`数据库。和 `MySQL` 中 `use` 的唯一不同点，就是当数据库`不存在`的时候，`MongoDB` 中的 `use` 可以`创建`数据库\n[][3]\n\n4.show dbs\n显示数据库，需要注意的是 `show dbs`，只会显示有数据的库，没有数据的库，是不会显示的。下图中，`test` 数据库中，开始没有数据，所以不会显示，当我插入一条数据库后，`show dbs` 就会显示它\n[][4]\n\n5.db.dropDatabase()\n`删除`当前数据\n[][5]\n\n6.db.stats()\n显示当前 `db` 状态\n[][6]\n\n7.db.version()\n显示当前 `db` 版本\n[][7]\n\n8.db.getMongo()\n查看当前 `db` 的链接机器地址\n[][8]\n\n9.MongoDB 对支持 JavaScript \n因为 `MongoDB` 支持 `JavaScript`，所以可以直接在命令提示中输入 `js` 代码\n[][9]\n\n10.清空屏幕\n`cls` 命令\n\nMongoDB 的数据结构类型\n----------------\n一个`数据库`(Database)中可以包含多个`集合`(colection)，每个`集合`中，可以包含多个`文档`。可以类比，SQL 数据库，一个`数据库`中包含多个`表`，每个`表`中包含多个`记录`\n| SQL术语/概念       | MongoDB术语/概念 |\n| :--------          | :-----           | \n|Database(数据库)    | Database(数据库) |\n|Table(数据库表)     | Collection(集合) |\n|Row(数据记录行)     | Document(文档)   |\n|Column(数据字段)    | Field(域)        |\n|Index(索引)         | Index(索引)      |\n|Table  joins(表连接)| 不支持           |\n|primary key(主键)   |primary key(MongoDB自动将_id字段设置为主键)|\n[][10]\n[][11]\n\n`BSON` 类型：\n\n - null\n `null` 用于表示`空值`或者`不存在`的字段。`{“tmpkey”:null}`\n - 布尔\n `布尔类型`有两个值 `true` 和 `false`。`{“tmpkey”:true}`\n - 32位整数\n 类型不可用。`JavaScript` 仅支持`64位`浮点数，所以`32位`整数会被`自动转换`\n - 64位整数\n 不支持这个类型。`shell` 会使用一个特殊的内嵌文档来显示`64位`整数\n - 64位浮点数\n `shell` 中的数字都是这种类型。下面的表示都是浮点数:`{“tmpkey”:5.12}`\n - 字符串\n `UTF-8` 字符串都可表示为字符串类型的数据:`{“tmpkey”:“abf”}`\n - 符号\n 不支持这种类型。`shell` 将数据库里的`符号类型`转换成`字符串`\n - 对象 id\n `对象 id `是文档的12字节的唯一 ID,`{“tmpkey”:ObjectId()}`\n - 日期\n `日期类型存储`的是从`标准纪元`开始的毫秒数。不存储时区:`{“tmpkey”:new Date()}`\n - 正则表达式\n 文档中可以包含`正则表达式`，采用 `JavaScript` 的正则表达式语法:`{“tmpkey”:/\\w/i}`\n - 代码\n 文档中还可以包含 `JavaScript` 代码：`{“tmpkey”:function() { /* …… */ }} `\n - 二进制数据\n `二进制数据`可以由任意字节的串组成。不过 `shell` 中无法使用\n - 最大值\n `BSON` 包括一个`特殊类型`，表示可能的`最大值`。`shell` 中没有这个类型 \n - 最小值\n `BSON` 包括一个`特殊类型`，表示可能的`最小值`。`shell` 中没有这个类型\n - 未定义\n 文档中也可以使用`未定义类型`:`{“tmpkey”:undefined}`\n - 数组\n 值的`集合`或者`列表`可以表示成`数组`:`{“tmpkey”:[“a”, “b”, “c”]}`\n - 内嵌文档\n 文档可以包含别的文档，也可以作为值`嵌入`到`父文档`中，数据可以组织得更自然些，不用非得存成扁平结构的:`{“tmpkey”:{“color”:“yello”}}`\n\n\n**相关文档：https://docs.mongodb.com/manual/reference/bson-types/**\n  [1]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [2]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [4]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [5]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [6]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/6.png\n  [7]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/7.png\n  [8]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/8.png\n  [9]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/9.png\n  [10]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/10.png\n  [11]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/11.png\n\n  ","source":"_posts/MongoDB-的基本命令（二）.md","raw":"---\ntitle: MongoDB 的基本命令（二）\ndate: 2017-04-28 23:08:15\ntags:\n- MongoDB\ncategories:\n- NoSQL\n---\nMongoDB 的基本命令\n----------------\n\n1.db.help()\n查看命令提示\n[][1]\n\n2.db\n查看当前所在数据库的名字\n[][2]\n\n3.use\n`use` + `数据库名`，表示`切换`或是`创建`数据库。和 `MySQL` 中 `use` 的唯一不同点，就是当数据库`不存在`的时候，`MongoDB` 中的 `use` 可以`创建`数据库\n[][3]\n\n4.show dbs\n显示数据库，需要注意的是 `show dbs`，只会显示有数据的库，没有数据的库，是不会显示的。下图中，`test` 数据库中，开始没有数据，所以不会显示，当我插入一条数据库后，`show dbs` 就会显示它\n[][4]\n\n5.db.dropDatabase()\n`删除`当前数据\n[][5]\n\n6.db.stats()\n显示当前 `db` 状态\n[][6]\n\n7.db.version()\n显示当前 `db` 版本\n[][7]\n\n8.db.getMongo()\n查看当前 `db` 的链接机器地址\n[][8]\n\n9.MongoDB 对支持 JavaScript \n因为 `MongoDB` 支持 `JavaScript`，所以可以直接在命令提示中输入 `js` 代码\n[][9]\n\n10.清空屏幕\n`cls` 命令\n\nMongoDB 的数据结构类型\n----------------\n一个`数据库`(Database)中可以包含多个`集合`(colection)，每个`集合`中，可以包含多个`文档`。可以类比，SQL 数据库，一个`数据库`中包含多个`表`，每个`表`中包含多个`记录`\n| SQL术语/概念       | MongoDB术语/概念 |\n| :--------          | :-----           | \n|Database(数据库)    | Database(数据库) |\n|Table(数据库表)     | Collection(集合) |\n|Row(数据记录行)     | Document(文档)   |\n|Column(数据字段)    | Field(域)        |\n|Index(索引)         | Index(索引)      |\n|Table  joins(表连接)| 不支持           |\n|primary key(主键)   |primary key(MongoDB自动将_id字段设置为主键)|\n[][10]\n[][11]\n\n`BSON` 类型：\n\n - null\n `null` 用于表示`空值`或者`不存在`的字段。`{“tmpkey”:null}`\n - 布尔\n `布尔类型`有两个值 `true` 和 `false`。`{“tmpkey”:true}`\n - 32位整数\n 类型不可用。`JavaScript` 仅支持`64位`浮点数，所以`32位`整数会被`自动转换`\n - 64位整数\n 不支持这个类型。`shell` 会使用一个特殊的内嵌文档来显示`64位`整数\n - 64位浮点数\n `shell` 中的数字都是这种类型。下面的表示都是浮点数:`{“tmpkey”:5.12}`\n - 字符串\n `UTF-8` 字符串都可表示为字符串类型的数据:`{“tmpkey”:“abf”}`\n - 符号\n 不支持这种类型。`shell` 将数据库里的`符号类型`转换成`字符串`\n - 对象 id\n `对象 id `是文档的12字节的唯一 ID,`{“tmpkey”:ObjectId()}`\n - 日期\n `日期类型存储`的是从`标准纪元`开始的毫秒数。不存储时区:`{“tmpkey”:new Date()}`\n - 正则表达式\n 文档中可以包含`正则表达式`，采用 `JavaScript` 的正则表达式语法:`{“tmpkey”:/\\w/i}`\n - 代码\n 文档中还可以包含 `JavaScript` 代码：`{“tmpkey”:function() { /* …… */ }} `\n - 二进制数据\n `二进制数据`可以由任意字节的串组成。不过 `shell` 中无法使用\n - 最大值\n `BSON` 包括一个`特殊类型`，表示可能的`最大值`。`shell` 中没有这个类型 \n - 最小值\n `BSON` 包括一个`特殊类型`，表示可能的`最小值`。`shell` 中没有这个类型\n - 未定义\n 文档中也可以使用`未定义类型`:`{“tmpkey”:undefined}`\n - 数组\n 值的`集合`或者`列表`可以表示成`数组`:`{“tmpkey”:[“a”, “b”, “c”]}`\n - 内嵌文档\n 文档可以包含别的文档，也可以作为值`嵌入`到`父文档`中，数据可以组织得更自然些，不用非得存成扁平结构的:`{“tmpkey”:{“color”:“yello”}}`\n\n\n**相关文档：https://docs.mongodb.com/manual/reference/bson-types/**\n  [1]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [2]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [4]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [5]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\n  [6]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/6.png\n  [7]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/7.png\n  [8]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/8.png\n  [9]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/9.png\n  [10]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/10.png\n  [11]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/11.png\n\n  ","slug":"MongoDB-的基本命令（二）","published":1,"updated":"2018-01-04T01:37:41.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeql000gu8w6n437mapx","content":"<h2 id=\"MongoDB-的基本命令\"><a href=\"#MongoDB-的基本命令\" class=\"headerlink\" title=\"MongoDB 的基本命令\"></a>MongoDB 的基本命令</h2><p>1.db.help()<br>查看命令提示<br>[][1]</p>\n<p>2.db<br>查看当前所在数据库的名字<br>[][2]</p>\n<p>3.use<br><code>use</code> + <code>数据库名</code>，表示<code>切换</code>或是<code>创建</code>数据库。和 <code>MySQL</code> 中 <code>use</code> 的唯一不同点，就是当数据库<code>不存在</code>的时候，<code>MongoDB</code> 中的 <code>use</code> 可以<code>创建</code>数据库<br>[][3]</p>\n<p>4.show dbs<br>显示数据库，需要注意的是 <code>show dbs</code>，只会显示有数据的库，没有数据的库，是不会显示的。下图中，<code>test</code> 数据库中，开始没有数据，所以不会显示，当我插入一条数据库后，<code>show dbs</code> 就会显示它<br>[][4]</p>\n<p>5.db.dropDatabase()<br><code>删除</code>当前数据<br>[][5]</p>\n<p>6.db.stats()<br>显示当前 <code>db</code> 状态<br>[][6]</p>\n<p>7.db.version()<br>显示当前 <code>db</code> 版本<br>[][7]</p>\n<p>8.db.getMongo()<br>查看当前 <code>db</code> 的链接机器地址<br>[][8]</p>\n<p>9.MongoDB 对支持 JavaScript<br>因为 <code>MongoDB</code> 支持 <code>JavaScript</code>，所以可以直接在命令提示中输入 <code>js</code> 代码<br>[][9]</p>\n<p>10.清空屏幕<br><code>cls</code> 命令</p>\n<h2 id=\"MongoDB-的数据结构类型\"><a href=\"#MongoDB-的数据结构类型\" class=\"headerlink\" title=\"MongoDB 的数据结构类型\"></a>MongoDB 的数据结构类型</h2><p>一个<code>数据库</code>(Database)中可以包含多个<code>集合</code>(colection)，每个<code>集合</code>中，可以包含多个<code>文档</code>。可以类比，SQL 数据库，一个<code>数据库</code>中包含多个<code>表</code>，每个<code>表</code>中包含多个<code>记录</code><br>| SQL术语/概念       | MongoDB术语/概念 |<br>| :——–          | :—–           |<br>|Database(数据库)    | Database(数据库) |<br>|Table(数据库表)     | Collection(集合) |<br>|Row(数据记录行)     | Document(文档)   |<br>|Column(数据字段)    | Field(域)        |<br>|Index(索引)         | Index(索引)      |<br>|Table  joins(表连接)| 不支持           |<br>|primary key(主键)   |primary key(MongoDB自动将_id字段设置为主键)|<br>[][10]<br>[][11]</p>\n<p><code>BSON</code> 类型：</p>\n<ul>\n<li>null<br><code>null</code> 用于表示<code>空值</code>或者<code>不存在</code>的字段。<code>{“tmpkey”:null}</code></li>\n<li>布尔<br><code>布尔类型</code>有两个值 <code>true</code> 和 <code>false</code>。<code>{“tmpkey”:true}</code></li>\n<li>32位整数<br>类型不可用。<code>JavaScript</code> 仅支持<code>64位</code>浮点数，所以<code>32位</code>整数会被<code>自动转换</code></li>\n<li>64位整数<br>不支持这个类型。<code>shell</code> 会使用一个特殊的内嵌文档来显示<code>64位</code>整数</li>\n<li>64位浮点数<br><code>shell</code> 中的数字都是这种类型。下面的表示都是浮点数:<code>{“tmpkey”:5.12}</code></li>\n<li>字符串<br><code>UTF-8</code> 字符串都可表示为字符串类型的数据:<code>{“tmpkey”:“abf”}</code></li>\n<li>符号<br>不支持这种类型。<code>shell</code> 将数据库里的<code>符号类型</code>转换成<code>字符串</code></li>\n<li>对象 id<br><code>对象 id</code>是文档的12字节的唯一 ID,<code>{“tmpkey”:ObjectId()}</code></li>\n<li>日期<br><code>日期类型存储</code>的是从<code>标准纪元</code>开始的毫秒数。不存储时区:<code>{“tmpkey”:new Date()}</code></li>\n<li>正则表达式<br>文档中可以包含<code>正则表达式</code>，采用 <code>JavaScript</code> 的正则表达式语法:<code>{“tmpkey”:/\\w/i}</code></li>\n<li>代码<br>文档中还可以包含 <code>JavaScript</code> 代码：<code>{“tmpkey”:function() { /* …… */ }}</code></li>\n<li>二进制数据<br><code>二进制数据</code>可以由任意字节的串组成。不过 <code>shell</code> 中无法使用</li>\n<li>最大值<br><code>BSON</code> 包括一个<code>特殊类型</code>，表示可能的<code>最大值</code>。<code>shell</code> 中没有这个类型 </li>\n<li>最小值<br><code>BSON</code> 包括一个<code>特殊类型</code>，表示可能的<code>最小值</code>。<code>shell</code> 中没有这个类型</li>\n<li>未定义<br>文档中也可以使用<code>未定义类型</code>:<code>{“tmpkey”:undefined}</code></li>\n<li>数组<br>值的<code>集合</code>或者<code>列表</code>可以表示成<code>数组</code>:<code>{“tmpkey”:[“a”, “b”, “c”]}</code></li>\n<li>内嵌文档<br>文档可以包含别的文档，也可以作为值<code>嵌入</code>到<code>父文档</code>中，数据可以组织得更自然些，不用非得存成扁平结构的:<code>{“tmpkey”:{“color”:“yello”}}</code></li>\n</ul>\n<p><strong>相关文档：<a href=\"https://docs.mongodb.com/manual/reference/bson-types/\" target=\"_blank\" rel=\"noopener\">https://docs.mongodb.com/manual/reference/bson-types/</a></strong><br>  [1]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [2]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [3]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [4]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [5]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [6]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/6.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/6.png</a><br>  [7]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/7.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/7.png</a><br>  [8]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/8.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/8.png</a><br>  [9]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/9.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/9.png</a><br>  [10]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/10.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/10.png</a><br>  [11]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/11.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/11.png</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MongoDB-的基本命令\"><a href=\"#MongoDB-的基本命令\" class=\"headerlink\" title=\"MongoDB 的基本命令\"></a>MongoDB 的基本命令</h2><p>1.db.help()<br>查看命令提示<br>[][1]</p>\n<p>2.db<br>查看当前所在数据库的名字<br>[][2]</p>\n<p>3.use<br><code>use</code> + <code>数据库名</code>，表示<code>切换</code>或是<code>创建</code>数据库。和 <code>MySQL</code> 中 <code>use</code> 的唯一不同点，就是当数据库<code>不存在</code>的时候，<code>MongoDB</code> 中的 <code>use</code> 可以<code>创建</code>数据库<br>[][3]</p>\n<p>4.show dbs<br>显示数据库，需要注意的是 <code>show dbs</code>，只会显示有数据的库，没有数据的库，是不会显示的。下图中，<code>test</code> 数据库中，开始没有数据，所以不会显示，当我插入一条数据库后，<code>show dbs</code> 就会显示它<br>[][4]</p>\n<p>5.db.dropDatabase()<br><code>删除</code>当前数据<br>[][5]</p>\n<p>6.db.stats()<br>显示当前 <code>db</code> 状态<br>[][6]</p>\n<p>7.db.version()<br>显示当前 <code>db</code> 版本<br>[][7]</p>\n<p>8.db.getMongo()<br>查看当前 <code>db</code> 的链接机器地址<br>[][8]</p>\n<p>9.MongoDB 对支持 JavaScript<br>因为 <code>MongoDB</code> 支持 <code>JavaScript</code>，所以可以直接在命令提示中输入 <code>js</code> 代码<br>[][9]</p>\n<p>10.清空屏幕<br><code>cls</code> 命令</p>\n<h2 id=\"MongoDB-的数据结构类型\"><a href=\"#MongoDB-的数据结构类型\" class=\"headerlink\" title=\"MongoDB 的数据结构类型\"></a>MongoDB 的数据结构类型</h2><p>一个<code>数据库</code>(Database)中可以包含多个<code>集合</code>(colection)，每个<code>集合</code>中，可以包含多个<code>文档</code>。可以类比，SQL 数据库，一个<code>数据库</code>中包含多个<code>表</code>，每个<code>表</code>中包含多个<code>记录</code><br>| SQL术语/概念       | MongoDB术语/概念 |<br>| :——–          | :—–           |<br>|Database(数据库)    | Database(数据库) |<br>|Table(数据库表)     | Collection(集合) |<br>|Row(数据记录行)     | Document(文档)   |<br>|Column(数据字段)    | Field(域)        |<br>|Index(索引)         | Index(索引)      |<br>|Table  joins(表连接)| 不支持           |<br>|primary key(主键)   |primary key(MongoDB自动将_id字段设置为主键)|<br>[][10]<br>[][11]</p>\n<p><code>BSON</code> 类型：</p>\n<ul>\n<li>null<br><code>null</code> 用于表示<code>空值</code>或者<code>不存在</code>的字段。<code>{“tmpkey”:null}</code></li>\n<li>布尔<br><code>布尔类型</code>有两个值 <code>true</code> 和 <code>false</code>。<code>{“tmpkey”:true}</code></li>\n<li>32位整数<br>类型不可用。<code>JavaScript</code> 仅支持<code>64位</code>浮点数，所以<code>32位</code>整数会被<code>自动转换</code></li>\n<li>64位整数<br>不支持这个类型。<code>shell</code> 会使用一个特殊的内嵌文档来显示<code>64位</code>整数</li>\n<li>64位浮点数<br><code>shell</code> 中的数字都是这种类型。下面的表示都是浮点数:<code>{“tmpkey”:5.12}</code></li>\n<li>字符串<br><code>UTF-8</code> 字符串都可表示为字符串类型的数据:<code>{“tmpkey”:“abf”}</code></li>\n<li>符号<br>不支持这种类型。<code>shell</code> 将数据库里的<code>符号类型</code>转换成<code>字符串</code></li>\n<li>对象 id<br><code>对象 id</code>是文档的12字节的唯一 ID,<code>{“tmpkey”:ObjectId()}</code></li>\n<li>日期<br><code>日期类型存储</code>的是从<code>标准纪元</code>开始的毫秒数。不存储时区:<code>{“tmpkey”:new Date()}</code></li>\n<li>正则表达式<br>文档中可以包含<code>正则表达式</code>，采用 <code>JavaScript</code> 的正则表达式语法:<code>{“tmpkey”:/\\w/i}</code></li>\n<li>代码<br>文档中还可以包含 <code>JavaScript</code> 代码：<code>{“tmpkey”:function() { /* …… */ }}</code></li>\n<li>二进制数据<br><code>二进制数据</code>可以由任意字节的串组成。不过 <code>shell</code> 中无法使用</li>\n<li>最大值<br><code>BSON</code> 包括一个<code>特殊类型</code>，表示可能的<code>最大值</code>。<code>shell</code> 中没有这个类型 </li>\n<li>最小值<br><code>BSON</code> 包括一个<code>特殊类型</code>，表示可能的<code>最小值</code>。<code>shell</code> 中没有这个类型</li>\n<li>未定义<br>文档中也可以使用<code>未定义类型</code>:<code>{“tmpkey”:undefined}</code></li>\n<li>数组<br>值的<code>集合</code>或者<code>列表</code>可以表示成<code>数组</code>:<code>{“tmpkey”:[“a”, “b”, “c”]}</code></li>\n<li>内嵌文档<br>文档可以包含别的文档，也可以作为值<code>嵌入</code>到<code>父文档</code>中，数据可以组织得更自然些，不用非得存成扁平结构的:<code>{“tmpkey”:{“color”:“yello”}}</code></li>\n</ul>\n<p><strong>相关文档：<a href=\"https://docs.mongodb.com/manual/reference/bson-types/\" target=\"_blank\" rel=\"noopener\">https://docs.mongodb.com/manual/reference/bson-types/</a></strong><br>  [1]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [2]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [3]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [4]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [5]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/1.png</a><br>  [6]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/6.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/6.png</a><br>  [7]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/7.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/7.png</a><br>  [8]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/8.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/8.png</a><br>  [9]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/9.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/9.png</a><br>  [10]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/10.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/10.png</a><br>  [11]: <a href=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/11.png\" target=\"_blank\" rel=\"noopener\">http://olln3wpar.bkt.clouddn.com/image/MongoDB%282%29/11.png</a></p>\n"},{"title":"MongoDB 的常用操作（三）","date":"2017-04-28T22:50:53.000Z","_content":"MongoDB 集合操作\n----------------\n1.显示创建集合\n```\ndb.createCollection();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/1.png)\n\n2.查看集合\n```\nshow collections\nshow tables\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/2.png)\n\n3.隐式创建\n```\ndb.class.insert({‘classId’:1,’className’:”三年二班”});\n```\n表示往 `class` 集合中插入一个`文档`(班级编号为1，班级名称为三年二班)。\n本质是，往一个集合中插入一条数据，如果这个集合不存在，`MongoDB` 会自动帮我们创建该集合\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/3.png)\n\n4.删除集合\n```\ndb.collectionName.drop();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/4.png)\n\nMongoDB 文档操作\n----------------\n1.文档插入\n`MongoDB` 中数据插入，指的是将创建的`文档`，`插入`到指定的`集合`中\n```\ndb.collectionName.insert(doc);\n```\n如果`集合不存在`，则`创建`该集合。`doc` 可以是一个`集合`或者一个`集合数组`。\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/5.png)\n`_id` 这是 `MongoDB` 自动生成的一个`全球唯一`的`主键`，用于`区分文档`。其包含四部分：`时间戳`、`机器`、`PID(进程号)`、`计数器`\n\n插入多个文档:\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/6.png)\n\n2.文档删除\n```\ndb.collectionName.remove(where,[justOne]);\n```\n`where` 代表`删除条件`，当 `where` 为`{}`代表`删除所有`文档。\n`justOne` 默认情况下为 `false`，代表`匹配`条件的`文档`有多个的时候，`删除所有`的`匹配文档`。如果设置为 `true` 或`1`（设置其他非0的整数也可以），代表仅仅`删除一个`文档。\n\n删除 `school` 数据库 `student` 集合里名字(stu_name)为王五的文档:\n\n```\ndb.student.remove({\"stu_name\":\"王五\"});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/7.png)\n\n删除 `school` 数据库 `student` 集合里班级编号(class_id)为1的一个集合:\n```\ndb.student.remove({\"class_id\":1},2);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/8.png)\n\n虽然`满足`条件的`文档`很多，但是`仅仅删除`了其中`一个文档`。\n\n3.文档修改\n```\ndb.collectionName.update(query,update,upset,multi);\n```\n`collectionName`：集合名字\n\n`query`：修改的条件，类似 SQL 的 where 语句。\n`update`：更新命令，类似 SQL 的 set 语句。\n`upset`：可选，默认为 false，如果未发现符合更新条件的数据内容，是否执行插入操作，1或者 true 代表进行插入,0或者 false 代表不插入。\n`multi`：可选，MongoDB 默认为 false。是否进行多行更新。1或者 true 进行·多行更新,0或者false代表不更新`。\n\n关于 `update` 格式有`两种`形式\n\n- 直接`赋值`使用 `{set:{}}`\n如 `{set:{“name”:”张三”}}`，将名字改为张三\n- 进行`算术运算`使用 `{inc:{}}`\n如 `{inc:{“age”:3}}`，将 `age` 增加3\n如 `{$inc:{“age”:-3}}`，将 `age` 减3\n\n**实例用法：**\n1、更新文档中不存在字段\n```\n# 更新学生编号(stu_id)为2文档，为其添加一个字段年龄(age)为13\ndb.student.update({\"stu_id\":2},{$set:{\"age\":13}});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/9.png)\n\n2、批量更新文档中不存在字段\n```\n# 更新学生，将其年龄(age不存在)设置为12\ndb.student.update({},{$set:{\"age\":12}},0,1);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/10.png)\n\n3、批量指定字段更新\n```\n# 将班级编号为2的所有学生，年龄(age)增加1\ndb.student.update({\"class_id\":1},{$inc:{\"age\":1}},0,1);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/11.png)\n\n4.文档查询\n\n- 查询集合中的所有文档\n```\ndb.collectionName.find();\n```\n为了便于查找，先向其中插入一些数据\n```\nfor (var i = 1;i < 20;i ++){\ndb.student.insert({\"stu_id\":i,\"stu_name\":\"李\" + i});\n}\ndb.student.find();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/12.png)\n\n- 查询集合中的第一个文档\n```\ndb.collectionName.findOne();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/13.png)\n\n**条件查询：**\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 等于(=)      | / |   查找名字为李四的所有学生：db.student.find({“name”:”李四”});     |\n| 等于(!=)      | \\$ne |   查找名字不为李四的所有学生：db.student.find({“name”:{'$ne:\"李四\"}'}});     |\n| 大于(>)      | \\$gt |   查找所有年龄大于5的学生：db.student.find({\"age\":{$gt:5}});     |\n| 小于(<)      | \\$lt |   查找所有年龄小于15的学生：db.student.find({\"age\":{$lt:15}});     |\n| 大于等于(>=)        |   \\$gte   |   查找所有年龄大于或等于5的学生：db.student.find({\"age\":{$gte:5}});   |\n| 小于等于(>=)        |    \\ &#124; $lte    |  查找所有年龄小于或等于15的学生：db.student.find({\"age\":{$lte:15}});  |\n| 与(and)        |    /    |  查找所有年龄小于或等于15且班级编号为1的所有学生：db.student.find({\"age\":{$lte:15},\"class_id\":1});  |\n| 或(or)        |    {$or:[{条件1},{条件2}]}    |  查找所有年龄小于或等于15或者班级为1的所有学生：db.student.find({$or:[{\"age\":{$lte:15}},{\"class_id\":1}]});  |\n| 非或(nor)        |    {$nor:[{条件1},{条件2}]}    |  条件1不能满足和条件2不能满足  |\n| 集合运算符(in)        |    \\$in\t    |  查找年龄12或者13或者14的学生：db.student.find({\"age\":{$in:[12,13,14]}});  |\n| 集合运算符(all)        |    \\$all    |  查找爱好包含football,和basketBall的所有学生：db.student.find({\"hobby\":{$all:[\"football\",\"basketBall\"]}});  |\n| 是否存在(exists)        |    $exists    |  查询存在hooby的所有学生：db.student.find({hobby:{$exists:1}});{$exists:0}代表不存在  |\n\n\n5.统计、排序、分页\n\n- 统计\n```\ndb.collectionName.count();\ndb.collectionName.find().count();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/14.png)\n\n- 排序\n```\n# key升序排列\ndb.collectionName.find().sort({key:1});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/15.png)\n\n```\n# key降序排列\ndb.collectionName.find().sort({key:-1});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/16.png)\n\n- 分页\n```\ndb.collectionName.find().skip(n).limit(m);\n```\n从 `collectionName` 中第 `n` 个文档开始读取，共读取 `m` 个文档，需要注意的是 `MongoDB` 中 `n` 是从 0 开始的。可以类比 `MySQL` 中 `limit` 方法。`n` 相当于 `limit` 中的第一个方法，`m` 相当于 `limit` 中第二个参数,当使用分页时候，若使用 `count`，需要注意 `MongoDB` 统计数量默认是忽略分页的\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/17.png)\n给 `count` 传递一个参数 `count(flag)`。`flag`为 `0`（默认情况为0）`忽视分页`，`flag` 为`1`，`不忽视分页`。\n从 `student` 中取出6~12条数据\n```\ndb.student.find().skip(6).limit(6);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/18.png)\n从集合 student 中取出第一条数据\n```\ndb.student.find().skip(0).limit(1);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/19.png)\n\n6.投影查询\n在 MongoDB 中，每次查询都是将所有的键都显示出来了，怎样只让部分键显示呢？这就要用到投影查询。\n比如，我只让集合 student 查询结果中 stu_name 显示。\n```\ndb.student.find({},{_id:0,stu_id:0});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/20.png)\n在 `MongoDB` 中，`find` 函数里面的`第二个参数`是用来`控制`让哪些键`显示`或者`不显示`。`0`是`不显示`，`1`为`显示`。`默认`情况下为`显示`。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/MongoDB-的常用操作（三）.md","raw":"---\ntitle: MongoDB 的常用操作（三）\ndate: 2017-04-29 06:50:53\ntags:\n- MongoDB\ncategories:\n- NoSQL\n---\nMongoDB 集合操作\n----------------\n1.显示创建集合\n```\ndb.createCollection();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/1.png)\n\n2.查看集合\n```\nshow collections\nshow tables\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/2.png)\n\n3.隐式创建\n```\ndb.class.insert({‘classId’:1,’className’:”三年二班”});\n```\n表示往 `class` 集合中插入一个`文档`(班级编号为1，班级名称为三年二班)。\n本质是，往一个集合中插入一条数据，如果这个集合不存在，`MongoDB` 会自动帮我们创建该集合\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/3.png)\n\n4.删除集合\n```\ndb.collectionName.drop();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/4.png)\n\nMongoDB 文档操作\n----------------\n1.文档插入\n`MongoDB` 中数据插入，指的是将创建的`文档`，`插入`到指定的`集合`中\n```\ndb.collectionName.insert(doc);\n```\n如果`集合不存在`，则`创建`该集合。`doc` 可以是一个`集合`或者一个`集合数组`。\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/5.png)\n`_id` 这是 `MongoDB` 自动生成的一个`全球唯一`的`主键`，用于`区分文档`。其包含四部分：`时间戳`、`机器`、`PID(进程号)`、`计数器`\n\n插入多个文档:\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/6.png)\n\n2.文档删除\n```\ndb.collectionName.remove(where,[justOne]);\n```\n`where` 代表`删除条件`，当 `where` 为`{}`代表`删除所有`文档。\n`justOne` 默认情况下为 `false`，代表`匹配`条件的`文档`有多个的时候，`删除所有`的`匹配文档`。如果设置为 `true` 或`1`（设置其他非0的整数也可以），代表仅仅`删除一个`文档。\n\n删除 `school` 数据库 `student` 集合里名字(stu_name)为王五的文档:\n\n```\ndb.student.remove({\"stu_name\":\"王五\"});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/7.png)\n\n删除 `school` 数据库 `student` 集合里班级编号(class_id)为1的一个集合:\n```\ndb.student.remove({\"class_id\":1},2);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/8.png)\n\n虽然`满足`条件的`文档`很多，但是`仅仅删除`了其中`一个文档`。\n\n3.文档修改\n```\ndb.collectionName.update(query,update,upset,multi);\n```\n`collectionName`：集合名字\n\n`query`：修改的条件，类似 SQL 的 where 语句。\n`update`：更新命令，类似 SQL 的 set 语句。\n`upset`：可选，默认为 false，如果未发现符合更新条件的数据内容，是否执行插入操作，1或者 true 代表进行插入,0或者 false 代表不插入。\n`multi`：可选，MongoDB 默认为 false。是否进行多行更新。1或者 true 进行·多行更新,0或者false代表不更新`。\n\n关于 `update` 格式有`两种`形式\n\n- 直接`赋值`使用 `{set:{}}`\n如 `{set:{“name”:”张三”}}`，将名字改为张三\n- 进行`算术运算`使用 `{inc:{}}`\n如 `{inc:{“age”:3}}`，将 `age` 增加3\n如 `{$inc:{“age”:-3}}`，将 `age` 减3\n\n**实例用法：**\n1、更新文档中不存在字段\n```\n# 更新学生编号(stu_id)为2文档，为其添加一个字段年龄(age)为13\ndb.student.update({\"stu_id\":2},{$set:{\"age\":13}});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/9.png)\n\n2、批量更新文档中不存在字段\n```\n# 更新学生，将其年龄(age不存在)设置为12\ndb.student.update({},{$set:{\"age\":12}},0,1);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/10.png)\n\n3、批量指定字段更新\n```\n# 将班级编号为2的所有学生，年龄(age)增加1\ndb.student.update({\"class_id\":1},{$inc:{\"age\":1}},0,1);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/11.png)\n\n4.文档查询\n\n- 查询集合中的所有文档\n```\ndb.collectionName.find();\n```\n为了便于查找，先向其中插入一些数据\n```\nfor (var i = 1;i < 20;i ++){\ndb.student.insert({\"stu_id\":i,\"stu_name\":\"李\" + i});\n}\ndb.student.find();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/12.png)\n\n- 查询集合中的第一个文档\n```\ndb.collectionName.findOne();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/13.png)\n\n**条件查询：**\n\n| 项目        | 价格   |  数量  |\n| --------   | -----:  | :----:  |\n| 等于(=)      | / |   查找名字为李四的所有学生：db.student.find({“name”:”李四”});     |\n| 等于(!=)      | \\$ne |   查找名字不为李四的所有学生：db.student.find({“name”:{'$ne:\"李四\"}'}});     |\n| 大于(>)      | \\$gt |   查找所有年龄大于5的学生：db.student.find({\"age\":{$gt:5}});     |\n| 小于(<)      | \\$lt |   查找所有年龄小于15的学生：db.student.find({\"age\":{$lt:15}});     |\n| 大于等于(>=)        |   \\$gte   |   查找所有年龄大于或等于5的学生：db.student.find({\"age\":{$gte:5}});   |\n| 小于等于(>=)        |    \\ &#124; $lte    |  查找所有年龄小于或等于15的学生：db.student.find({\"age\":{$lte:15}});  |\n| 与(and)        |    /    |  查找所有年龄小于或等于15且班级编号为1的所有学生：db.student.find({\"age\":{$lte:15},\"class_id\":1});  |\n| 或(or)        |    {$or:[{条件1},{条件2}]}    |  查找所有年龄小于或等于15或者班级为1的所有学生：db.student.find({$or:[{\"age\":{$lte:15}},{\"class_id\":1}]});  |\n| 非或(nor)        |    {$nor:[{条件1},{条件2}]}    |  条件1不能满足和条件2不能满足  |\n| 集合运算符(in)        |    \\$in\t    |  查找年龄12或者13或者14的学生：db.student.find({\"age\":{$in:[12,13,14]}});  |\n| 集合运算符(all)        |    \\$all    |  查找爱好包含football,和basketBall的所有学生：db.student.find({\"hobby\":{$all:[\"football\",\"basketBall\"]}});  |\n| 是否存在(exists)        |    $exists    |  查询存在hooby的所有学生：db.student.find({hobby:{$exists:1}});{$exists:0}代表不存在  |\n\n\n5.统计、排序、分页\n\n- 统计\n```\ndb.collectionName.count();\ndb.collectionName.find().count();\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/14.png)\n\n- 排序\n```\n# key升序排列\ndb.collectionName.find().sort({key:1});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/15.png)\n\n```\n# key降序排列\ndb.collectionName.find().sort({key:-1});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/16.png)\n\n- 分页\n```\ndb.collectionName.find().skip(n).limit(m);\n```\n从 `collectionName` 中第 `n` 个文档开始读取，共读取 `m` 个文档，需要注意的是 `MongoDB` 中 `n` 是从 0 开始的。可以类比 `MySQL` 中 `limit` 方法。`n` 相当于 `limit` 中的第一个方法，`m` 相当于 `limit` 中第二个参数,当使用分页时候，若使用 `count`，需要注意 `MongoDB` 统计数量默认是忽略分页的\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/17.png)\n给 `count` 传递一个参数 `count(flag)`。`flag`为 `0`（默认情况为0）`忽视分页`，`flag` 为`1`，`不忽视分页`。\n从 `student` 中取出6~12条数据\n```\ndb.student.find().skip(6).limit(6);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/18.png)\n从集合 student 中取出第一条数据\n```\ndb.student.find().skip(0).limit(1);\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/19.png)\n\n6.投影查询\n在 MongoDB 中，每次查询都是将所有的键都显示出来了，怎样只让部分键显示呢？这就要用到投影查询。\n比如，我只让集合 student 查询结果中 stu_name 显示。\n```\ndb.student.find({},{_id:0,stu_id:0});\n```\n![](http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/20.png)\n在 `MongoDB` 中，`find` 函数里面的`第二个参数`是用来`控制`让哪些键`显示`或者`不显示`。`0`是`不显示`，`1`为`显示`。`默认`情况下为`显示`。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"MongoDB-的常用操作（三）","published":1,"updated":"2018-01-04T01:37:41.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeqp000lu8w6beyslnsn","content":"<h2 id=\"MongoDB-集合操作\"><a href=\"#MongoDB-集合操作\" class=\"headerlink\" title=\"MongoDB 集合操作\"></a>MongoDB 集合操作</h2><p>1.显示创建集合</p>\n<pre><code>db.createCollection();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/1.png\" alt=\"\"></p>\n<p>2.查看集合</p>\n<pre><code>show collections\nshow tables\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/2.png\" alt=\"\"></p>\n<p>3.隐式创建</p>\n<pre><code>db.class.insert({‘classId’:1,’className’:”三年二班”});\n</code></pre><p>表示往 <code>class</code> 集合中插入一个<code>文档</code>(班级编号为1，班级名称为三年二班)。<br>本质是，往一个集合中插入一条数据，如果这个集合不存在，<code>MongoDB</code> 会自动帮我们创建该集合<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/3.png\" alt=\"\"></p>\n<p>4.删除集合</p>\n<pre><code>db.collectionName.drop();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/4.png\" alt=\"\"></p>\n<h2 id=\"MongoDB-文档操作\"><a href=\"#MongoDB-文档操作\" class=\"headerlink\" title=\"MongoDB 文档操作\"></a>MongoDB 文档操作</h2><p>1.文档插入<br><code>MongoDB</code> 中数据插入，指的是将创建的<code>文档</code>，<code>插入</code>到指定的<code>集合</code>中</p>\n<pre><code>db.collectionName.insert(doc);\n</code></pre><p>如果<code>集合不存在</code>，则<code>创建</code>该集合。<code>doc</code> 可以是一个<code>集合</code>或者一个<code>集合数组</code>。<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/5.png\" alt=\"\"><br><code>_id</code> 这是 <code>MongoDB</code> 自动生成的一个<code>全球唯一</code>的<code>主键</code>，用于<code>区分文档</code>。其包含四部分：<code>时间戳</code>、<code>机器</code>、<code>PID(进程号)</code>、<code>计数器</code></p>\n<p>插入多个文档:<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/6.png\" alt=\"\"></p>\n<p>2.文档删除</p>\n<pre><code>db.collectionName.remove(where,[justOne]);\n</code></pre><p><code>where</code> 代表<code>删除条件</code>，当 <code>where</code> 为<code>{}</code>代表<code>删除所有</code>文档。<br><code>justOne</code> 默认情况下为 <code>false</code>，代表<code>匹配</code>条件的<code>文档</code>有多个的时候，<code>删除所有</code>的<code>匹配文档</code>。如果设置为 <code>true</code> 或<code>1</code>（设置其他非0的整数也可以），代表仅仅<code>删除一个</code>文档。</p>\n<p>删除 <code>school</code> 数据库 <code>student</code> 集合里名字(stu_name)为王五的文档:</p>\n<pre><code>db.student.remove({&quot;stu_name&quot;:&quot;王五&quot;});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/7.png\" alt=\"\"></p>\n<p>删除 <code>school</code> 数据库 <code>student</code> 集合里班级编号(class_id)为1的一个集合:</p>\n<pre><code>db.student.remove({&quot;class_id&quot;:1},2);\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/8.png\" alt=\"\"></p>\n<p>虽然<code>满足</code>条件的<code>文档</code>很多，但是<code>仅仅删除</code>了其中<code>一个文档</code>。</p>\n<p>3.文档修改</p>\n<pre><code>db.collectionName.update(query,update,upset,multi);\n</code></pre><p><code>collectionName</code>：集合名字</p>\n<p><code>query</code>：修改的条件，类似 SQL 的 where 语句。<br><code>update</code>：更新命令，类似 SQL 的 set 语句。<br><code>upset</code>：可选，默认为 false，如果未发现符合更新条件的数据内容，是否执行插入操作，1或者 true 代表进行插入,0或者 false 代表不插入。<br><code>multi</code>：可选，MongoDB 默认为 false。是否进行多行更新。1或者 true 进行·多行更新,0或者false代表不更新`。</p>\n<p>关于 <code>update</code> 格式有<code>两种</code>形式</p>\n<ul>\n<li>直接<code>赋值</code>使用 <code>{set:{}}</code><br>如 <code>{set:{“name”:”张三”}}</code>，将名字改为张三</li>\n<li>进行<code>算术运算</code>使用 <code>{inc:{}}</code><br>如 <code>{inc:{“age”:3}}</code>，将 <code>age</code> 增加3<br>如 <code>{$inc:{“age”:-3}}</code>，将 <code>age</code> 减3</li>\n</ul>\n<p><strong>实例用法：</strong><br>1、更新文档中不存在字段</p>\n<pre><code># 更新学生编号(stu_id)为2文档，为其添加一个字段年龄(age)为13\ndb.student.update({&quot;stu_id&quot;:2},{$set:{&quot;age&quot;:13}});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/9.png\" alt=\"\"></p>\n<p>2、批量更新文档中不存在字段</p>\n<pre><code># 更新学生，将其年龄(age不存在)设置为12\ndb.student.update({},{$set:{&quot;age&quot;:12}},0,1);\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/10.png\" alt=\"\"></p>\n<p>3、批量指定字段更新</p>\n<pre><code># 将班级编号为2的所有学生，年龄(age)增加1\ndb.student.update({&quot;class_id&quot;:1},{$inc:{&quot;age&quot;:1}},0,1);\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/11.png\" alt=\"\"></p>\n<p>4.文档查询</p>\n<ul>\n<li><p>查询集合中的所有文档</p>\n<pre><code>db.collectionName.find();\n</code></pre><p>为了便于查找，先向其中插入一些数据</p>\n<pre><code>for (var i = 1;i &lt; 20;i ++){\ndb.student.insert({&quot;stu_id&quot;:i,&quot;stu_name&quot;:&quot;李&quot; + i});\n}\ndb.student.find();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/12.png\" alt=\"\"></p>\n</li>\n<li><p>查询集合中的第一个文档</p>\n<pre><code>db.collectionName.findOne();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/13.png\" alt=\"\"></p>\n</li>\n</ul>\n<p><strong>条件查询：</strong></p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:right\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>等于(=)</td>\n<td style=\"text-align:right\">/</td>\n<td style=\"text-align:center\">查找名字为李四的所有学生：db.student.find({“name”:”李四”});</td>\n</tr>\n<tr>\n<td>等于(!=)</td>\n<td style=\"text-align:right\">\\$ne</td>\n<td style=\"text-align:center\">查找名字不为李四的所有学生：db.student.find({“name”:{‘$ne:”李四”}’}});</td>\n</tr>\n<tr>\n<td>大于(&gt;)</td>\n<td style=\"text-align:right\">\\$gt</td>\n<td style=\"text-align:center\">查找所有年龄大于5的学生：db.student.find({“age”:{$gt:5}});</td>\n</tr>\n<tr>\n<td>小于(&lt;)</td>\n<td style=\"text-align:right\">\\$lt</td>\n<td style=\"text-align:center\">查找所有年龄小于15的学生：db.student.find({“age”:{$lt:15}});</td>\n</tr>\n<tr>\n<td>大于等于(&gt;=)</td>\n<td style=\"text-align:right\">\\$gte</td>\n<td style=\"text-align:center\">查找所有年龄大于或等于5的学生：db.student.find({“age”:{$gte:5}});</td>\n</tr>\n<tr>\n<td>小于等于(&gt;=)</td>\n<td style=\"text-align:right\">\\ &#124; $lte</td>\n<td style=\"text-align:center\">查找所有年龄小于或等于15的学生：db.student.find({“age”:{$lte:15}});</td>\n</tr>\n<tr>\n<td>与(and)</td>\n<td style=\"text-align:right\">/</td>\n<td style=\"text-align:center\">查找所有年龄小于或等于15且班级编号为1的所有学生：db.student.find({“age”:{$lte:15},”class_id”:1});</td>\n</tr>\n<tr>\n<td>或(or)</td>\n<td style=\"text-align:right\">{$or:[{条件1},{条件2}]}</td>\n<td style=\"text-align:center\">查找所有年龄小于或等于15或者班级为1的所有学生：db.student.find({$or:[{“age”:{$lte:15}},{“class_id”:1}]});</td>\n</tr>\n<tr>\n<td>非或(nor)</td>\n<td style=\"text-align:right\">{$nor:[{条件1},{条件2}]}</td>\n<td style=\"text-align:center\">条件1不能满足和条件2不能满足</td>\n</tr>\n<tr>\n<td>集合运算符(in)</td>\n<td style=\"text-align:right\">\\$in</td>\n<td style=\"text-align:center\">查找年龄12或者13或者14的学生：db.student.find({“age”:{$in:[12,13,14]}});</td>\n</tr>\n<tr>\n<td>集合运算符(all)</td>\n<td style=\"text-align:right\">\\$all</td>\n<td style=\"text-align:center\">查找爱好包含football,和basketBall的所有学生：db.student.find({“hobby”:{$all:[“football”,”basketBall”]}});</td>\n</tr>\n<tr>\n<td>是否存在(exists)</td>\n<td style=\"text-align:right\">$exists</td>\n<td style=\"text-align:center\">查询存在hooby的所有学生：db.student.find({hobby:{$exists:1}});{$exists:0}代表不存在</td>\n</tr>\n</tbody>\n</table>\n<p>5.统计、排序、分页</p>\n<ul>\n<li><p>统计</p>\n<pre><code>db.collectionName.count();\ndb.collectionName.find().count();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/14.png\" alt=\"\"></p>\n</li>\n<li><p>排序</p>\n<pre><code># key升序排列\ndb.collectionName.find().sort({key:1});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/15.png\" alt=\"\"></p>\n</li>\n</ul>\n<pre><code># key降序排列\ndb.collectionName.find().sort({key:-1});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/16.png\" alt=\"\"></p>\n<ul>\n<li>分页<pre><code>db.collectionName.find().skip(n).limit(m);\n</code></pre>从 <code>collectionName</code> 中第 <code>n</code> 个文档开始读取，共读取 <code>m</code> 个文档，需要注意的是 <code>MongoDB</code> 中 <code>n</code> 是从 0 开始的。可以类比 <code>MySQL</code> 中 <code>limit</code> 方法。<code>n</code> 相当于 <code>limit</code> 中的第一个方法，<code>m</code> 相当于 <code>limit</code> 中第二个参数,当使用分页时候，若使用 <code>count</code>，需要注意 <code>MongoDB</code> 统计数量默认是忽略分页的<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/17.png\" alt=\"\"><br>给 <code>count</code> 传递一个参数 <code>count(flag)</code>。<code>flag</code>为 <code>0</code>（默认情况为0）<code>忽视分页</code>，<code>flag</code> 为<code>1</code>，<code>不忽视分页</code>。<br>从 <code>student</code> 中取出6~12条数据<pre><code>db.student.find().skip(6).limit(6);\n</code></pre><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/18.png\" alt=\"\"><br>从集合 student 中取出第一条数据<pre><code>db.student.find().skip(0).limit(1);\n</code></pre><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/19.png\" alt=\"\"></li>\n</ul>\n<p>6.投影查询<br>在 MongoDB 中，每次查询都是将所有的键都显示出来了，怎样只让部分键显示呢？这就要用到投影查询。<br>比如，我只让集合 student 查询结果中 stu_name 显示。</p>\n<pre><code>db.student.find({},{_id:0,stu_id:0});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/20.png\" alt=\"\"><br>在 <code>MongoDB</code> 中，<code>find</code> 函数里面的<code>第二个参数</code>是用来<code>控制</code>让哪些键<code>显示</code>或者<code>不显示</code>。<code>0</code>是<code>不显示</code>，<code>1</code>为<code>显示</code>。<code>默认</code>情况下为<code>显示</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MongoDB-集合操作\"><a href=\"#MongoDB-集合操作\" class=\"headerlink\" title=\"MongoDB 集合操作\"></a>MongoDB 集合操作</h2><p>1.显示创建集合</p>\n<pre><code>db.createCollection();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/1.png\" alt=\"\"></p>\n<p>2.查看集合</p>\n<pre><code>show collections\nshow tables\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/2.png\" alt=\"\"></p>\n<p>3.隐式创建</p>\n<pre><code>db.class.insert({‘classId’:1,’className’:”三年二班”});\n</code></pre><p>表示往 <code>class</code> 集合中插入一个<code>文档</code>(班级编号为1，班级名称为三年二班)。<br>本质是，往一个集合中插入一条数据，如果这个集合不存在，<code>MongoDB</code> 会自动帮我们创建该集合<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/3.png\" alt=\"\"></p>\n<p>4.删除集合</p>\n<pre><code>db.collectionName.drop();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/4.png\" alt=\"\"></p>\n<h2 id=\"MongoDB-文档操作\"><a href=\"#MongoDB-文档操作\" class=\"headerlink\" title=\"MongoDB 文档操作\"></a>MongoDB 文档操作</h2><p>1.文档插入<br><code>MongoDB</code> 中数据插入，指的是将创建的<code>文档</code>，<code>插入</code>到指定的<code>集合</code>中</p>\n<pre><code>db.collectionName.insert(doc);\n</code></pre><p>如果<code>集合不存在</code>，则<code>创建</code>该集合。<code>doc</code> 可以是一个<code>集合</code>或者一个<code>集合数组</code>。<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/5.png\" alt=\"\"><br><code>_id</code> 这是 <code>MongoDB</code> 自动生成的一个<code>全球唯一</code>的<code>主键</code>，用于<code>区分文档</code>。其包含四部分：<code>时间戳</code>、<code>机器</code>、<code>PID(进程号)</code>、<code>计数器</code></p>\n<p>插入多个文档:<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/6.png\" alt=\"\"></p>\n<p>2.文档删除</p>\n<pre><code>db.collectionName.remove(where,[justOne]);\n</code></pre><p><code>where</code> 代表<code>删除条件</code>，当 <code>where</code> 为<code>{}</code>代表<code>删除所有</code>文档。<br><code>justOne</code> 默认情况下为 <code>false</code>，代表<code>匹配</code>条件的<code>文档</code>有多个的时候，<code>删除所有</code>的<code>匹配文档</code>。如果设置为 <code>true</code> 或<code>1</code>（设置其他非0的整数也可以），代表仅仅<code>删除一个</code>文档。</p>\n<p>删除 <code>school</code> 数据库 <code>student</code> 集合里名字(stu_name)为王五的文档:</p>\n<pre><code>db.student.remove({&quot;stu_name&quot;:&quot;王五&quot;});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/7.png\" alt=\"\"></p>\n<p>删除 <code>school</code> 数据库 <code>student</code> 集合里班级编号(class_id)为1的一个集合:</p>\n<pre><code>db.student.remove({&quot;class_id&quot;:1},2);\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/8.png\" alt=\"\"></p>\n<p>虽然<code>满足</code>条件的<code>文档</code>很多，但是<code>仅仅删除</code>了其中<code>一个文档</code>。</p>\n<p>3.文档修改</p>\n<pre><code>db.collectionName.update(query,update,upset,multi);\n</code></pre><p><code>collectionName</code>：集合名字</p>\n<p><code>query</code>：修改的条件，类似 SQL 的 where 语句。<br><code>update</code>：更新命令，类似 SQL 的 set 语句。<br><code>upset</code>：可选，默认为 false，如果未发现符合更新条件的数据内容，是否执行插入操作，1或者 true 代表进行插入,0或者 false 代表不插入。<br><code>multi</code>：可选，MongoDB 默认为 false。是否进行多行更新。1或者 true 进行·多行更新,0或者false代表不更新`。</p>\n<p>关于 <code>update</code> 格式有<code>两种</code>形式</p>\n<ul>\n<li>直接<code>赋值</code>使用 <code>{set:{}}</code><br>如 <code>{set:{“name”:”张三”}}</code>，将名字改为张三</li>\n<li>进行<code>算术运算</code>使用 <code>{inc:{}}</code><br>如 <code>{inc:{“age”:3}}</code>，将 <code>age</code> 增加3<br>如 <code>{$inc:{“age”:-3}}</code>，将 <code>age</code> 减3</li>\n</ul>\n<p><strong>实例用法：</strong><br>1、更新文档中不存在字段</p>\n<pre><code># 更新学生编号(stu_id)为2文档，为其添加一个字段年龄(age)为13\ndb.student.update({&quot;stu_id&quot;:2},{$set:{&quot;age&quot;:13}});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/9.png\" alt=\"\"></p>\n<p>2、批量更新文档中不存在字段</p>\n<pre><code># 更新学生，将其年龄(age不存在)设置为12\ndb.student.update({},{$set:{&quot;age&quot;:12}},0,1);\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/10.png\" alt=\"\"></p>\n<p>3、批量指定字段更新</p>\n<pre><code># 将班级编号为2的所有学生，年龄(age)增加1\ndb.student.update({&quot;class_id&quot;:1},{$inc:{&quot;age&quot;:1}},0,1);\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/11.png\" alt=\"\"></p>\n<p>4.文档查询</p>\n<ul>\n<li><p>查询集合中的所有文档</p>\n<pre><code>db.collectionName.find();\n</code></pre><p>为了便于查找，先向其中插入一些数据</p>\n<pre><code>for (var i = 1;i &lt; 20;i ++){\ndb.student.insert({&quot;stu_id&quot;:i,&quot;stu_name&quot;:&quot;李&quot; + i});\n}\ndb.student.find();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/12.png\" alt=\"\"></p>\n</li>\n<li><p>查询集合中的第一个文档</p>\n<pre><code>db.collectionName.findOne();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/13.png\" alt=\"\"></p>\n</li>\n</ul>\n<p><strong>条件查询：</strong></p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:right\">价格</th>\n<th style=\"text-align:center\">数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>等于(=)</td>\n<td style=\"text-align:right\">/</td>\n<td style=\"text-align:center\">查找名字为李四的所有学生：db.student.find({“name”:”李四”});</td>\n</tr>\n<tr>\n<td>等于(!=)</td>\n<td style=\"text-align:right\">\\$ne</td>\n<td style=\"text-align:center\">查找名字不为李四的所有学生：db.student.find({“name”:{‘$ne:”李四”}’}});</td>\n</tr>\n<tr>\n<td>大于(&gt;)</td>\n<td style=\"text-align:right\">\\$gt</td>\n<td style=\"text-align:center\">查找所有年龄大于5的学生：db.student.find({“age”:{$gt:5}});</td>\n</tr>\n<tr>\n<td>小于(&lt;)</td>\n<td style=\"text-align:right\">\\$lt</td>\n<td style=\"text-align:center\">查找所有年龄小于15的学生：db.student.find({“age”:{$lt:15}});</td>\n</tr>\n<tr>\n<td>大于等于(&gt;=)</td>\n<td style=\"text-align:right\">\\$gte</td>\n<td style=\"text-align:center\">查找所有年龄大于或等于5的学生：db.student.find({“age”:{$gte:5}});</td>\n</tr>\n<tr>\n<td>小于等于(&gt;=)</td>\n<td style=\"text-align:right\">\\ &#124; $lte</td>\n<td style=\"text-align:center\">查找所有年龄小于或等于15的学生：db.student.find({“age”:{$lte:15}});</td>\n</tr>\n<tr>\n<td>与(and)</td>\n<td style=\"text-align:right\">/</td>\n<td style=\"text-align:center\">查找所有年龄小于或等于15且班级编号为1的所有学生：db.student.find({“age”:{$lte:15},”class_id”:1});</td>\n</tr>\n<tr>\n<td>或(or)</td>\n<td style=\"text-align:right\">{$or:[{条件1},{条件2}]}</td>\n<td style=\"text-align:center\">查找所有年龄小于或等于15或者班级为1的所有学生：db.student.find({$or:[{“age”:{$lte:15}},{“class_id”:1}]});</td>\n</tr>\n<tr>\n<td>非或(nor)</td>\n<td style=\"text-align:right\">{$nor:[{条件1},{条件2}]}</td>\n<td style=\"text-align:center\">条件1不能满足和条件2不能满足</td>\n</tr>\n<tr>\n<td>集合运算符(in)</td>\n<td style=\"text-align:right\">\\$in</td>\n<td style=\"text-align:center\">查找年龄12或者13或者14的学生：db.student.find({“age”:{$in:[12,13,14]}});</td>\n</tr>\n<tr>\n<td>集合运算符(all)</td>\n<td style=\"text-align:right\">\\$all</td>\n<td style=\"text-align:center\">查找爱好包含football,和basketBall的所有学生：db.student.find({“hobby”:{$all:[“football”,”basketBall”]}});</td>\n</tr>\n<tr>\n<td>是否存在(exists)</td>\n<td style=\"text-align:right\">$exists</td>\n<td style=\"text-align:center\">查询存在hooby的所有学生：db.student.find({hobby:{$exists:1}});{$exists:0}代表不存在</td>\n</tr>\n</tbody>\n</table>\n<p>5.统计、排序、分页</p>\n<ul>\n<li><p>统计</p>\n<pre><code>db.collectionName.count();\ndb.collectionName.find().count();\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/14.png\" alt=\"\"></p>\n</li>\n<li><p>排序</p>\n<pre><code># key升序排列\ndb.collectionName.find().sort({key:1});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/15.png\" alt=\"\"></p>\n</li>\n</ul>\n<pre><code># key降序排列\ndb.collectionName.find().sort({key:-1});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/16.png\" alt=\"\"></p>\n<ul>\n<li>分页<pre><code>db.collectionName.find().skip(n).limit(m);\n</code></pre>从 <code>collectionName</code> 中第 <code>n</code> 个文档开始读取，共读取 <code>m</code> 个文档，需要注意的是 <code>MongoDB</code> 中 <code>n</code> 是从 0 开始的。可以类比 <code>MySQL</code> 中 <code>limit</code> 方法。<code>n</code> 相当于 <code>limit</code> 中的第一个方法，<code>m</code> 相当于 <code>limit</code> 中第二个参数,当使用分页时候，若使用 <code>count</code>，需要注意 <code>MongoDB</code> 统计数量默认是忽略分页的<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/17.png\" alt=\"\"><br>给 <code>count</code> 传递一个参数 <code>count(flag)</code>。<code>flag</code>为 <code>0</code>（默认情况为0）<code>忽视分页</code>，<code>flag</code> 为<code>1</code>，<code>不忽视分页</code>。<br>从 <code>student</code> 中取出6~12条数据<pre><code>db.student.find().skip(6).limit(6);\n</code></pre><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/18.png\" alt=\"\"><br>从集合 student 中取出第一条数据<pre><code>db.student.find().skip(0).limit(1);\n</code></pre><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/19.png\" alt=\"\"></li>\n</ul>\n<p>6.投影查询<br>在 MongoDB 中，每次查询都是将所有的键都显示出来了，怎样只让部分键显示呢？这就要用到投影查询。<br>比如，我只让集合 student 查询结果中 stu_name 显示。</p>\n<pre><code>db.student.find({},{_id:0,stu_id:0});\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%283%29/20.png\" alt=\"\"><br>在 <code>MongoDB</code> 中，<code>find</code> 函数里面的<code>第二个参数</code>是用来<code>控制</code>让哪些键<code>显示</code>或者<code>不显示</code>。<code>0</code>是<code>不显示</code>，<code>1</code>为<code>显示</code>。<code>默认</code>情况下为<code>显示</code>。</p>\n"},{"title":"MongoDB的索引（四）","date":"2017-04-30T01:57:56.000Z","_content":"\nMongoDB 索引分类\n----------------\n1、_id 索引\n`_id 索引`是绝大多数集合`默认建立`的`索引`，对于每个插入的数据，`MongoDB` 都会`自动生成`一条`唯一`的 `_id`字段\n\n2、单键索引\n1.\t`单键索引`是最`普通的`索引\n2.\t与`_id索引`不同，`单键索引`不会自动创建 如：一条记录，形式为：`{ \"stu_id\" : 1, \"stu_name\" : \"李1\"}`\n3.\t可以重复创建，若创建已经存在的索引，则会直接返回成功\n\n\n3、多键索引\n多键索引与单键索引创建形式相同，区别在于字段的值：\n\n 1. 单键索引：值为一个单一的值，如字符串，数字或日期\n 2. 多键索引：值具有多个记录，如数组\n \n4、复合索引\n查询多个条件时,建立复合索引\n例如`{stu_id:1,stu_name:-1}`这样一条数据，要按照`学生id`与`学生名字`的值进行查询，就需要创建复合索引。\n```\n# 1升序;-1降序\ndb.student.createIndex({stu_id:1,stu_name:-1}) \n\n# 使用复合索引查询\ndb.student.find({stu_id:1,stu_name:\"李1\"})\n```\n\n5、过期索引（TTL索引）\n在`一段时间`后会`过期`的`索引`，在`索引过期`后，相应的`数据`会被`删除`，适合存储在`一段时间`之后会`失效`的`数据`，比如用户的登录信息、存储的日志等\n```\n# 创建过期索引，time-字段，expireAfterSeconds-在多少秒后过期，单位：秒\ndb.collection.createIndex({time:1},{expireAfterSeconds:10}) \n\n# time索引30秒后失效\ndb.student.createIndex({time:1},{expireAfterSeconds:15})\n\n# new Date()自动获取当前时间，ISODate\ndb.student.insert({time:new Date()}) \ndb.student find() \n\n```\n过30秒后再查找，刚才的数据就已经不存在了\n![][1]\n过期索引的限制：\n\n 1. 存储在过期索引字段的值`必须`是指定的`时间类型`，必须是 `ISODate` 或者 `ISODate` 数组，`不能`使用`时间戳`，否则不能`自动删除`\n 2. 如果指定了 `ISODate` 数组，则按照`最小`的`时间`进行删除\n 3. 过期索引`不能`是`复合索引`。因为`不能`指定`两个`过期时间\n 4. 删除时间是不精确的。删除过程是由 `MongoDB` 的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差\n \n6、全文索引（文本索引）\n```\n# 每个集合只允许创建一个全文索引\ndb.articles.createIndex({key: \"text\"});\n\n# 多个字段上创建全文索引\ndb.articles.createIndex({key1:\"text\",key2:\"text\"});\n\n# 所有字段建立全文索引\ndb.articles.createIndex({\"$**\":\"text\"});\n\n# 全文索引的查找\ndb.articles.find({$text:{$search:\"coffee\"}});\n\n# 空格代表或操作，aa或bb或cc\ndb.articles.find({$text:{$search:\"aa bb cc\"}});\n\n# -号为非操作，即不包含cc的\ndb.articles.find({$text:{$search:\"aa bb -cc\"}}); \n\n# 加双引号可以提供与关系操作\ndb.articles.find({$text:{$search: \"\\\"aa\\\" \\\"bb\\\" \\\"cc\\\"\"}}); \n\n# 全文索引相似度查询，score 返回字段越高相关度越高\ndb.articles.find({$text:{$search:\"aa bb\"}},{score:{$meta:\"textScore\"}});\n\n# 对`查询`出的`结果`根据`得分`进行`排序`\ndb.articles.find({$text:{$search:\"aa bb\"}},{score:{$meta:\"textScore\"}}).sort({score:{$meta:\"textScore\"}})\n```\n全文索引的限制：\n\n - 每次查询，只能指定一个`$text`查询\n - `$text`查询不能出现在`$nor`查询(非或)中\n - 查询中如果包含了 `$text`, `hint` 不再起作用（hint:强制指定索引）\n - `MongoDB` 全文索引还`不支持中文`\n\n6、地理位置索引\n将一些点的位置存储在 `MongoDB` 中，创建索引后，可以按照位置来查找其他点。\n\n地理位置索引分为两类：\n\n - `2d 索引`，用于存储和查找`平面上的点`\n - `2dsphere 索引`，用于存储和查找`球面上的点`\n\n1.2d索引:\n\n`2d 索引`的`取值范围`以及表示方法:`经纬度[经度,纬度]`,经纬度取值范围 经度`[-180,180]`，纬度`[-90,90]`\n\n```\n# 创建 2d 索引\ndb.collection.createIndex({<location field>:”2d”});\n\n# 查询距离某个点最近的点 ,默认返回最近的100个点\ndb.collection.find({w:{$near:[x,y]}});\n\n# $maxDistance:x 限制返回的最远距离\ndb.collection.find({w:{$near:[x,y],$maxDistance:z}});\n\n# 查询矩形中的点\ndb.collection.find({w:{$geoWithin:{$box:[[0,0],[3,3]]}}});\n\n# 查询圆中的点\ndb.collection.find({w:{$geoWithin:{$center:[[0,0],5]}}});\n\n# 查询多边形中的点\ndb.collection.find({w:{$geoWithin:{$polygon:[[0,0],[0,1],[2,5],[6,1]]}}});\n\n# geoNear查询，minDistance对2D索引无效，对2Dsphere有效，num:返回数量\ndb.runCommand({geoNear:\"collectionName\",near:[x,y],minDistance:10,num:1});\n\n```\n\n2.2dsphere 索引:\n\n`2dsphere` 索引位置表示方式是用 `GeoJSON` 对象来存储的，存储`GeoJSON`数据的话，在文档中使用 `type` 字段来指定 `GeoJSON` 对象类型以及 `coordinates` 对象来指定对象的坐标：\n\n```\n{ type: \"<GeoJSON type>\" , coordinates: <coordinates> }\n```\n`MongoDB` 默认使用 `WGS84` 基准作为 `GeoJSON `默认的坐标参考系统。\n\n`GeoJSON` 对象类型：\n```\n# 点（Point）\n{ type: \"Point\", coordinates: [ 40, 5 ] }\n\n# 线（LineString），coordinate 成员必须是两个或多个坐标的数组\n{ type: \"LineString\", coordinates: [ [ 40, 5 ], [ 41, 6 ] ] }\n\n# 单环多边形（ Polygon ），第一个和最后一个坐标必须相同以关闭这个多边形 \n{\n  type: \"Polygon\",\n  coordinates: [ [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0  ] ] ]\n}\n\n# 多环多边形（ Polygon ）\n# 第一个描述的环必须是外环，外环不能自交叉，所有内环必须全部包含在外环中，内环之间不能交叉或覆盖。内环不能共边\n{\n  type : \"Polygon\",\n  coordinates : [\n     [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0 ] ],\n     [ [ 2 , 2 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 2 , 2 ] ]\n  ]\n}\n\n# 多点（ MultiPoint ）\n{\n  type: \"MultiPoint\",\n  coordinates: [\n     [ -73.9580, 40.8003 ],\n     [ -73.9498, 40.7968 ],\n     [ -73.9737, 40.7648 ],\n     [ -73.9814, 40.7681 ]\n  ]\n}\n\n# 多线（ MultiLineString ）\n{\n  type: \"MultiLineString\",\n  coordinates: [\n     [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],\n     [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],\n     [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],\n     [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]\n  ]\n}\n\n# 多个多边形（ MultiPolygon ）\n{\n  type: \"MultiPolygon\",\n  coordinates: [\n     [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.9814, 40.7681 ], [ -73.958, 40.8003 ] ] ],\n     [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.958, 40.8003 ] ] ]\n  ]\n}\n\n# 几何集合（GeometryCollection）\n{\n  type: \"GeometryCollection\",\n  geometries: [\n     {\n       type: \"MultiPoint\",\n       coordinates: [\n          [ -73.9580, 40.8003 ],\n          [ -73.9498, 40.7968 ],\n          [ -73.9737, 40.7648 ],\n          [ -73.9814, 40.7681 ]\n       ]\n     },\n     {\n       type: \"MultiLineString\",\n       coordinates: [\n          [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],\n          [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],\n          [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],\n          [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]\n       ]\n     }\n  ]\n}\n```\n创建 `2dsphere` 索引：\n```\n# 创建2dsphere索引\ndb.collection.createIndex({<location field>:”2dsphere”});\n\n# 插入一个坐标为[-73.97,40.77]的点\ndb.places.insert(\n   {\n      loc : { type: \"Point\", coordinates: [ -73.97, 40.77 ] },\n      name: \"Central Park\",\n      category : \"Parks\"\n   }\n)\n```\n\n2dsphere 查询类型：\n\n - `$near （GeoJSON点，2dsphere索引）`\n```\n# 查询坐标[-73.9667, 40.78],最近1000米，最远5000米的记录\ndb.places.find(\n   {\n     location:\n       { $near :\n          {\n            $geometry: { type: \"Point\",  coordinates: [ -73.9667, 40.78 ] },\n            $minDistance: 1000,\n            $maxDistance: 5000\n          }\n       }\n   }\n)\n```\n - `$nearSphere （GeoJSON点，2dsphere索引）`\n```\n# 查询坐标[-73.9667, 40.78]最少0.0004弧度距离的记录\ndb.legacyPlaces.find(\n   { location : { $nearSphere : [ -73.9667, 40.78 ], $minDistance: 0.0004 } }\n)\n```\n - `$geoWithin:{$geometry:...}` \n - `$geoWithin:{$centerSphere:...}`\n```\n# 查询坐标[-88, 30]，半径10/3963.2范围内的\ndb.places.find( {\n  loc: { $geoWithin: { $centerSphere: [ [ -88, 30 ], 10/3963.2 ] } }\n} )\n```\n - `$geoIntersects`  \n```\n# 查询多边形内坐标[ 0, 0 ], [ 3, 6 ], [ 6, 1 ], [ 0, 0 ]相交的记录\ndb.places.find(\n   {\n     loc: {\n       $geoIntersects: {\n          $geometry: {\n             type: \"Polygon\" ,\n             coordinates: [\n               [ [ 0, 0 ], [ 3, 6 ], [ 6, 1 ], [ 0, 0 ] ]\n             ]\n          }\n       }\n     }\n   }\n)\n```\n索引的操作\n----------------\n```\n# 查询索引\ndb.collection.getIndexes();\n\n# 创建索引 1:正序；-1:倒序\ndb.collection.createIndex({indexValue:1/-1);\n\n# 指定索引别名\ndb.collection.createIndex({indexValue},{name:});\n\n# 指定唯一索引\ndb.collection.createIndex({indexValue},{unique:true/false});\n\n# 指定索引是否稀疏\n#   例如，我们为一个collection的x字段指定了索引，\n#   但这个collection中可以# 插入如{y:1,z:1}这种不存在x字段的数据，\n#   如果索引为不稀疏的，MongoDB 依然会为这个数据创建索引，\n#   如果在创建索引时指定为稀疏索引，那么就可以避免这件事情发生了\ndb.collection.createIndex({indexValue},{sparse:true/false});\n\n# 删除某个索引\ndb.collection.dropIndex({indexValue:1});\n\n# 删除集合下所有索引\ndb.collection.dropIndexes();\n```\n\n\n  [1]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%284%29/1.png\n\n\n\n\n  ","source":"_posts/MongoDB的索引(四).md","raw":"---\ntitle: MongoDB的索引（四）\ndate: 2017-04-30 09:57:56\ntags:\n- MongoDB\ncategories:\n- NoSQL\n---\n\nMongoDB 索引分类\n----------------\n1、_id 索引\n`_id 索引`是绝大多数集合`默认建立`的`索引`，对于每个插入的数据，`MongoDB` 都会`自动生成`一条`唯一`的 `_id`字段\n\n2、单键索引\n1.\t`单键索引`是最`普通的`索引\n2.\t与`_id索引`不同，`单键索引`不会自动创建 如：一条记录，形式为：`{ \"stu_id\" : 1, \"stu_name\" : \"李1\"}`\n3.\t可以重复创建，若创建已经存在的索引，则会直接返回成功\n\n\n3、多键索引\n多键索引与单键索引创建形式相同，区别在于字段的值：\n\n 1. 单键索引：值为一个单一的值，如字符串，数字或日期\n 2. 多键索引：值具有多个记录，如数组\n \n4、复合索引\n查询多个条件时,建立复合索引\n例如`{stu_id:1,stu_name:-1}`这样一条数据，要按照`学生id`与`学生名字`的值进行查询，就需要创建复合索引。\n```\n# 1升序;-1降序\ndb.student.createIndex({stu_id:1,stu_name:-1}) \n\n# 使用复合索引查询\ndb.student.find({stu_id:1,stu_name:\"李1\"})\n```\n\n5、过期索引（TTL索引）\n在`一段时间`后会`过期`的`索引`，在`索引过期`后，相应的`数据`会被`删除`，适合存储在`一段时间`之后会`失效`的`数据`，比如用户的登录信息、存储的日志等\n```\n# 创建过期索引，time-字段，expireAfterSeconds-在多少秒后过期，单位：秒\ndb.collection.createIndex({time:1},{expireAfterSeconds:10}) \n\n# time索引30秒后失效\ndb.student.createIndex({time:1},{expireAfterSeconds:15})\n\n# new Date()自动获取当前时间，ISODate\ndb.student.insert({time:new Date()}) \ndb.student find() \n\n```\n过30秒后再查找，刚才的数据就已经不存在了\n![][1]\n过期索引的限制：\n\n 1. 存储在过期索引字段的值`必须`是指定的`时间类型`，必须是 `ISODate` 或者 `ISODate` 数组，`不能`使用`时间戳`，否则不能`自动删除`\n 2. 如果指定了 `ISODate` 数组，则按照`最小`的`时间`进行删除\n 3. 过期索引`不能`是`复合索引`。因为`不能`指定`两个`过期时间\n 4. 删除时间是不精确的。删除过程是由 `MongoDB` 的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差\n \n6、全文索引（文本索引）\n```\n# 每个集合只允许创建一个全文索引\ndb.articles.createIndex({key: \"text\"});\n\n# 多个字段上创建全文索引\ndb.articles.createIndex({key1:\"text\",key2:\"text\"});\n\n# 所有字段建立全文索引\ndb.articles.createIndex({\"$**\":\"text\"});\n\n# 全文索引的查找\ndb.articles.find({$text:{$search:\"coffee\"}});\n\n# 空格代表或操作，aa或bb或cc\ndb.articles.find({$text:{$search:\"aa bb cc\"}});\n\n# -号为非操作，即不包含cc的\ndb.articles.find({$text:{$search:\"aa bb -cc\"}}); \n\n# 加双引号可以提供与关系操作\ndb.articles.find({$text:{$search: \"\\\"aa\\\" \\\"bb\\\" \\\"cc\\\"\"}}); \n\n# 全文索引相似度查询，score 返回字段越高相关度越高\ndb.articles.find({$text:{$search:\"aa bb\"}},{score:{$meta:\"textScore\"}});\n\n# 对`查询`出的`结果`根据`得分`进行`排序`\ndb.articles.find({$text:{$search:\"aa bb\"}},{score:{$meta:\"textScore\"}}).sort({score:{$meta:\"textScore\"}})\n```\n全文索引的限制：\n\n - 每次查询，只能指定一个`$text`查询\n - `$text`查询不能出现在`$nor`查询(非或)中\n - 查询中如果包含了 `$text`, `hint` 不再起作用（hint:强制指定索引）\n - `MongoDB` 全文索引还`不支持中文`\n\n6、地理位置索引\n将一些点的位置存储在 `MongoDB` 中，创建索引后，可以按照位置来查找其他点。\n\n地理位置索引分为两类：\n\n - `2d 索引`，用于存储和查找`平面上的点`\n - `2dsphere 索引`，用于存储和查找`球面上的点`\n\n1.2d索引:\n\n`2d 索引`的`取值范围`以及表示方法:`经纬度[经度,纬度]`,经纬度取值范围 经度`[-180,180]`，纬度`[-90,90]`\n\n```\n# 创建 2d 索引\ndb.collection.createIndex({<location field>:”2d”});\n\n# 查询距离某个点最近的点 ,默认返回最近的100个点\ndb.collection.find({w:{$near:[x,y]}});\n\n# $maxDistance:x 限制返回的最远距离\ndb.collection.find({w:{$near:[x,y],$maxDistance:z}});\n\n# 查询矩形中的点\ndb.collection.find({w:{$geoWithin:{$box:[[0,0],[3,3]]}}});\n\n# 查询圆中的点\ndb.collection.find({w:{$geoWithin:{$center:[[0,0],5]}}});\n\n# 查询多边形中的点\ndb.collection.find({w:{$geoWithin:{$polygon:[[0,0],[0,1],[2,5],[6,1]]}}});\n\n# geoNear查询，minDistance对2D索引无效，对2Dsphere有效，num:返回数量\ndb.runCommand({geoNear:\"collectionName\",near:[x,y],minDistance:10,num:1});\n\n```\n\n2.2dsphere 索引:\n\n`2dsphere` 索引位置表示方式是用 `GeoJSON` 对象来存储的，存储`GeoJSON`数据的话，在文档中使用 `type` 字段来指定 `GeoJSON` 对象类型以及 `coordinates` 对象来指定对象的坐标：\n\n```\n{ type: \"<GeoJSON type>\" , coordinates: <coordinates> }\n```\n`MongoDB` 默认使用 `WGS84` 基准作为 `GeoJSON `默认的坐标参考系统。\n\n`GeoJSON` 对象类型：\n```\n# 点（Point）\n{ type: \"Point\", coordinates: [ 40, 5 ] }\n\n# 线（LineString），coordinate 成员必须是两个或多个坐标的数组\n{ type: \"LineString\", coordinates: [ [ 40, 5 ], [ 41, 6 ] ] }\n\n# 单环多边形（ Polygon ），第一个和最后一个坐标必须相同以关闭这个多边形 \n{\n  type: \"Polygon\",\n  coordinates: [ [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0  ] ] ]\n}\n\n# 多环多边形（ Polygon ）\n# 第一个描述的环必须是外环，外环不能自交叉，所有内环必须全部包含在外环中，内环之间不能交叉或覆盖。内环不能共边\n{\n  type : \"Polygon\",\n  coordinates : [\n     [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0 ] ],\n     [ [ 2 , 2 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 2 , 2 ] ]\n  ]\n}\n\n# 多点（ MultiPoint ）\n{\n  type: \"MultiPoint\",\n  coordinates: [\n     [ -73.9580, 40.8003 ],\n     [ -73.9498, 40.7968 ],\n     [ -73.9737, 40.7648 ],\n     [ -73.9814, 40.7681 ]\n  ]\n}\n\n# 多线（ MultiLineString ）\n{\n  type: \"MultiLineString\",\n  coordinates: [\n     [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],\n     [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],\n     [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],\n     [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]\n  ]\n}\n\n# 多个多边形（ MultiPolygon ）\n{\n  type: \"MultiPolygon\",\n  coordinates: [\n     [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.9814, 40.7681 ], [ -73.958, 40.8003 ] ] ],\n     [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.958, 40.8003 ] ] ]\n  ]\n}\n\n# 几何集合（GeometryCollection）\n{\n  type: \"GeometryCollection\",\n  geometries: [\n     {\n       type: \"MultiPoint\",\n       coordinates: [\n          [ -73.9580, 40.8003 ],\n          [ -73.9498, 40.7968 ],\n          [ -73.9737, 40.7648 ],\n          [ -73.9814, 40.7681 ]\n       ]\n     },\n     {\n       type: \"MultiLineString\",\n       coordinates: [\n          [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],\n          [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],\n          [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],\n          [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]\n       ]\n     }\n  ]\n}\n```\n创建 `2dsphere` 索引：\n```\n# 创建2dsphere索引\ndb.collection.createIndex({<location field>:”2dsphere”});\n\n# 插入一个坐标为[-73.97,40.77]的点\ndb.places.insert(\n   {\n      loc : { type: \"Point\", coordinates: [ -73.97, 40.77 ] },\n      name: \"Central Park\",\n      category : \"Parks\"\n   }\n)\n```\n\n2dsphere 查询类型：\n\n - `$near （GeoJSON点，2dsphere索引）`\n```\n# 查询坐标[-73.9667, 40.78],最近1000米，最远5000米的记录\ndb.places.find(\n   {\n     location:\n       { $near :\n          {\n            $geometry: { type: \"Point\",  coordinates: [ -73.9667, 40.78 ] },\n            $minDistance: 1000,\n            $maxDistance: 5000\n          }\n       }\n   }\n)\n```\n - `$nearSphere （GeoJSON点，2dsphere索引）`\n```\n# 查询坐标[-73.9667, 40.78]最少0.0004弧度距离的记录\ndb.legacyPlaces.find(\n   { location : { $nearSphere : [ -73.9667, 40.78 ], $minDistance: 0.0004 } }\n)\n```\n - `$geoWithin:{$geometry:...}` \n - `$geoWithin:{$centerSphere:...}`\n```\n# 查询坐标[-88, 30]，半径10/3963.2范围内的\ndb.places.find( {\n  loc: { $geoWithin: { $centerSphere: [ [ -88, 30 ], 10/3963.2 ] } }\n} )\n```\n - `$geoIntersects`  \n```\n# 查询多边形内坐标[ 0, 0 ], [ 3, 6 ], [ 6, 1 ], [ 0, 0 ]相交的记录\ndb.places.find(\n   {\n     loc: {\n       $geoIntersects: {\n          $geometry: {\n             type: \"Polygon\" ,\n             coordinates: [\n               [ [ 0, 0 ], [ 3, 6 ], [ 6, 1 ], [ 0, 0 ] ]\n             ]\n          }\n       }\n     }\n   }\n)\n```\n索引的操作\n----------------\n```\n# 查询索引\ndb.collection.getIndexes();\n\n# 创建索引 1:正序；-1:倒序\ndb.collection.createIndex({indexValue:1/-1);\n\n# 指定索引别名\ndb.collection.createIndex({indexValue},{name:});\n\n# 指定唯一索引\ndb.collection.createIndex({indexValue},{unique:true/false});\n\n# 指定索引是否稀疏\n#   例如，我们为一个collection的x字段指定了索引，\n#   但这个collection中可以# 插入如{y:1,z:1}这种不存在x字段的数据，\n#   如果索引为不稀疏的，MongoDB 依然会为这个数据创建索引，\n#   如果在创建索引时指定为稀疏索引，那么就可以避免这件事情发生了\ndb.collection.createIndex({indexValue},{sparse:true/false});\n\n# 删除某个索引\ndb.collection.dropIndex({indexValue:1});\n\n# 删除集合下所有索引\ndb.collection.dropIndexes();\n```\n\n\n  [1]: http://olln3wpar.bkt.clouddn.com/image/MongoDB%284%29/1.png\n\n\n\n\n  ","slug":"MongoDB的索引(四)","published":1,"updated":"2018-01-04T01:37:41.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeqq000nu8w6gikdr826","content":"<h2 id=\"MongoDB-索引分类\"><a href=\"#MongoDB-索引分类\" class=\"headerlink\" title=\"MongoDB 索引分类\"></a>MongoDB 索引分类</h2><p>1、_id 索引<br><code>_id 索引</code>是绝大多数集合<code>默认建立</code>的<code>索引</code>，对于每个插入的数据，<code>MongoDB</code> 都会<code>自动生成</code>一条<code>唯一</code>的 <code>_id</code>字段</p>\n<p>2、单键索引</p>\n<ol>\n<li><code>单键索引</code>是最<code>普通的</code>索引</li>\n<li>与<code>_id索引</code>不同，<code>单键索引</code>不会自动创建 如：一条记录，形式为：<code>{ &quot;stu_id&quot; : 1, &quot;stu_name&quot; : &quot;李1&quot;}</code></li>\n<li>可以重复创建，若创建已经存在的索引，则会直接返回成功</li>\n</ol>\n<p>3、多键索引<br>多键索引与单键索引创建形式相同，区别在于字段的值：</p>\n<ol>\n<li>单键索引：值为一个单一的值，如字符串，数字或日期</li>\n<li>多键索引：值具有多个记录，如数组</li>\n</ol>\n<p>4、复合索引<br>查询多个条件时,建立复合索引<br>例如<code>{stu_id:1,stu_name:-1}</code>这样一条数据，要按照<code>学生id</code>与<code>学生名字</code>的值进行查询，就需要创建复合索引。</p>\n<pre><code># 1升序;-1降序\ndb.student.createIndex({stu_id:1,stu_name:-1}) \n\n# 使用复合索引查询\ndb.student.find({stu_id:1,stu_name:&quot;李1&quot;})\n</code></pre><p>5、过期索引（TTL索引）<br>在<code>一段时间</code>后会<code>过期</code>的<code>索引</code>，在<code>索引过期</code>后，相应的<code>数据</code>会被<code>删除</code>，适合存储在<code>一段时间</code>之后会<code>失效</code>的<code>数据</code>，比如用户的登录信息、存储的日志等</p>\n<pre><code># 创建过期索引，time-字段，expireAfterSeconds-在多少秒后过期，单位：秒\ndb.collection.createIndex({time:1},{expireAfterSeconds:10}) \n\n# time索引30秒后失效\ndb.student.createIndex({time:1},{expireAfterSeconds:15})\n\n# new Date()自动获取当前时间，ISODate\ndb.student.insert({time:new Date()}) \ndb.student find()\n</code></pre><p>过30秒后再查找，刚才的数据就已经不存在了<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%284%29/1.png\" alt=\"\"><br>过期索引的限制：</p>\n<ol>\n<li>存储在过期索引字段的值<code>必须</code>是指定的<code>时间类型</code>，必须是 <code>ISODate</code> 或者 <code>ISODate</code> 数组，<code>不能</code>使用<code>时间戳</code>，否则不能<code>自动删除</code></li>\n<li>如果指定了 <code>ISODate</code> 数组，则按照<code>最小</code>的<code>时间</code>进行删除</li>\n<li>过期索引<code>不能</code>是<code>复合索引</code>。因为<code>不能</code>指定<code>两个</code>过期时间</li>\n<li>删除时间是不精确的。删除过程是由 <code>MongoDB</code> 的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差</li>\n</ol>\n<p>6、全文索引（文本索引）</p>\n<pre><code># 每个集合只允许创建一个全文索引\ndb.articles.createIndex({key: &quot;text&quot;});\n\n# 多个字段上创建全文索引\ndb.articles.createIndex({key1:&quot;text&quot;,key2:&quot;text&quot;});\n\n# 所有字段建立全文索引\ndb.articles.createIndex({&quot;$**&quot;:&quot;text&quot;});\n\n# 全文索引的查找\ndb.articles.find({$text:{$search:&quot;coffee&quot;}});\n\n# 空格代表或操作，aa或bb或cc\ndb.articles.find({$text:{$search:&quot;aa bb cc&quot;}});\n\n# -号为非操作，即不包含cc的\ndb.articles.find({$text:{$search:&quot;aa bb -cc&quot;}}); \n\n# 加双引号可以提供与关系操作\ndb.articles.find({$text:{$search: &quot;\\&quot;aa\\&quot; \\&quot;bb\\&quot; \\&quot;cc\\&quot;&quot;}}); \n\n# 全文索引相似度查询，score 返回字段越高相关度越高\ndb.articles.find({$text:{$search:&quot;aa bb&quot;}},{score:{$meta:&quot;textScore&quot;}});\n\n# 对`查询`出的`结果`根据`得分`进行`排序`\ndb.articles.find({$text:{$search:&quot;aa bb&quot;}},{score:{$meta:&quot;textScore&quot;}}).sort({score:{$meta:&quot;textScore&quot;}})\n</code></pre><p>全文索引的限制：</p>\n<ul>\n<li>每次查询，只能指定一个<code>$text</code>查询</li>\n<li><code>$text</code>查询不能出现在<code>$nor</code>查询(非或)中</li>\n<li>查询中如果包含了 <code>$text</code>, <code>hint</code> 不再起作用（hint:强制指定索引）</li>\n<li><code>MongoDB</code> 全文索引还<code>不支持中文</code></li>\n</ul>\n<p>6、地理位置索引<br>将一些点的位置存储在 <code>MongoDB</code> 中，创建索引后，可以按照位置来查找其他点。</p>\n<p>地理位置索引分为两类：</p>\n<ul>\n<li><code>2d 索引</code>，用于存储和查找<code>平面上的点</code></li>\n<li><code>2dsphere 索引</code>，用于存储和查找<code>球面上的点</code></li>\n</ul>\n<p>1.2d索引:</p>\n<p><code>2d 索引</code>的<code>取值范围</code>以及表示方法:<code>经纬度[经度,纬度]</code>,经纬度取值范围 经度<code>[-180,180]</code>，纬度<code>[-90,90]</code></p>\n<pre><code># 创建 2d 索引\ndb.collection.createIndex({&lt;location field&gt;:”2d”});\n\n# 查询距离某个点最近的点 ,默认返回最近的100个点\ndb.collection.find({w:{$near:[x,y]}});\n\n# $maxDistance:x 限制返回的最远距离\ndb.collection.find({w:{$near:[x,y],$maxDistance:z}});\n\n# 查询矩形中的点\ndb.collection.find({w:{$geoWithin:{$box:[[0,0],[3,3]]}}});\n\n# 查询圆中的点\ndb.collection.find({w:{$geoWithin:{$center:[[0,0],5]}}});\n\n# 查询多边形中的点\ndb.collection.find({w:{$geoWithin:{$polygon:[[0,0],[0,1],[2,5],[6,1]]}}});\n\n# geoNear查询，minDistance对2D索引无效，对2Dsphere有效，num:返回数量\ndb.runCommand({geoNear:&quot;collectionName&quot;,near:[x,y],minDistance:10,num:1});\n</code></pre><p>2.2dsphere 索引:</p>\n<p><code>2dsphere</code> 索引位置表示方式是用 <code>GeoJSON</code> 对象来存储的，存储<code>GeoJSON</code>数据的话，在文档中使用 <code>type</code> 字段来指定 <code>GeoJSON</code> 对象类型以及 <code>coordinates</code> 对象来指定对象的坐标：</p>\n<pre><code>{ type: &quot;&lt;GeoJSON type&gt;&quot; , coordinates: &lt;coordinates&gt; }\n</code></pre><p><code>MongoDB</code> 默认使用 <code>WGS84</code> 基准作为 <code>GeoJSON</code>默认的坐标参考系统。</p>\n<p><code>GeoJSON</code> 对象类型：</p>\n<pre><code># 点（Point）\n{ type: &quot;Point&quot;, coordinates: [ 40, 5 ] }\n\n# 线（LineString），coordinate 成员必须是两个或多个坐标的数组\n{ type: &quot;LineString&quot;, coordinates: [ [ 40, 5 ], [ 41, 6 ] ] }\n\n# 单环多边形（ Polygon ），第一个和最后一个坐标必须相同以关闭这个多边形 \n{\n  type: &quot;Polygon&quot;,\n  coordinates: [ [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0  ] ] ]\n}\n\n# 多环多边形（ Polygon ）\n# 第一个描述的环必须是外环，外环不能自交叉，所有内环必须全部包含在外环中，内环之间不能交叉或覆盖。内环不能共边\n{\n  type : &quot;Polygon&quot;,\n  coordinates : [\n     [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0 ] ],\n     [ [ 2 , 2 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 2 , 2 ] ]\n  ]\n}\n\n# 多点（ MultiPoint ）\n{\n  type: &quot;MultiPoint&quot;,\n  coordinates: [\n     [ -73.9580, 40.8003 ],\n     [ -73.9498, 40.7968 ],\n     [ -73.9737, 40.7648 ],\n     [ -73.9814, 40.7681 ]\n  ]\n}\n\n# 多线（ MultiLineString ）\n{\n  type: &quot;MultiLineString&quot;,\n  coordinates: [\n     [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],\n     [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],\n     [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],\n     [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]\n  ]\n}\n\n# 多个多边形（ MultiPolygon ）\n{\n  type: &quot;MultiPolygon&quot;,\n  coordinates: [\n     [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.9814, 40.7681 ], [ -73.958, 40.8003 ] ] ],\n     [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.958, 40.8003 ] ] ]\n  ]\n}\n\n# 几何集合（GeometryCollection）\n{\n  type: &quot;GeometryCollection&quot;,\n  geometries: [\n     {\n       type: &quot;MultiPoint&quot;,\n       coordinates: [\n          [ -73.9580, 40.8003 ],\n          [ -73.9498, 40.7968 ],\n          [ -73.9737, 40.7648 ],\n          [ -73.9814, 40.7681 ]\n       ]\n     },\n     {\n       type: &quot;MultiLineString&quot;,\n       coordinates: [\n          [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],\n          [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],\n          [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],\n          [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]\n       ]\n     }\n  ]\n}\n</code></pre><p>创建 <code>2dsphere</code> 索引：</p>\n<pre><code># 创建2dsphere索引\ndb.collection.createIndex({&lt;location field&gt;:”2dsphere”});\n\n# 插入一个坐标为[-73.97,40.77]的点\ndb.places.insert(\n   {\n      loc : { type: &quot;Point&quot;, coordinates: [ -73.97, 40.77 ] },\n      name: &quot;Central Park&quot;,\n      category : &quot;Parks&quot;\n   }\n)\n</code></pre><p>2dsphere 查询类型：</p>\n<ul>\n<li><code>$near （GeoJSON点，2dsphere索引）</code><pre><code># 查询坐标[-73.9667, 40.78],最近1000米，最远5000米的记录\ndb.places.find(\n{\n  location:\n    { $near :\n       {\n         $geometry: { type: &quot;Point&quot;,  coordinates: [ -73.9667, 40.78 ] },\n         $minDistance: 1000,\n         $maxDistance: 5000\n       }\n    }\n}\n)\n</code></pre></li>\n<li><code>$nearSphere （GeoJSON点，2dsphere索引）</code><pre><code># 查询坐标[-73.9667, 40.78]最少0.0004弧度距离的记录\ndb.legacyPlaces.find(\n{ location : { $nearSphere : [ -73.9667, 40.78 ], $minDistance: 0.0004 } }\n)\n</code></pre></li>\n<li><code>$geoWithin:{$geometry:...}</code> </li>\n<li><code>$geoWithin:{$centerSphere:...}</code><pre><code># 查询坐标[-88, 30]，半径10/3963.2范围内的\ndb.places.find( {\nloc: { $geoWithin: { $centerSphere: [ [ -88, 30 ], 10/3963.2 ] } }\n} )\n</code></pre></li>\n<li><code>$geoIntersects</code>  <pre><code># 查询多边形内坐标[ 0, 0 ], [ 3, 6 ], [ 6, 1 ], [ 0, 0 ]相交的记录\ndb.places.find(\n{\n  loc: {\n    $geoIntersects: {\n       $geometry: {\n          type: &quot;Polygon&quot; ,\n          coordinates: [\n            [ [ 0, 0 ], [ 3, 6 ], [ 6, 1 ], [ 0, 0 ] ]\n          ]\n       }\n    }\n  }\n}\n)\n</code></pre>索引的操作</li>\n</ul>\n<hr>\n<pre><code># 查询索引\ndb.collection.getIndexes();\n\n# 创建索引 1:正序；-1:倒序\ndb.collection.createIndex({indexValue:1/-1);\n\n# 指定索引别名\ndb.collection.createIndex({indexValue},{name:});\n\n# 指定唯一索引\ndb.collection.createIndex({indexValue},{unique:true/false});\n\n# 指定索引是否稀疏\n#   例如，我们为一个collection的x字段指定了索引，\n#   但这个collection中可以# 插入如{y:1,z:1}这种不存在x字段的数据，\n#   如果索引为不稀疏的，MongoDB 依然会为这个数据创建索引，\n#   如果在创建索引时指定为稀疏索引，那么就可以避免这件事情发生了\ndb.collection.createIndex({indexValue},{sparse:true/false});\n\n# 删除某个索引\ndb.collection.dropIndex({indexValue:1});\n\n# 删除集合下所有索引\ndb.collection.dropIndexes();\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MongoDB-索引分类\"><a href=\"#MongoDB-索引分类\" class=\"headerlink\" title=\"MongoDB 索引分类\"></a>MongoDB 索引分类</h2><p>1、_id 索引<br><code>_id 索引</code>是绝大多数集合<code>默认建立</code>的<code>索引</code>，对于每个插入的数据，<code>MongoDB</code> 都会<code>自动生成</code>一条<code>唯一</code>的 <code>_id</code>字段</p>\n<p>2、单键索引</p>\n<ol>\n<li><code>单键索引</code>是最<code>普通的</code>索引</li>\n<li>与<code>_id索引</code>不同，<code>单键索引</code>不会自动创建 如：一条记录，形式为：<code>{ &quot;stu_id&quot; : 1, &quot;stu_name&quot; : &quot;李1&quot;}</code></li>\n<li>可以重复创建，若创建已经存在的索引，则会直接返回成功</li>\n</ol>\n<p>3、多键索引<br>多键索引与单键索引创建形式相同，区别在于字段的值：</p>\n<ol>\n<li>单键索引：值为一个单一的值，如字符串，数字或日期</li>\n<li>多键索引：值具有多个记录，如数组</li>\n</ol>\n<p>4、复合索引<br>查询多个条件时,建立复合索引<br>例如<code>{stu_id:1,stu_name:-1}</code>这样一条数据，要按照<code>学生id</code>与<code>学生名字</code>的值进行查询，就需要创建复合索引。</p>\n<pre><code># 1升序;-1降序\ndb.student.createIndex({stu_id:1,stu_name:-1}) \n\n# 使用复合索引查询\ndb.student.find({stu_id:1,stu_name:&quot;李1&quot;})\n</code></pre><p>5、过期索引（TTL索引）<br>在<code>一段时间</code>后会<code>过期</code>的<code>索引</code>，在<code>索引过期</code>后，相应的<code>数据</code>会被<code>删除</code>，适合存储在<code>一段时间</code>之后会<code>失效</code>的<code>数据</code>，比如用户的登录信息、存储的日志等</p>\n<pre><code># 创建过期索引，time-字段，expireAfterSeconds-在多少秒后过期，单位：秒\ndb.collection.createIndex({time:1},{expireAfterSeconds:10}) \n\n# time索引30秒后失效\ndb.student.createIndex({time:1},{expireAfterSeconds:15})\n\n# new Date()自动获取当前时间，ISODate\ndb.student.insert({time:new Date()}) \ndb.student find()\n</code></pre><p>过30秒后再查找，刚才的数据就已经不存在了<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MongoDB%284%29/1.png\" alt=\"\"><br>过期索引的限制：</p>\n<ol>\n<li>存储在过期索引字段的值<code>必须</code>是指定的<code>时间类型</code>，必须是 <code>ISODate</code> 或者 <code>ISODate</code> 数组，<code>不能</code>使用<code>时间戳</code>，否则不能<code>自动删除</code></li>\n<li>如果指定了 <code>ISODate</code> 数组，则按照<code>最小</code>的<code>时间</code>进行删除</li>\n<li>过期索引<code>不能</code>是<code>复合索引</code>。因为<code>不能</code>指定<code>两个</code>过期时间</li>\n<li>删除时间是不精确的。删除过程是由 <code>MongoDB</code> 的后台进程每60s跑一次的，而且删除也需要一定时间，所以存在误差</li>\n</ol>\n<p>6、全文索引（文本索引）</p>\n<pre><code># 每个集合只允许创建一个全文索引\ndb.articles.createIndex({key: &quot;text&quot;});\n\n# 多个字段上创建全文索引\ndb.articles.createIndex({key1:&quot;text&quot;,key2:&quot;text&quot;});\n\n# 所有字段建立全文索引\ndb.articles.createIndex({&quot;$**&quot;:&quot;text&quot;});\n\n# 全文索引的查找\ndb.articles.find({$text:{$search:&quot;coffee&quot;}});\n\n# 空格代表或操作，aa或bb或cc\ndb.articles.find({$text:{$search:&quot;aa bb cc&quot;}});\n\n# -号为非操作，即不包含cc的\ndb.articles.find({$text:{$search:&quot;aa bb -cc&quot;}}); \n\n# 加双引号可以提供与关系操作\ndb.articles.find({$text:{$search: &quot;\\&quot;aa\\&quot; \\&quot;bb\\&quot; \\&quot;cc\\&quot;&quot;}}); \n\n# 全文索引相似度查询，score 返回字段越高相关度越高\ndb.articles.find({$text:{$search:&quot;aa bb&quot;}},{score:{$meta:&quot;textScore&quot;}});\n\n# 对`查询`出的`结果`根据`得分`进行`排序`\ndb.articles.find({$text:{$search:&quot;aa bb&quot;}},{score:{$meta:&quot;textScore&quot;}}).sort({score:{$meta:&quot;textScore&quot;}})\n</code></pre><p>全文索引的限制：</p>\n<ul>\n<li>每次查询，只能指定一个<code>$text</code>查询</li>\n<li><code>$text</code>查询不能出现在<code>$nor</code>查询(非或)中</li>\n<li>查询中如果包含了 <code>$text</code>, <code>hint</code> 不再起作用（hint:强制指定索引）</li>\n<li><code>MongoDB</code> 全文索引还<code>不支持中文</code></li>\n</ul>\n<p>6、地理位置索引<br>将一些点的位置存储在 <code>MongoDB</code> 中，创建索引后，可以按照位置来查找其他点。</p>\n<p>地理位置索引分为两类：</p>\n<ul>\n<li><code>2d 索引</code>，用于存储和查找<code>平面上的点</code></li>\n<li><code>2dsphere 索引</code>，用于存储和查找<code>球面上的点</code></li>\n</ul>\n<p>1.2d索引:</p>\n<p><code>2d 索引</code>的<code>取值范围</code>以及表示方法:<code>经纬度[经度,纬度]</code>,经纬度取值范围 经度<code>[-180,180]</code>，纬度<code>[-90,90]</code></p>\n<pre><code># 创建 2d 索引\ndb.collection.createIndex({&lt;location field&gt;:”2d”});\n\n# 查询距离某个点最近的点 ,默认返回最近的100个点\ndb.collection.find({w:{$near:[x,y]}});\n\n# $maxDistance:x 限制返回的最远距离\ndb.collection.find({w:{$near:[x,y],$maxDistance:z}});\n\n# 查询矩形中的点\ndb.collection.find({w:{$geoWithin:{$box:[[0,0],[3,3]]}}});\n\n# 查询圆中的点\ndb.collection.find({w:{$geoWithin:{$center:[[0,0],5]}}});\n\n# 查询多边形中的点\ndb.collection.find({w:{$geoWithin:{$polygon:[[0,0],[0,1],[2,5],[6,1]]}}});\n\n# geoNear查询，minDistance对2D索引无效，对2Dsphere有效，num:返回数量\ndb.runCommand({geoNear:&quot;collectionName&quot;,near:[x,y],minDistance:10,num:1});\n</code></pre><p>2.2dsphere 索引:</p>\n<p><code>2dsphere</code> 索引位置表示方式是用 <code>GeoJSON</code> 对象来存储的，存储<code>GeoJSON</code>数据的话，在文档中使用 <code>type</code> 字段来指定 <code>GeoJSON</code> 对象类型以及 <code>coordinates</code> 对象来指定对象的坐标：</p>\n<pre><code>{ type: &quot;&lt;GeoJSON type&gt;&quot; , coordinates: &lt;coordinates&gt; }\n</code></pre><p><code>MongoDB</code> 默认使用 <code>WGS84</code> 基准作为 <code>GeoJSON</code>默认的坐标参考系统。</p>\n<p><code>GeoJSON</code> 对象类型：</p>\n<pre><code># 点（Point）\n{ type: &quot;Point&quot;, coordinates: [ 40, 5 ] }\n\n# 线（LineString），coordinate 成员必须是两个或多个坐标的数组\n{ type: &quot;LineString&quot;, coordinates: [ [ 40, 5 ], [ 41, 6 ] ] }\n\n# 单环多边形（ Polygon ），第一个和最后一个坐标必须相同以关闭这个多边形 \n{\n  type: &quot;Polygon&quot;,\n  coordinates: [ [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0  ] ] ]\n}\n\n# 多环多边形（ Polygon ）\n# 第一个描述的环必须是外环，外环不能自交叉，所有内环必须全部包含在外环中，内环之间不能交叉或覆盖。内环不能共边\n{\n  type : &quot;Polygon&quot;,\n  coordinates : [\n     [ [ 0 , 0 ] , [ 3 , 6 ] , [ 6 , 1 ] , [ 0 , 0 ] ],\n     [ [ 2 , 2 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 2 , 2 ] ]\n  ]\n}\n\n# 多点（ MultiPoint ）\n{\n  type: &quot;MultiPoint&quot;,\n  coordinates: [\n     [ -73.9580, 40.8003 ],\n     [ -73.9498, 40.7968 ],\n     [ -73.9737, 40.7648 ],\n     [ -73.9814, 40.7681 ]\n  ]\n}\n\n# 多线（ MultiLineString ）\n{\n  type: &quot;MultiLineString&quot;,\n  coordinates: [\n     [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],\n     [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],\n     [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],\n     [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]\n  ]\n}\n\n# 多个多边形（ MultiPolygon ）\n{\n  type: &quot;MultiPolygon&quot;,\n  coordinates: [\n     [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.9814, 40.7681 ], [ -73.958, 40.8003 ] ] ],\n     [ [ [ -73.958, 40.8003 ], [ -73.9498, 40.7968 ], [ -73.9737, 40.7648 ], [ -73.958, 40.8003 ] ] ]\n  ]\n}\n\n# 几何集合（GeometryCollection）\n{\n  type: &quot;GeometryCollection&quot;,\n  geometries: [\n     {\n       type: &quot;MultiPoint&quot;,\n       coordinates: [\n          [ -73.9580, 40.8003 ],\n          [ -73.9498, 40.7968 ],\n          [ -73.9737, 40.7648 ],\n          [ -73.9814, 40.7681 ]\n       ]\n     },\n     {\n       type: &quot;MultiLineString&quot;,\n       coordinates: [\n          [ [ -73.96943, 40.78519 ], [ -73.96082, 40.78095 ] ],\n          [ [ -73.96415, 40.79229 ], [ -73.95544, 40.78854 ] ],\n          [ [ -73.97162, 40.78205 ], [ -73.96374, 40.77715 ] ],\n          [ [ -73.97880, 40.77247 ], [ -73.97036, 40.76811 ] ]\n       ]\n     }\n  ]\n}\n</code></pre><p>创建 <code>2dsphere</code> 索引：</p>\n<pre><code># 创建2dsphere索引\ndb.collection.createIndex({&lt;location field&gt;:”2dsphere”});\n\n# 插入一个坐标为[-73.97,40.77]的点\ndb.places.insert(\n   {\n      loc : { type: &quot;Point&quot;, coordinates: [ -73.97, 40.77 ] },\n      name: &quot;Central Park&quot;,\n      category : &quot;Parks&quot;\n   }\n)\n</code></pre><p>2dsphere 查询类型：</p>\n<ul>\n<li><code>$near （GeoJSON点，2dsphere索引）</code><pre><code># 查询坐标[-73.9667, 40.78],最近1000米，最远5000米的记录\ndb.places.find(\n{\n  location:\n    { $near :\n       {\n         $geometry: { type: &quot;Point&quot;,  coordinates: [ -73.9667, 40.78 ] },\n         $minDistance: 1000,\n         $maxDistance: 5000\n       }\n    }\n}\n)\n</code></pre></li>\n<li><code>$nearSphere （GeoJSON点，2dsphere索引）</code><pre><code># 查询坐标[-73.9667, 40.78]最少0.0004弧度距离的记录\ndb.legacyPlaces.find(\n{ location : { $nearSphere : [ -73.9667, 40.78 ], $minDistance: 0.0004 } }\n)\n</code></pre></li>\n<li><code>$geoWithin:{$geometry:...}</code> </li>\n<li><code>$geoWithin:{$centerSphere:...}</code><pre><code># 查询坐标[-88, 30]，半径10/3963.2范围内的\ndb.places.find( {\nloc: { $geoWithin: { $centerSphere: [ [ -88, 30 ], 10/3963.2 ] } }\n} )\n</code></pre></li>\n<li><code>$geoIntersects</code>  <pre><code># 查询多边形内坐标[ 0, 0 ], [ 3, 6 ], [ 6, 1 ], [ 0, 0 ]相交的记录\ndb.places.find(\n{\n  loc: {\n    $geoIntersects: {\n       $geometry: {\n          type: &quot;Polygon&quot; ,\n          coordinates: [\n            [ [ 0, 0 ], [ 3, 6 ], [ 6, 1 ], [ 0, 0 ] ]\n          ]\n       }\n    }\n  }\n}\n)\n</code></pre>索引的操作</li>\n</ul>\n<hr>\n<pre><code># 查询索引\ndb.collection.getIndexes();\n\n# 创建索引 1:正序；-1:倒序\ndb.collection.createIndex({indexValue:1/-1);\n\n# 指定索引别名\ndb.collection.createIndex({indexValue},{name:});\n\n# 指定唯一索引\ndb.collection.createIndex({indexValue},{unique:true/false});\n\n# 指定索引是否稀疏\n#   例如，我们为一个collection的x字段指定了索引，\n#   但这个collection中可以# 插入如{y:1,z:1}这种不存在x字段的数据，\n#   如果索引为不稀疏的，MongoDB 依然会为这个数据创建索引，\n#   如果在创建索引时指定为稀疏索引，那么就可以避免这件事情发生了\ndb.collection.createIndex({indexValue},{sparse:true/false});\n\n# 删除某个索引\ndb.collection.dropIndex({indexValue:1});\n\n# 删除集合下所有索引\ndb.collection.dropIndexes();\n</code></pre>"},{"title":"MySQL5.7 主从复制配置","date":"2017-07-16T05:06:09.000Z","_content":"\n一、主从复制原理\n----------------\n>`MySQL` 主从复制是一个`异步`的`复制`过程，`主库`发送`更新事件`到`从库`，`从库`读取`更新记录`，并`执行`更新`记录`，使得`从库`的内容与主库`保持一致`。每一个`主从复制`的连接，都有`三个线程`。拥有`多个从库`的`主库`为`每一个连接`到`主库`的`从库`创建一个 `Binarylog` 输出线程，`每一个从库`都有它自己的 `I/O` 线程和 `SQL` 线程。\n![][8]\n**步骤**：\n1.`主库`会将`所有`的`更新`记录保存到 `Binarylog` 文件。\n2.每当有`从库`连接到`主库`的时候，`主库`都会创建一个 `log dump` 线程发送 `Binarylog` 文件到`从库`。\n3.在`从库`里，当复制开始的时候，`从库`就会创建`两个线程`进行处理，一个 `I/O` 线程，一个 `SQL` 线程。\n4. `I/O` 线程去请求`主库`的  `Binarylog`文件，并将得到的 `Binarylog` 文件写到 `Relaylog` 文件中。\n5. `SQL` 线程会读取 `Relaylog` 文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致。\n\n二、工具\n----------------\n - VMware版本：12.0.0 \n - CentOS版本：7.0\n - MySQL版本: 5.7.18\n - Master 服务器：192.168.78.128\n - Slave 服务器：192.168.78.130\n\n三、准备工作\n----------------\n1.安装 MySQL5.7 [详见此处][1]\n2.如果`从服务器`是`克隆`的`主服务器`，则修改 `auto.cnf` 文件中 `server-uuid` 值，不然后面`主从复制`会报 `1593` 错误。修改完记得重启MySQL\n![][2]\n3.关闭`主、从`服务器`防火墙`：\n```\n$ firewall-cmd --state      ##查看防火墙状态\nrunning                     ##防火墙开启\n\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running                 ##防火墙关闭\n```\n\n4.修改`主从配置`文件(my.cnf)\n\n192.168.78.128(master)：\n\n```\nbind-address=192.168.78.128         #当前服务器地址\nlog_bin=mysql-bin  \nserver_id=128\n```\n\n192.168.78.130(slave)：\n\n```\nbind-address=192.168.78.130         #当前服务器地址\nlog_bin=mysql-bin  \nserver_id=130\n```\n![][3]\n\n重启主从 `MySQL`:\n\n```\n$ systemctl restart mysqld\n```\n\n`注`: `server_id` 必须唯一\n\n\n5.`master` 上创建一个测试数据库\n\n```\n$ create database test;\n$ use test;\n$ create table test(id int(11), value varchar(20));\n$ insert into test values(1, 'aa'),(2, 'bb'),(3, 'cc');\n```\n\n四、步骤\n----------------\n1.`master`创建授权用户：\n192.168.78.128(master)：\n\n```\n##创建 test 用户，指定该用户只能在master 192.168.78.130 上\n##使用 MyPass1! 密码登录\nmysql> create user 'test'@'192.168.78.130' identified by 'MyPass1!';\n\n##为 test 用户赋予 REPLICATION SLAVE 权限。\nmysql> grant replication slave on *.* to 'test'@'192.168.78.130';\n\n##查看用户\nmysql> select user,host from mysql.user;\n\n##查看 master 状态\nmysql> show master status;\n```\n![][4]\n`注`：\n这里的 `mysql-bin.000001`和 `Position` 配置 `slave` 的时候需要用到\n\n2.将 `master` 中现有的数据信息`导出`：\n\n```\n$ mysqldump -u root -p --all-databases --master-data > all.sql\n```\n\n3.将 `all.sql` 发送到 `slave` 服务器 `tmp` 目录下:\n\n```\n$ scp all.sql root@192.168.78.130:/tmp\n```\n\n4.`slave` 导入 `master` 数据，使 `master-slave` 数据`保持一致`：\n\n192.168.78.130(slave)：\n\n```\n$ mysql -uroot -p < all.sql\n```\n\n5.使 `slave` 与 `master` 建立连接，从而同步\n\n```\nmysql> change master to\n    -> master_host='192.168.78.128',\n    -> master_user='test',\n    -> master_password='MyPass1!',\n    -> master_log_file='mysql-bin.000001',\n    -> master_log_pos=1244;\n    \nmysql> start slave;\n\nmysql> show slave status \\G\n```\n![][5]\n\n`注`：\n\n - `master_log_file` 和 `master_log_pos`值为`主库`上面执行`show master status`得到\n - 如果 `Slave_IO_Running` 和 `Slave_SQL_Running` 都为 `Yes`，说明配置`成功`。 如果\n - 其中一项不为 `Yes`，查看 `Last_IO_Errno` 错误码和`错误信息`，或者查看 `MySQL` 日志信息并查找对应问题。\n\n五、主从配置检验\n----------------\n\n`master` 插入一条数据，`slave`查看是否成功\n192.168.78.128(master)：\n![][6]\n\n192.168.78.130(slave)：\n![][7]\n\n六、思考\n----------------\n主从复制同步`延迟`如何解决？\n\n  [1]: http://upupjie.com/2017/04/10/CentOS-7-%E5%AE%89%E8%A3%85-LNMP-%E7%8E%AF%E5%A2%83%EF%BC%88PHP7-MySQL5-7-Nginx1-10%EF%BC%89/\n  [2]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/2.png\n  [4]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/3.png\n  [5]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/5.png\n  [6]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/6.png\n  [7]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/7.png\n  [8]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg00.png","source":"_posts/MySQL5-7-主从复制配置.md","raw":"---\ntitle: MySQL5.7 主从复制配置\ndate: 2017-07-16 13:06:09\ntags:\ncategories:\n- MySQL\n---\n\n一、主从复制原理\n----------------\n>`MySQL` 主从复制是一个`异步`的`复制`过程，`主库`发送`更新事件`到`从库`，`从库`读取`更新记录`，并`执行`更新`记录`，使得`从库`的内容与主库`保持一致`。每一个`主从复制`的连接，都有`三个线程`。拥有`多个从库`的`主库`为`每一个连接`到`主库`的`从库`创建一个 `Binarylog` 输出线程，`每一个从库`都有它自己的 `I/O` 线程和 `SQL` 线程。\n![][8]\n**步骤**：\n1.`主库`会将`所有`的`更新`记录保存到 `Binarylog` 文件。\n2.每当有`从库`连接到`主库`的时候，`主库`都会创建一个 `log dump` 线程发送 `Binarylog` 文件到`从库`。\n3.在`从库`里，当复制开始的时候，`从库`就会创建`两个线程`进行处理，一个 `I/O` 线程，一个 `SQL` 线程。\n4. `I/O` 线程去请求`主库`的  `Binarylog`文件，并将得到的 `Binarylog` 文件写到 `Relaylog` 文件中。\n5. `SQL` 线程会读取 `Relaylog` 文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致。\n\n二、工具\n----------------\n - VMware版本：12.0.0 \n - CentOS版本：7.0\n - MySQL版本: 5.7.18\n - Master 服务器：192.168.78.128\n - Slave 服务器：192.168.78.130\n\n三、准备工作\n----------------\n1.安装 MySQL5.7 [详见此处][1]\n2.如果`从服务器`是`克隆`的`主服务器`，则修改 `auto.cnf` 文件中 `server-uuid` 值，不然后面`主从复制`会报 `1593` 错误。修改完记得重启MySQL\n![][2]\n3.关闭`主、从`服务器`防火墙`：\n```\n$ firewall-cmd --state      ##查看防火墙状态\nrunning                     ##防火墙开启\n\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running                 ##防火墙关闭\n```\n\n4.修改`主从配置`文件(my.cnf)\n\n192.168.78.128(master)：\n\n```\nbind-address=192.168.78.128         #当前服务器地址\nlog_bin=mysql-bin  \nserver_id=128\n```\n\n192.168.78.130(slave)：\n\n```\nbind-address=192.168.78.130         #当前服务器地址\nlog_bin=mysql-bin  \nserver_id=130\n```\n![][3]\n\n重启主从 `MySQL`:\n\n```\n$ systemctl restart mysqld\n```\n\n`注`: `server_id` 必须唯一\n\n\n5.`master` 上创建一个测试数据库\n\n```\n$ create database test;\n$ use test;\n$ create table test(id int(11), value varchar(20));\n$ insert into test values(1, 'aa'),(2, 'bb'),(3, 'cc');\n```\n\n四、步骤\n----------------\n1.`master`创建授权用户：\n192.168.78.128(master)：\n\n```\n##创建 test 用户，指定该用户只能在master 192.168.78.130 上\n##使用 MyPass1! 密码登录\nmysql> create user 'test'@'192.168.78.130' identified by 'MyPass1!';\n\n##为 test 用户赋予 REPLICATION SLAVE 权限。\nmysql> grant replication slave on *.* to 'test'@'192.168.78.130';\n\n##查看用户\nmysql> select user,host from mysql.user;\n\n##查看 master 状态\nmysql> show master status;\n```\n![][4]\n`注`：\n这里的 `mysql-bin.000001`和 `Position` 配置 `slave` 的时候需要用到\n\n2.将 `master` 中现有的数据信息`导出`：\n\n```\n$ mysqldump -u root -p --all-databases --master-data > all.sql\n```\n\n3.将 `all.sql` 发送到 `slave` 服务器 `tmp` 目录下:\n\n```\n$ scp all.sql root@192.168.78.130:/tmp\n```\n\n4.`slave` 导入 `master` 数据，使 `master-slave` 数据`保持一致`：\n\n192.168.78.130(slave)：\n\n```\n$ mysql -uroot -p < all.sql\n```\n\n5.使 `slave` 与 `master` 建立连接，从而同步\n\n```\nmysql> change master to\n    -> master_host='192.168.78.128',\n    -> master_user='test',\n    -> master_password='MyPass1!',\n    -> master_log_file='mysql-bin.000001',\n    -> master_log_pos=1244;\n    \nmysql> start slave;\n\nmysql> show slave status \\G\n```\n![][5]\n\n`注`：\n\n - `master_log_file` 和 `master_log_pos`值为`主库`上面执行`show master status`得到\n - 如果 `Slave_IO_Running` 和 `Slave_SQL_Running` 都为 `Yes`，说明配置`成功`。 如果\n - 其中一项不为 `Yes`，查看 `Last_IO_Errno` 错误码和`错误信息`，或者查看 `MySQL` 日志信息并查找对应问题。\n\n五、主从配置检验\n----------------\n\n`master` 插入一条数据，`slave`查看是否成功\n192.168.78.128(master)：\n![][6]\n\n192.168.78.130(slave)：\n![][7]\n\n六、思考\n----------------\n主从复制同步`延迟`如何解决？\n\n  [1]: http://upupjie.com/2017/04/10/CentOS-7-%E5%AE%89%E8%A3%85-LNMP-%E7%8E%AF%E5%A2%83%EF%BC%88PHP7-MySQL5-7-Nginx1-10%EF%BC%89/\n  [2]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/2.png\n  [4]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/3.png\n  [5]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/5.png\n  [6]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/6.png\n  [7]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg/7.png\n  [8]: http://olln3wpar.bkt.clouddn.com/Mysql/jpg00.png","slug":"MySQL5-7-主从复制配置","published":1,"updated":"2018-01-03T02:37:16.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyequ000su8w64kr7675v","content":"<h2 id=\"一、主从复制原理\"><a href=\"#一、主从复制原理\" class=\"headerlink\" title=\"一、主从复制原理\"></a>一、主从复制原理</h2><blockquote>\n<p><code>MySQL</code> 主从复制是一个<code>异步</code>的<code>复制</code>过程，<code>主库</code>发送<code>更新事件</code>到<code>从库</code>，<code>从库</code>读取<code>更新记录</code>，并<code>执行</code>更新<code>记录</code>，使得<code>从库</code>的内容与主库<code>保持一致</code>。每一个<code>主从复制</code>的连接，都有<code>三个线程</code>。拥有<code>多个从库</code>的<code>主库</code>为<code>每一个连接</code>到<code>主库</code>的<code>从库</code>创建一个 <code>Binarylog</code> 输出线程，<code>每一个从库</code>都有它自己的 <code>I/O</code> 线程和 <code>SQL</code> 线程。<br><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg00.png\" alt=\"\"><br><strong>步骤</strong>：<br>1.<code>主库</code>会将<code>所有</code>的<code>更新</code>记录保存到 <code>Binarylog</code> 文件。<br>2.每当有<code>从库</code>连接到<code>主库</code>的时候，<code>主库</code>都会创建一个 <code>log dump</code> 线程发送 <code>Binarylog</code> 文件到<code>从库</code>。<br>3.在<code>从库</code>里，当复制开始的时候，<code>从库</code>就会创建<code>两个线程</code>进行处理，一个 <code>I/O</code> 线程，一个 <code>SQL</code> 线程。</p>\n<ol>\n<li><code>I/O</code> 线程去请求<code>主库</code>的  <code>Binarylog</code>文件，并将得到的 <code>Binarylog</code> 文件写到 <code>Relaylog</code> 文件中。</li>\n<li><code>SQL</code> 线程会读取 <code>Relaylog</code> 文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致。</li>\n</ol>\n</blockquote>\n<h2 id=\"二、工具\"><a href=\"#二、工具\" class=\"headerlink\" title=\"二、工具\"></a>二、工具</h2><ul>\n<li>VMware版本：12.0.0 </li>\n<li>CentOS版本：7.0</li>\n<li>MySQL版本: 5.7.18</li>\n<li>Master 服务器：192.168.78.128</li>\n<li>Slave 服务器：192.168.78.130</li>\n</ul>\n<h2 id=\"三、准备工作\"><a href=\"#三、准备工作\" class=\"headerlink\" title=\"三、准备工作\"></a>三、准备工作</h2><p>1.安装 MySQL5.7 <a href=\"http://upupjie.com/2017/04/10/CentOS-7-%E5%AE%89%E8%A3%85-LNMP-%E7%8E%AF%E5%A2%83%EF%BC%88PHP7-MySQL5-7-Nginx1-10%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">详见此处</a><br>2.如果<code>从服务器</code>是<code>克隆</code>的<code>主服务器</code>，则修改 <code>auto.cnf</code> 文件中 <code>server-uuid</code> 值，不然后面<code>主从复制</code>会报 <code>1593</code> 错误。修改完记得重启MySQL<br><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/1.png\" alt=\"\"><br>3.关闭<code>主、从</code>服务器<code>防火墙</code>：</p>\n<pre><code>$ firewall-cmd --state      ##查看防火墙状态\nrunning                     ##防火墙开启\n\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running                 ##防火墙关闭\n</code></pre><p>4.修改<code>主从配置</code>文件(my.cnf)</p>\n<p>192.168.78.128(master)：</p>\n<pre><code>bind-address=192.168.78.128         #当前服务器地址\nlog_bin=mysql-bin  \nserver_id=128\n</code></pre><p>192.168.78.130(slave)：</p>\n<pre><code>bind-address=192.168.78.130         #当前服务器地址\nlog_bin=mysql-bin  \nserver_id=130\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/2.png\" alt=\"\"></p>\n<p>重启主从 <code>MySQL</code>:</p>\n<pre><code>$ systemctl restart mysqld\n</code></pre><p><code>注</code>: <code>server_id</code> 必须唯一</p>\n<p>5.<code>master</code> 上创建一个测试数据库</p>\n<pre><code>$ create database test;\n$ use test;\n$ create table test(id int(11), value varchar(20));\n$ insert into test values(1, &#39;aa&#39;),(2, &#39;bb&#39;),(3, &#39;cc&#39;);\n</code></pre><h2 id=\"四、步骤\"><a href=\"#四、步骤\" class=\"headerlink\" title=\"四、步骤\"></a>四、步骤</h2><p>1.<code>master</code>创建授权用户：<br>192.168.78.128(master)：</p>\n<pre><code>##创建 test 用户，指定该用户只能在master 192.168.78.130 上\n##使用 MyPass1! 密码登录\nmysql&gt; create user &#39;test&#39;@&#39;192.168.78.130&#39; identified by &#39;MyPass1!&#39;;\n\n##为 test 用户赋予 REPLICATION SLAVE 权限。\nmysql&gt; grant replication slave on *.* to &#39;test&#39;@&#39;192.168.78.130&#39;;\n\n##查看用户\nmysql&gt; select user,host from mysql.user;\n\n##查看 master 状态\nmysql&gt; show master status;\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/3.png\" alt=\"\"><br><code>注</code>：<br>这里的 <code>mysql-bin.000001</code>和 <code>Position</code> 配置 <code>slave</code> 的时候需要用到</p>\n<p>2.将 <code>master</code> 中现有的数据信息<code>导出</code>：</p>\n<pre><code>$ mysqldump -u root -p --all-databases --master-data &gt; all.sql\n</code></pre><p>3.将 <code>all.sql</code> 发送到 <code>slave</code> 服务器 <code>tmp</code> 目录下:</p>\n<pre><code>$ scp all.sql root@192.168.78.130:/tmp\n</code></pre><p>4.<code>slave</code> 导入 <code>master</code> 数据，使 <code>master-slave</code> 数据<code>保持一致</code>：</p>\n<p>192.168.78.130(slave)：</p>\n<pre><code>$ mysql -uroot -p &lt; all.sql\n</code></pre><p>5.使 <code>slave</code> 与 <code>master</code> 建立连接，从而同步</p>\n<pre><code>mysql&gt; change master to\n    -&gt; master_host=&#39;192.168.78.128&#39;,\n    -&gt; master_user=&#39;test&#39;,\n    -&gt; master_password=&#39;MyPass1!&#39;,\n    -&gt; master_log_file=&#39;mysql-bin.000001&#39;,\n    -&gt; master_log_pos=1244;\n\nmysql&gt; start slave;\n\nmysql&gt; show slave status \\G\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/5.png\" alt=\"\"></p>\n<p><code>注</code>：</p>\n<ul>\n<li><code>master_log_file</code> 和 <code>master_log_pos</code>值为<code>主库</code>上面执行<code>show master status</code>得到</li>\n<li>如果 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 都为 <code>Yes</code>，说明配置<code>成功</code>。 如果</li>\n<li>其中一项不为 <code>Yes</code>，查看 <code>Last_IO_Errno</code> 错误码和<code>错误信息</code>，或者查看 <code>MySQL</code> 日志信息并查找对应问题。</li>\n</ul>\n<h2 id=\"五、主从配置检验\"><a href=\"#五、主从配置检验\" class=\"headerlink\" title=\"五、主从配置检验\"></a>五、主从配置检验</h2><p><code>master</code> 插入一条数据，<code>slave</code>查看是否成功<br>192.168.78.128(master)：<br><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/6.png\" alt=\"\"></p>\n<p>192.168.78.130(slave)：<br><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/7.png\" alt=\"\"></p>\n<h2 id=\"六、思考\"><a href=\"#六、思考\" class=\"headerlink\" title=\"六、思考\"></a>六、思考</h2><p>主从复制同步<code>延迟</code>如何解决？</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、主从复制原理\"><a href=\"#一、主从复制原理\" class=\"headerlink\" title=\"一、主从复制原理\"></a>一、主从复制原理</h2><blockquote>\n<p><code>MySQL</code> 主从复制是一个<code>异步</code>的<code>复制</code>过程，<code>主库</code>发送<code>更新事件</code>到<code>从库</code>，<code>从库</code>读取<code>更新记录</code>，并<code>执行</code>更新<code>记录</code>，使得<code>从库</code>的内容与主库<code>保持一致</code>。每一个<code>主从复制</code>的连接，都有<code>三个线程</code>。拥有<code>多个从库</code>的<code>主库</code>为<code>每一个连接</code>到<code>主库</code>的<code>从库</code>创建一个 <code>Binarylog</code> 输出线程，<code>每一个从库</code>都有它自己的 <code>I/O</code> 线程和 <code>SQL</code> 线程。<br><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg00.png\" alt=\"\"><br><strong>步骤</strong>：<br>1.<code>主库</code>会将<code>所有</code>的<code>更新</code>记录保存到 <code>Binarylog</code> 文件。<br>2.每当有<code>从库</code>连接到<code>主库</code>的时候，<code>主库</code>都会创建一个 <code>log dump</code> 线程发送 <code>Binarylog</code> 文件到<code>从库</code>。<br>3.在<code>从库</code>里，当复制开始的时候，<code>从库</code>就会创建<code>两个线程</code>进行处理，一个 <code>I/O</code> 线程，一个 <code>SQL</code> 线程。</p>\n<ol>\n<li><code>I/O</code> 线程去请求<code>主库</code>的  <code>Binarylog</code>文件，并将得到的 <code>Binarylog</code> 文件写到 <code>Relaylog</code> 文件中。</li>\n<li><code>SQL</code> 线程会读取 <code>Relaylog</code> 文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致。</li>\n</ol>\n</blockquote>\n<h2 id=\"二、工具\"><a href=\"#二、工具\" class=\"headerlink\" title=\"二、工具\"></a>二、工具</h2><ul>\n<li>VMware版本：12.0.0 </li>\n<li>CentOS版本：7.0</li>\n<li>MySQL版本: 5.7.18</li>\n<li>Master 服务器：192.168.78.128</li>\n<li>Slave 服务器：192.168.78.130</li>\n</ul>\n<h2 id=\"三、准备工作\"><a href=\"#三、准备工作\" class=\"headerlink\" title=\"三、准备工作\"></a>三、准备工作</h2><p>1.安装 MySQL5.7 <a href=\"http://upupjie.com/2017/04/10/CentOS-7-%E5%AE%89%E8%A3%85-LNMP-%E7%8E%AF%E5%A2%83%EF%BC%88PHP7-MySQL5-7-Nginx1-10%EF%BC%89/\" target=\"_blank\" rel=\"noopener\">详见此处</a><br>2.如果<code>从服务器</code>是<code>克隆</code>的<code>主服务器</code>，则修改 <code>auto.cnf</code> 文件中 <code>server-uuid</code> 值，不然后面<code>主从复制</code>会报 <code>1593</code> 错误。修改完记得重启MySQL<br><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/1.png\" alt=\"\"><br>3.关闭<code>主、从</code>服务器<code>防火墙</code>：</p>\n<pre><code>$ firewall-cmd --state      ##查看防火墙状态\nrunning                     ##防火墙开启\n\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running                 ##防火墙关闭\n</code></pre><p>4.修改<code>主从配置</code>文件(my.cnf)</p>\n<p>192.168.78.128(master)：</p>\n<pre><code>bind-address=192.168.78.128         #当前服务器地址\nlog_bin=mysql-bin  \nserver_id=128\n</code></pre><p>192.168.78.130(slave)：</p>\n<pre><code>bind-address=192.168.78.130         #当前服务器地址\nlog_bin=mysql-bin  \nserver_id=130\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/2.png\" alt=\"\"></p>\n<p>重启主从 <code>MySQL</code>:</p>\n<pre><code>$ systemctl restart mysqld\n</code></pre><p><code>注</code>: <code>server_id</code> 必须唯一</p>\n<p>5.<code>master</code> 上创建一个测试数据库</p>\n<pre><code>$ create database test;\n$ use test;\n$ create table test(id int(11), value varchar(20));\n$ insert into test values(1, &#39;aa&#39;),(2, &#39;bb&#39;),(3, &#39;cc&#39;);\n</code></pre><h2 id=\"四、步骤\"><a href=\"#四、步骤\" class=\"headerlink\" title=\"四、步骤\"></a>四、步骤</h2><p>1.<code>master</code>创建授权用户：<br>192.168.78.128(master)：</p>\n<pre><code>##创建 test 用户，指定该用户只能在master 192.168.78.130 上\n##使用 MyPass1! 密码登录\nmysql&gt; create user &#39;test&#39;@&#39;192.168.78.130&#39; identified by &#39;MyPass1!&#39;;\n\n##为 test 用户赋予 REPLICATION SLAVE 权限。\nmysql&gt; grant replication slave on *.* to &#39;test&#39;@&#39;192.168.78.130&#39;;\n\n##查看用户\nmysql&gt; select user,host from mysql.user;\n\n##查看 master 状态\nmysql&gt; show master status;\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/3.png\" alt=\"\"><br><code>注</code>：<br>这里的 <code>mysql-bin.000001</code>和 <code>Position</code> 配置 <code>slave</code> 的时候需要用到</p>\n<p>2.将 <code>master</code> 中现有的数据信息<code>导出</code>：</p>\n<pre><code>$ mysqldump -u root -p --all-databases --master-data &gt; all.sql\n</code></pre><p>3.将 <code>all.sql</code> 发送到 <code>slave</code> 服务器 <code>tmp</code> 目录下:</p>\n<pre><code>$ scp all.sql root@192.168.78.130:/tmp\n</code></pre><p>4.<code>slave</code> 导入 <code>master</code> 数据，使 <code>master-slave</code> 数据<code>保持一致</code>：</p>\n<p>192.168.78.130(slave)：</p>\n<pre><code>$ mysql -uroot -p &lt; all.sql\n</code></pre><p>5.使 <code>slave</code> 与 <code>master</code> 建立连接，从而同步</p>\n<pre><code>mysql&gt; change master to\n    -&gt; master_host=&#39;192.168.78.128&#39;,\n    -&gt; master_user=&#39;test&#39;,\n    -&gt; master_password=&#39;MyPass1!&#39;,\n    -&gt; master_log_file=&#39;mysql-bin.000001&#39;,\n    -&gt; master_log_pos=1244;\n\nmysql&gt; start slave;\n\nmysql&gt; show slave status \\G\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/5.png\" alt=\"\"></p>\n<p><code>注</code>：</p>\n<ul>\n<li><code>master_log_file</code> 和 <code>master_log_pos</code>值为<code>主库</code>上面执行<code>show master status</code>得到</li>\n<li>如果 <code>Slave_IO_Running</code> 和 <code>Slave_SQL_Running</code> 都为 <code>Yes</code>，说明配置<code>成功</code>。 如果</li>\n<li>其中一项不为 <code>Yes</code>，查看 <code>Last_IO_Errno</code> 错误码和<code>错误信息</code>，或者查看 <code>MySQL</code> 日志信息并查找对应问题。</li>\n</ul>\n<h2 id=\"五、主从配置检验\"><a href=\"#五、主从配置检验\" class=\"headerlink\" title=\"五、主从配置检验\"></a>五、主从配置检验</h2><p><code>master</code> 插入一条数据，<code>slave</code>查看是否成功<br>192.168.78.128(master)：<br><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/6.png\" alt=\"\"></p>\n<p>192.168.78.130(slave)：<br><img src=\"http://olln3wpar.bkt.clouddn.com/Mysql/jpg/7.png\" alt=\"\"></p>\n<h2 id=\"六、思考\"><a href=\"#六、思考\" class=\"headerlink\" title=\"六、思考\"></a>六、思考</h2><p>主从复制同步<code>延迟</code>如何解决？</p>\n"},{"title":"PHP多维数组去重","date":"2017-02-14T22:25:18.000Z","_content":"```\n/**\n * 多维数组去重\n * @param array \n * @return array\n */\nfunction super_unique($array)\n{\n    $result = array_map(\"unserialize\", array_unique(array_map(\"serialize\", $array)));\n\n    foreach ($result as $key => $value)\n    {\n        if ( is_array($value) ) {\n            $result[$key] = super_unique($value);\n        }\n    }\n\n    return $result;\n}\n```","source":"_posts/PHP多维数组去重.md","raw":"---\ntitle: PHP多维数组去重\ndate: 2017-02-15 06:25:18\ncategories:\n- PHP\n---\n```\n/**\n * 多维数组去重\n * @param array \n * @return array\n */\nfunction super_unique($array)\n{\n    $result = array_map(\"unserialize\", array_unique(array_map(\"serialize\", $array)));\n\n    foreach ($result as $key => $value)\n    {\n        if ( is_array($value) ) {\n            $result[$key] = super_unique($value);\n        }\n    }\n\n    return $result;\n}\n```","slug":"PHP多维数组去重","published":1,"updated":"2018-01-04T01:37:41.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeqx000uu8w64fsa29p6","content":"<pre><code>/**\n * 多维数组去重\n * @param array \n * @return array\n */\nfunction super_unique($array)\n{\n    $result = array_map(&quot;unserialize&quot;, array_unique(array_map(&quot;serialize&quot;, $array)));\n\n    foreach ($result as $key =&gt; $value)\n    {\n        if ( is_array($value) ) {\n            $result[$key] = super_unique($value);\n        }\n    }\n\n    return $result;\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>/**\n * 多维数组去重\n * @param array \n * @return array\n */\nfunction super_unique($array)\n{\n    $result = array_map(&quot;unserialize&quot;, array_unique(array_map(&quot;serialize&quot;, $array)));\n\n    foreach ($result as $key =&gt; $value)\n    {\n        if ( is_array($value) ) {\n            $result[$key] = super_unique($value);\n        }\n    }\n\n    return $result;\n}\n</code></pre>"},{"title":"PHP中的自动加载","date":"2018-01-02T08:59:31.000Z","_content":"\n\n所谓的`自动加载`意思就是我们在 `new` 一个 `class` 的时候必须先 `include` 或者 `require` 的类文件，如果没有 `include` 或者 `require`，则会报错。那这样我们就必须在文件头部写上许多 `include` 或 `require` 文件，非常麻烦，\n为了使得没有 `include` 或者 `require` 类的时候也正常 `new` 一个类，所以有了 `自动加载` 的概念，也就是说 `new` 一个类之前不用事先包含类文件也可以正常 `new`，这样我们的文件头部就不用包含许多 `include(require)`。\n如何才能`自动加载`呢？ PHP 5 版本更新了`自动加载`需要的一个`魔术方法`—— `__autoload($class_name)`\n`注`： PHP 7.2.0版本已经废弃。\n\n一、自动加载的原理以及 __autoload 的使用\n----------------------------------------------\n\n`自动加载`的原理，就是在我们 `new` 一个 `class` 的时候，PHP系统如果找不到你这个类，就会去自动调用本文件中的 `__autoload($class_name)` 方法，我们 `new` 的这个 `class_name` 就成为这个方法的参数。所以我们就可以在这个方法中根据我们需要 `new class_name` 的各种判断和划分就去 `require` 对应的路径类文件，从而实现自动加载。\n\n我们先一步步来，看下__autoload()的自动调用，看个例子： \n\n```\n// index.php\n$db = new DB();\n```\n如果我们不手动导入 `DB` 类，程序可能会报错，说找不到这个类：\n```\nFatal error: Class 'DB' not found in D:\\www\\test\\index.php on line 2\n```\n那么，我们现在加入 `__autoload()` 这个方法再看看：\n```\n// index.php\n$db = new DB();\n\nfunction __autoload($className)\n{\n    echo $className;\n    exit();\n}\n```\n根据上面`自动加载`机制的描述，会输出：`DB`， 也就是我们需要 `new` 的类的类名。所以，这个时候我们就可以在 `__autoload()` 方法里，根据需要去加载类库文件了。\n\n```\n// index.php\n$db = new DB();\n\nfunction __autoload($className)\n{\n    require $className . '.php';\n}\n```\n\n```\n// DB.php\nclass DB\n{\n    public function __construct()\n    {\n        echo 'Hello DB';\n    }\n}\n```\n这样子我们就很轻松的将我们需要 `new` 的 `class` 全部加载进来，我们就可以轻松的 new N个 class，比如：\n```\nfunction __autoload($className)\n{\n    require $className . '.php';\n}\n\n$db = new DB();\n$info = new Info();\n$gender = new Gender();\n$name = new Name();\n\n// 静态方法直接调用的\nHeight::test();\n```\n\n二、spl_autoload_register 的使用\n----------------------------------------------\n小的项目，用 `__autoload()` 就能实现基本的自动加载了。但是如果一个项目过大，或者需要不同的`自动加载`来加载不同路径的文件，这个时候 `__autoload` 就不能满足了，原因是一个项目中仅能有一个这样的 `__autoload()` 函数，因为 PHP 不允许函数重名，也就是说你不能声明2个 `__autoload()` 函数文件，否则会报致命错误，所以 `spl_autoload_register()` 函数诞生了，并且取而代之它。它执行效率更高，更灵活\n`spl_autoload_register` 可以很好地处理需要多个加载器的情况，这种情况下 `spl_autoload_register` 会按顺序依次调用之前注册过的加载器。作为对比， `__autoload` 因为是一个函数，所以只能被定义`一次`。\n\n当我们去 `new` 一个找不到的 `class` 时，PHP 就会去自动调用 `sql_autoload_resister` 注册的函数，这个函数通过它的参数传进去：\n\n`sql_autoload_resister($param)` 这个参数可以有多种形式：\n```\nsql_autoload_resister('loadFunction'); // 函数名\nsql_autoload_resister(array('loadObject', 'loadFunction')); // 类和静态方法\nsql_autoload_resister('loadObject::loadFunction'); // 类和方法的静态调用\n\n// PHP 5.3 之后，也可以像这样支持匿名函数了。\nspl_autoload_register(function($className){\n    if (is_file('./lib/' . $className . '.php')) {\n        require './lib/' . $className . '.php';\n    }\n});\n```\n```\n// index.php\nfunction loader($className)\n{\n    require $className . '.php';\n}\nspl_autoload_register('loader'); // 将 loader 函数注册到自动加载队列中。\n$db = new DB(); // 找不到 DB 类，就会自动去调用刚注册的 loader 函数了\n```\n上面就是实现了`自动加载`的方式，我们同样也可以用类加载的方式调用，但是必须是 `static` 方法：\n```\nclass autoLoading\n{\n    //必须是静态方法，不然报错\n    public static function loader($className)\n    {   \n        require $className . '.php';\n    }\n}\n\nspl_autoload_register(array('autoLoading', 'loader')); \nspl_autoload_register('autoLoading::loader');// 静态方式调用\n$db = new DB(); //会自动找到\n```\n`注`：如你同时使用 `spl_autoload_register` 和 `__autoload` ， `__autoload` 会失效！！！\n\n三、多个 spl_autoload_register 的使用\n----------------------------------------------\n`spl_autoload_register` 是可以多次重复使用的，这一点正是解决了 `__autoload` 的短板，那么如果一个页面有多个，执行顺序是按照注册的顺序，一个一个往下找，如果找到了就停止。\n\n我们来看下这个例子， `DB.php` 就在本目录下，`Info.php` 在 `/lib/` 目录下。\n```\n// Info.php\nclass Info\n{\n    public function __construct()\n    {\n        echo 'Hello Info';\n    }\n}\n```\n```\n// index.php\n\nfunction loader1($className)\n{\n    echo 1;\n    if (is_file($className . '.php')) {\n        require $className . '.php';\n    }\n}\nfunction loader2($className)\n{\n    echo 2;\n    if (is_file('./app/' . $className . '.php')) {\n        require './app/' . $className . '.php';\n    }\n}\nfunction __autoload($className)\n{\n    echo 3;\n    if (is_file('./lib/' . $className . '.php')) {\n        require './lib/' . $className . '.php';\n    }\n}\n//注册了3个\nspl_autoload_register('loader1');\nspl_autoload_register('loader2');\nspl_autoload_register('__autoload'); \n$db = new DB(); // DB 就在本目录下\n$info = new Info(); // Info 在/lib/Info.php\n```\n我们注册了3个自动加载函数。执行结果是啥呢？\n```\n1Hello DB\n123Hello Info\n```\n我们分析下：\n\n 1. `new DB` 的时候，就按照注册顺序，先去找 `loader1()` 函数了，发现找到了，就停止了，所以输出 `1 Hello Word`\n 2. `new Info` 的时候，先是安装注册顺序，先找 `loader1()`，所以输出了 1，发现没找到，就去 `loader2()` 里面去找，所以输出了 2，还是没这个文件，就去 `__autoload()` 函数里找，所以，先输出了 3，再输出 `Hello Info`\n\n`注`: `spl_autoload_register` 使用时， `__autoload `会无效，有时候，我们希望它继续有效，就可以也将它注册进来，就可以继续使用。\n我们可以打印 `spl_autoload_functions()` 函数，来显示一共注册了多少个自动加载：\n```\nvar_dump(spl_autoload_functions());\n//数组的形式输出\narray (size=3)\n  0 => string 'load1' (length=5)\n  1 => string 'load2' (length=5)\n  2 => string '__autoload' (length=10)\n```\n\n四、spl_autoload_register 自动加载与 namespace 命名空间的使用\n----------------------------------------------\n`自动加载`现在是PHP现代框架的基石，基本都是 `spl_autoload_register` 来实现自动加载。`namespace` 也是使用比较多的。所以 `spl_autoload_register` + `namespace` 就成为了一个主流。根据 `PSR-0` 的规范，`namespace` 命名已经非常规范化，所以用 `namespace` 就能找到详细的路径，从而找到类文件。\n\n```\nnamespace AutoLoading;\n\n// AutoLoading\\loading.php\nclass loading \n{\n    public static function autoload($className)\n    {\n        // 根据 PSR-O 的第4点 把 \\ 转换层（目录风格符） DIRECTORY_SEPARATOR , \n        // 便于兼容Linux文件找。Windows 下（/ 和 \\）是通用的\n        // 由于 namspace 很规格，所以直接很快就能找到\n       $fileName = str_replace('\\\\', DIRECTORY_SEPARATOR,  DIR . '\\\\'. $className) . '.php';\n       if (is_file($fileName)) {\n            require $fileName;\n       } else {\n            echo $fileName . ' is not exist'; die;\n       }\n    }\n}\n```\n上面就是一个自动加载的核心思想方法。下面我们就来 `spl_autoload_register` 来注册这个函数：\n```\n// index.php\n\n// 定义当前的目录绝对路径\ndefine('DIR', dirname(__FILE__));\n\n// 加载这个文件\nrequire DIR . '/loading.php';\n\n// 采用“命名空间”的方式注册。php 5.3 加入的\n// 也必须是 static 静态方法调用，然后就像加载 namespace 的方式调用，注意：不能使用 use\nspl_autoload_register(\"\\\\AutoLoading\\\\loading::autoload\"); \n\n// 调用三个 namespace 类\n//定位到 Lib 目录下的 Name.php \nLib\\Name::test();\n\n// 定位到App目录下 Android 目录下的 Name.php\nApp\\Android\\Name::test();\n\n// 定位到App目录下 Ios 目录下的 Name.php\nApp\\Ios\\Name::test();\n```\n由于我们是采用PSR-O方式来定义namespace的命名的，所以很好的定位到这个文件的在哪个目录下了。\n```\n// APP\\Android\\Name\n\nnamespace App\\Android;\n\nclass Name\n{\n    public function __construct()\n    {\n        echo __NAMESPACE__ . \"<br>\";\n    }\n    \n    public static function test()\n    {\n        echo  __NAMESPACE__ . ' static function test <br>';\n    }\n}\n```\n所以就会很容易找到文件，并输出：\n```\nLib static function test \nApp\\Android static function test \nApp\\Ios static function test \n```\n\n五、同命名空间下的相互调用\n----------------------------------------------\n在平时我们使用命令空间时，有时候可能是在同一个命名空间下的2个类文件在相互调用。这个时候就要注意，在自动调用的问题了。\n\n比如在 `Lib\\Factory.php` 中调用 `Lib\\Db\\MySQL.php`。怎么调用呢？以下是错误的示范：\n```\nnew Lib\\Db\\MySQL();  \n// 报错，提示说 D:\\www\\test\\module\\Lib\\Lib\\Db\\MySQL.php is not exist\n```\n这种方式是在 `Lib\\` 命名空间的基础上来加载的。所以会加载`2`个 `Lib`。这种方式相当于`相对路径`在`加载`。\n正确的做法是，如果是在同一个命名空间下平级的2个文件。可以直接调用，不用命名空间。\n```\nnew MySQL(); // 直接这样就可以了。\nnew Db\\MySQL(); // 如果有个Db文件夹，就这样。\n```\n还有一种方法就是使用 `use` 。使用 `use` 就可以带上 `Lib` 了。`use` 使用的是`绝对路径`。\n如果在 `Lib\\Db\\MySQL.php` 中调用 `Lib\\Register.php` 呢？\n```\nuse Lib\\Register;\nRegister::getInstance();\n```\n因为现在已经在 `Lib\\Db` 命名空间里了，如果你不用 `use` ，而是使用 `Lib\\Register::getInstance()` 或者使用 `Register::getInstance()` 的话。将是在 `Lib\\Db` 这个空间下进行`相对路径`的加载，是错误的。","source":"_posts/PHP中的自动加载.md","raw":"---\ntitle: PHP中的自动加载\ndate: 2018-01-02 16:59:31\ntags:\ncategories:\n- PHP\n---\n\n\n所谓的`自动加载`意思就是我们在 `new` 一个 `class` 的时候必须先 `include` 或者 `require` 的类文件，如果没有 `include` 或者 `require`，则会报错。那这样我们就必须在文件头部写上许多 `include` 或 `require` 文件，非常麻烦，\n为了使得没有 `include` 或者 `require` 类的时候也正常 `new` 一个类，所以有了 `自动加载` 的概念，也就是说 `new` 一个类之前不用事先包含类文件也可以正常 `new`，这样我们的文件头部就不用包含许多 `include(require)`。\n如何才能`自动加载`呢？ PHP 5 版本更新了`自动加载`需要的一个`魔术方法`—— `__autoload($class_name)`\n`注`： PHP 7.2.0版本已经废弃。\n\n一、自动加载的原理以及 __autoload 的使用\n----------------------------------------------\n\n`自动加载`的原理，就是在我们 `new` 一个 `class` 的时候，PHP系统如果找不到你这个类，就会去自动调用本文件中的 `__autoload($class_name)` 方法，我们 `new` 的这个 `class_name` 就成为这个方法的参数。所以我们就可以在这个方法中根据我们需要 `new class_name` 的各种判断和划分就去 `require` 对应的路径类文件，从而实现自动加载。\n\n我们先一步步来，看下__autoload()的自动调用，看个例子： \n\n```\n// index.php\n$db = new DB();\n```\n如果我们不手动导入 `DB` 类，程序可能会报错，说找不到这个类：\n```\nFatal error: Class 'DB' not found in D:\\www\\test\\index.php on line 2\n```\n那么，我们现在加入 `__autoload()` 这个方法再看看：\n```\n// index.php\n$db = new DB();\n\nfunction __autoload($className)\n{\n    echo $className;\n    exit();\n}\n```\n根据上面`自动加载`机制的描述，会输出：`DB`， 也就是我们需要 `new` 的类的类名。所以，这个时候我们就可以在 `__autoload()` 方法里，根据需要去加载类库文件了。\n\n```\n// index.php\n$db = new DB();\n\nfunction __autoload($className)\n{\n    require $className . '.php';\n}\n```\n\n```\n// DB.php\nclass DB\n{\n    public function __construct()\n    {\n        echo 'Hello DB';\n    }\n}\n```\n这样子我们就很轻松的将我们需要 `new` 的 `class` 全部加载进来，我们就可以轻松的 new N个 class，比如：\n```\nfunction __autoload($className)\n{\n    require $className . '.php';\n}\n\n$db = new DB();\n$info = new Info();\n$gender = new Gender();\n$name = new Name();\n\n// 静态方法直接调用的\nHeight::test();\n```\n\n二、spl_autoload_register 的使用\n----------------------------------------------\n小的项目，用 `__autoload()` 就能实现基本的自动加载了。但是如果一个项目过大，或者需要不同的`自动加载`来加载不同路径的文件，这个时候 `__autoload` 就不能满足了，原因是一个项目中仅能有一个这样的 `__autoload()` 函数，因为 PHP 不允许函数重名，也就是说你不能声明2个 `__autoload()` 函数文件，否则会报致命错误，所以 `spl_autoload_register()` 函数诞生了，并且取而代之它。它执行效率更高，更灵活\n`spl_autoload_register` 可以很好地处理需要多个加载器的情况，这种情况下 `spl_autoload_register` 会按顺序依次调用之前注册过的加载器。作为对比， `__autoload` 因为是一个函数，所以只能被定义`一次`。\n\n当我们去 `new` 一个找不到的 `class` 时，PHP 就会去自动调用 `sql_autoload_resister` 注册的函数，这个函数通过它的参数传进去：\n\n`sql_autoload_resister($param)` 这个参数可以有多种形式：\n```\nsql_autoload_resister('loadFunction'); // 函数名\nsql_autoload_resister(array('loadObject', 'loadFunction')); // 类和静态方法\nsql_autoload_resister('loadObject::loadFunction'); // 类和方法的静态调用\n\n// PHP 5.3 之后，也可以像这样支持匿名函数了。\nspl_autoload_register(function($className){\n    if (is_file('./lib/' . $className . '.php')) {\n        require './lib/' . $className . '.php';\n    }\n});\n```\n```\n// index.php\nfunction loader($className)\n{\n    require $className . '.php';\n}\nspl_autoload_register('loader'); // 将 loader 函数注册到自动加载队列中。\n$db = new DB(); // 找不到 DB 类，就会自动去调用刚注册的 loader 函数了\n```\n上面就是实现了`自动加载`的方式，我们同样也可以用类加载的方式调用，但是必须是 `static` 方法：\n```\nclass autoLoading\n{\n    //必须是静态方法，不然报错\n    public static function loader($className)\n    {   \n        require $className . '.php';\n    }\n}\n\nspl_autoload_register(array('autoLoading', 'loader')); \nspl_autoload_register('autoLoading::loader');// 静态方式调用\n$db = new DB(); //会自动找到\n```\n`注`：如你同时使用 `spl_autoload_register` 和 `__autoload` ， `__autoload` 会失效！！！\n\n三、多个 spl_autoload_register 的使用\n----------------------------------------------\n`spl_autoload_register` 是可以多次重复使用的，这一点正是解决了 `__autoload` 的短板，那么如果一个页面有多个，执行顺序是按照注册的顺序，一个一个往下找，如果找到了就停止。\n\n我们来看下这个例子， `DB.php` 就在本目录下，`Info.php` 在 `/lib/` 目录下。\n```\n// Info.php\nclass Info\n{\n    public function __construct()\n    {\n        echo 'Hello Info';\n    }\n}\n```\n```\n// index.php\n\nfunction loader1($className)\n{\n    echo 1;\n    if (is_file($className . '.php')) {\n        require $className . '.php';\n    }\n}\nfunction loader2($className)\n{\n    echo 2;\n    if (is_file('./app/' . $className . '.php')) {\n        require './app/' . $className . '.php';\n    }\n}\nfunction __autoload($className)\n{\n    echo 3;\n    if (is_file('./lib/' . $className . '.php')) {\n        require './lib/' . $className . '.php';\n    }\n}\n//注册了3个\nspl_autoload_register('loader1');\nspl_autoload_register('loader2');\nspl_autoload_register('__autoload'); \n$db = new DB(); // DB 就在本目录下\n$info = new Info(); // Info 在/lib/Info.php\n```\n我们注册了3个自动加载函数。执行结果是啥呢？\n```\n1Hello DB\n123Hello Info\n```\n我们分析下：\n\n 1. `new DB` 的时候，就按照注册顺序，先去找 `loader1()` 函数了，发现找到了，就停止了，所以输出 `1 Hello Word`\n 2. `new Info` 的时候，先是安装注册顺序，先找 `loader1()`，所以输出了 1，发现没找到，就去 `loader2()` 里面去找，所以输出了 2，还是没这个文件，就去 `__autoload()` 函数里找，所以，先输出了 3，再输出 `Hello Info`\n\n`注`: `spl_autoload_register` 使用时， `__autoload `会无效，有时候，我们希望它继续有效，就可以也将它注册进来，就可以继续使用。\n我们可以打印 `spl_autoload_functions()` 函数，来显示一共注册了多少个自动加载：\n```\nvar_dump(spl_autoload_functions());\n//数组的形式输出\narray (size=3)\n  0 => string 'load1' (length=5)\n  1 => string 'load2' (length=5)\n  2 => string '__autoload' (length=10)\n```\n\n四、spl_autoload_register 自动加载与 namespace 命名空间的使用\n----------------------------------------------\n`自动加载`现在是PHP现代框架的基石，基本都是 `spl_autoload_register` 来实现自动加载。`namespace` 也是使用比较多的。所以 `spl_autoload_register` + `namespace` 就成为了一个主流。根据 `PSR-0` 的规范，`namespace` 命名已经非常规范化，所以用 `namespace` 就能找到详细的路径，从而找到类文件。\n\n```\nnamespace AutoLoading;\n\n// AutoLoading\\loading.php\nclass loading \n{\n    public static function autoload($className)\n    {\n        // 根据 PSR-O 的第4点 把 \\ 转换层（目录风格符） DIRECTORY_SEPARATOR , \n        // 便于兼容Linux文件找。Windows 下（/ 和 \\）是通用的\n        // 由于 namspace 很规格，所以直接很快就能找到\n       $fileName = str_replace('\\\\', DIRECTORY_SEPARATOR,  DIR . '\\\\'. $className) . '.php';\n       if (is_file($fileName)) {\n            require $fileName;\n       } else {\n            echo $fileName . ' is not exist'; die;\n       }\n    }\n}\n```\n上面就是一个自动加载的核心思想方法。下面我们就来 `spl_autoload_register` 来注册这个函数：\n```\n// index.php\n\n// 定义当前的目录绝对路径\ndefine('DIR', dirname(__FILE__));\n\n// 加载这个文件\nrequire DIR . '/loading.php';\n\n// 采用“命名空间”的方式注册。php 5.3 加入的\n// 也必须是 static 静态方法调用，然后就像加载 namespace 的方式调用，注意：不能使用 use\nspl_autoload_register(\"\\\\AutoLoading\\\\loading::autoload\"); \n\n// 调用三个 namespace 类\n//定位到 Lib 目录下的 Name.php \nLib\\Name::test();\n\n// 定位到App目录下 Android 目录下的 Name.php\nApp\\Android\\Name::test();\n\n// 定位到App目录下 Ios 目录下的 Name.php\nApp\\Ios\\Name::test();\n```\n由于我们是采用PSR-O方式来定义namespace的命名的，所以很好的定位到这个文件的在哪个目录下了。\n```\n// APP\\Android\\Name\n\nnamespace App\\Android;\n\nclass Name\n{\n    public function __construct()\n    {\n        echo __NAMESPACE__ . \"<br>\";\n    }\n    \n    public static function test()\n    {\n        echo  __NAMESPACE__ . ' static function test <br>';\n    }\n}\n```\n所以就会很容易找到文件，并输出：\n```\nLib static function test \nApp\\Android static function test \nApp\\Ios static function test \n```\n\n五、同命名空间下的相互调用\n----------------------------------------------\n在平时我们使用命令空间时，有时候可能是在同一个命名空间下的2个类文件在相互调用。这个时候就要注意，在自动调用的问题了。\n\n比如在 `Lib\\Factory.php` 中调用 `Lib\\Db\\MySQL.php`。怎么调用呢？以下是错误的示范：\n```\nnew Lib\\Db\\MySQL();  \n// 报错，提示说 D:\\www\\test\\module\\Lib\\Lib\\Db\\MySQL.php is not exist\n```\n这种方式是在 `Lib\\` 命名空间的基础上来加载的。所以会加载`2`个 `Lib`。这种方式相当于`相对路径`在`加载`。\n正确的做法是，如果是在同一个命名空间下平级的2个文件。可以直接调用，不用命名空间。\n```\nnew MySQL(); // 直接这样就可以了。\nnew Db\\MySQL(); // 如果有个Db文件夹，就这样。\n```\n还有一种方法就是使用 `use` 。使用 `use` 就可以带上 `Lib` 了。`use` 使用的是`绝对路径`。\n如果在 `Lib\\Db\\MySQL.php` 中调用 `Lib\\Register.php` 呢？\n```\nuse Lib\\Register;\nRegister::getInstance();\n```\n因为现在已经在 `Lib\\Db` 命名空间里了，如果你不用 `use` ，而是使用 `Lib\\Register::getInstance()` 或者使用 `Register::getInstance()` 的话。将是在 `Lib\\Db` 这个空间下进行`相对路径`的加载，是错误的。","slug":"PHP中的自动加载","published":1,"updated":"2018-01-03T02:05:08.002Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyer1000zu8w6i3tpbno2","content":"<p>所谓的<code>自动加载</code>意思就是我们在 <code>new</code> 一个 <code>class</code> 的时候必须先 <code>include</code> 或者 <code>require</code> 的类文件，如果没有 <code>include</code> 或者 <code>require</code>，则会报错。那这样我们就必须在文件头部写上许多 <code>include</code> 或 <code>require</code> 文件，非常麻烦，<br>为了使得没有 <code>include</code> 或者 <code>require</code> 类的时候也正常 <code>new</code> 一个类，所以有了 <code>自动加载</code> 的概念，也就是说 <code>new</code> 一个类之前不用事先包含类文件也可以正常 <code>new</code>，这样我们的文件头部就不用包含许多 <code>include(require)</code>。<br>如何才能<code>自动加载</code>呢？ PHP 5 版本更新了<code>自动加载</code>需要的一个<code>魔术方法</code>—— <code>__autoload($class_name)</code><br><code>注</code>： PHP 7.2.0版本已经废弃。</p>\n<h2 id=\"一、自动加载的原理以及-autoload-的使用\"><a href=\"#一、自动加载的原理以及-autoload-的使用\" class=\"headerlink\" title=\"一、自动加载的原理以及 __autoload 的使用\"></a>一、自动加载的原理以及 __autoload 的使用</h2><p><code>自动加载</code>的原理，就是在我们 <code>new</code> 一个 <code>class</code> 的时候，PHP系统如果找不到你这个类，就会去自动调用本文件中的 <code>__autoload($class_name)</code> 方法，我们 <code>new</code> 的这个 <code>class_name</code> 就成为这个方法的参数。所以我们就可以在这个方法中根据我们需要 <code>new class_name</code> 的各种判断和划分就去 <code>require</code> 对应的路径类文件，从而实现自动加载。</p>\n<p>我们先一步步来，看下__autoload()的自动调用，看个例子： </p>\n<pre><code>// index.php\n$db = new DB();\n</code></pre><p>如果我们不手动导入 <code>DB</code> 类，程序可能会报错，说找不到这个类：</p>\n<pre><code>Fatal error: Class &#39;DB&#39; not found in D:\\www\\test\\index.php on line 2\n</code></pre><p>那么，我们现在加入 <code>__autoload()</code> 这个方法再看看：</p>\n<pre><code>// index.php\n$db = new DB();\n\nfunction __autoload($className)\n{\n    echo $className;\n    exit();\n}\n</code></pre><p>根据上面<code>自动加载</code>机制的描述，会输出：<code>DB</code>， 也就是我们需要 <code>new</code> 的类的类名。所以，这个时候我们就可以在 <code>__autoload()</code> 方法里，根据需要去加载类库文件了。</p>\n<pre><code>// index.php\n$db = new DB();\n\nfunction __autoload($className)\n{\n    require $className . &#39;.php&#39;;\n}\n</code></pre><pre><code>// DB.php\nclass DB\n{\n    public function __construct()\n    {\n        echo &#39;Hello DB&#39;;\n    }\n}\n</code></pre><p>这样子我们就很轻松的将我们需要 <code>new</code> 的 <code>class</code> 全部加载进来，我们就可以轻松的 new N个 class，比如：</p>\n<pre><code>function __autoload($className)\n{\n    require $className . &#39;.php&#39;;\n}\n\n$db = new DB();\n$info = new Info();\n$gender = new Gender();\n$name = new Name();\n\n// 静态方法直接调用的\nHeight::test();\n</code></pre><h2 id=\"二、spl-autoload-register-的使用\"><a href=\"#二、spl-autoload-register-的使用\" class=\"headerlink\" title=\"二、spl_autoload_register 的使用\"></a>二、spl_autoload_register 的使用</h2><p>小的项目，用 <code>__autoload()</code> 就能实现基本的自动加载了。但是如果一个项目过大，或者需要不同的<code>自动加载</code>来加载不同路径的文件，这个时候 <code>__autoload</code> 就不能满足了，原因是一个项目中仅能有一个这样的 <code>__autoload()</code> 函数，因为 PHP 不允许函数重名，也就是说你不能声明2个 <code>__autoload()</code> 函数文件，否则会报致命错误，所以 <code>spl_autoload_register()</code> 函数诞生了，并且取而代之它。它执行效率更高，更灵活<br><code>spl_autoload_register</code> 可以很好地处理需要多个加载器的情况，这种情况下 <code>spl_autoload_register</code> 会按顺序依次调用之前注册过的加载器。作为对比， <code>__autoload</code> 因为是一个函数，所以只能被定义<code>一次</code>。</p>\n<p>当我们去 <code>new</code> 一个找不到的 <code>class</code> 时，PHP 就会去自动调用 <code>sql_autoload_resister</code> 注册的函数，这个函数通过它的参数传进去：</p>\n<p><code>sql_autoload_resister($param)</code> 这个参数可以有多种形式：</p>\n<pre><code>sql_autoload_resister(&#39;loadFunction&#39;); // 函数名\nsql_autoload_resister(array(&#39;loadObject&#39;, &#39;loadFunction&#39;)); // 类和静态方法\nsql_autoload_resister(&#39;loadObject::loadFunction&#39;); // 类和方法的静态调用\n\n// PHP 5.3 之后，也可以像这样支持匿名函数了。\nspl_autoload_register(function($className){\n    if (is_file(&#39;./lib/&#39; . $className . &#39;.php&#39;)) {\n        require &#39;./lib/&#39; . $className . &#39;.php&#39;;\n    }\n});\n</code></pre><pre><code>// index.php\nfunction loader($className)\n{\n    require $className . &#39;.php&#39;;\n}\nspl_autoload_register(&#39;loader&#39;); // 将 loader 函数注册到自动加载队列中。\n$db = new DB(); // 找不到 DB 类，就会自动去调用刚注册的 loader 函数了\n</code></pre><p>上面就是实现了<code>自动加载</code>的方式，我们同样也可以用类加载的方式调用，但是必须是 <code>static</code> 方法：</p>\n<pre><code>class autoLoading\n{\n    //必须是静态方法，不然报错\n    public static function loader($className)\n    {   \n        require $className . &#39;.php&#39;;\n    }\n}\n\nspl_autoload_register(array(&#39;autoLoading&#39;, &#39;loader&#39;)); \nspl_autoload_register(&#39;autoLoading::loader&#39;);// 静态方式调用\n$db = new DB(); //会自动找到\n</code></pre><p><code>注</code>：如你同时使用 <code>spl_autoload_register</code> 和 <code>__autoload</code> ， <code>__autoload</code> 会失效！！！</p>\n<h2 id=\"三、多个-spl-autoload-register-的使用\"><a href=\"#三、多个-spl-autoload-register-的使用\" class=\"headerlink\" title=\"三、多个 spl_autoload_register 的使用\"></a>三、多个 spl_autoload_register 的使用</h2><p><code>spl_autoload_register</code> 是可以多次重复使用的，这一点正是解决了 <code>__autoload</code> 的短板，那么如果一个页面有多个，执行顺序是按照注册的顺序，一个一个往下找，如果找到了就停止。</p>\n<p>我们来看下这个例子， <code>DB.php</code> 就在本目录下，<code>Info.php</code> 在 <code>/lib/</code> 目录下。</p>\n<pre><code>// Info.php\nclass Info\n{\n    public function __construct()\n    {\n        echo &#39;Hello Info&#39;;\n    }\n}\n</code></pre><pre><code>// index.php\n\nfunction loader1($className)\n{\n    echo 1;\n    if (is_file($className . &#39;.php&#39;)) {\n        require $className . &#39;.php&#39;;\n    }\n}\nfunction loader2($className)\n{\n    echo 2;\n    if (is_file(&#39;./app/&#39; . $className . &#39;.php&#39;)) {\n        require &#39;./app/&#39; . $className . &#39;.php&#39;;\n    }\n}\nfunction __autoload($className)\n{\n    echo 3;\n    if (is_file(&#39;./lib/&#39; . $className . &#39;.php&#39;)) {\n        require &#39;./lib/&#39; . $className . &#39;.php&#39;;\n    }\n}\n//注册了3个\nspl_autoload_register(&#39;loader1&#39;);\nspl_autoload_register(&#39;loader2&#39;);\nspl_autoload_register(&#39;__autoload&#39;); \n$db = new DB(); // DB 就在本目录下\n$info = new Info(); // Info 在/lib/Info.php\n</code></pre><p>我们注册了3个自动加载函数。执行结果是啥呢？</p>\n<pre><code>1Hello DB\n123Hello Info\n</code></pre><p>我们分析下：</p>\n<ol>\n<li><code>new DB</code> 的时候，就按照注册顺序，先去找 <code>loader1()</code> 函数了，发现找到了，就停止了，所以输出 <code>1 Hello Word</code></li>\n<li><code>new Info</code> 的时候，先是安装注册顺序，先找 <code>loader1()</code>，所以输出了 1，发现没找到，就去 <code>loader2()</code> 里面去找，所以输出了 2，还是没这个文件，就去 <code>__autoload()</code> 函数里找，所以，先输出了 3，再输出 <code>Hello Info</code></li>\n</ol>\n<p><code>注</code>: <code>spl_autoload_register</code> 使用时， <code>__autoload</code>会无效，有时候，我们希望它继续有效，就可以也将它注册进来，就可以继续使用。<br>我们可以打印 <code>spl_autoload_functions()</code> 函数，来显示一共注册了多少个自动加载：</p>\n<pre><code>var_dump(spl_autoload_functions());\n//数组的形式输出\narray (size=3)\n  0 =&gt; string &#39;load1&#39; (length=5)\n  1 =&gt; string &#39;load2&#39; (length=5)\n  2 =&gt; string &#39;__autoload&#39; (length=10)\n</code></pre><h2 id=\"四、spl-autoload-register-自动加载与-namespace-命名空间的使用\"><a href=\"#四、spl-autoload-register-自动加载与-namespace-命名空间的使用\" class=\"headerlink\" title=\"四、spl_autoload_register 自动加载与 namespace 命名空间的使用\"></a>四、spl_autoload_register 自动加载与 namespace 命名空间的使用</h2><p><code>自动加载</code>现在是PHP现代框架的基石，基本都是 <code>spl_autoload_register</code> 来实现自动加载。<code>namespace</code> 也是使用比较多的。所以 <code>spl_autoload_register</code> + <code>namespace</code> 就成为了一个主流。根据 <code>PSR-0</code> 的规范，<code>namespace</code> 命名已经非常规范化，所以用 <code>namespace</code> 就能找到详细的路径，从而找到类文件。</p>\n<pre><code>namespace AutoLoading;\n\n// AutoLoading\\loading.php\nclass loading \n{\n    public static function autoload($className)\n    {\n        // 根据 PSR-O 的第4点 把 \\ 转换层（目录风格符） DIRECTORY_SEPARATOR , \n        // 便于兼容Linux文件找。Windows 下（/ 和 \\）是通用的\n        // 由于 namspace 很规格，所以直接很快就能找到\n       $fileName = str_replace(&#39;\\\\&#39;, DIRECTORY_SEPARATOR,  DIR . &#39;\\\\&#39;. $className) . &#39;.php&#39;;\n       if (is_file($fileName)) {\n            require $fileName;\n       } else {\n            echo $fileName . &#39; is not exist&#39;; die;\n       }\n    }\n}\n</code></pre><p>上面就是一个自动加载的核心思想方法。下面我们就来 <code>spl_autoload_register</code> 来注册这个函数：</p>\n<pre><code>// index.php\n\n// 定义当前的目录绝对路径\ndefine(&#39;DIR&#39;, dirname(__FILE__));\n\n// 加载这个文件\nrequire DIR . &#39;/loading.php&#39;;\n\n// 采用“命名空间”的方式注册。php 5.3 加入的\n// 也必须是 static 静态方法调用，然后就像加载 namespace 的方式调用，注意：不能使用 use\nspl_autoload_register(&quot;\\\\AutoLoading\\\\loading::autoload&quot;); \n\n// 调用三个 namespace 类\n//定位到 Lib 目录下的 Name.php \nLib\\Name::test();\n\n// 定位到App目录下 Android 目录下的 Name.php\nApp\\Android\\Name::test();\n\n// 定位到App目录下 Ios 目录下的 Name.php\nApp\\Ios\\Name::test();\n</code></pre><p>由于我们是采用PSR-O方式来定义namespace的命名的，所以很好的定位到这个文件的在哪个目录下了。</p>\n<pre><code>// APP\\Android\\Name\n\nnamespace App\\Android;\n\nclass Name\n{\n    public function __construct()\n    {\n        echo __NAMESPACE__ . &quot;&lt;br&gt;&quot;;\n    }\n\n    public static function test()\n    {\n        echo  __NAMESPACE__ . &#39; static function test &lt;br&gt;&#39;;\n    }\n}\n</code></pre><p>所以就会很容易找到文件，并输出：</p>\n<pre><code>Lib static function test \nApp\\Android static function test \nApp\\Ios static function test\n</code></pre><h2 id=\"五、同命名空间下的相互调用\"><a href=\"#五、同命名空间下的相互调用\" class=\"headerlink\" title=\"五、同命名空间下的相互调用\"></a>五、同命名空间下的相互调用</h2><p>在平时我们使用命令空间时，有时候可能是在同一个命名空间下的2个类文件在相互调用。这个时候就要注意，在自动调用的问题了。</p>\n<p>比如在 <code>Lib\\Factory.php</code> 中调用 <code>Lib\\Db\\MySQL.php</code>。怎么调用呢？以下是错误的示范：</p>\n<pre><code>new Lib\\Db\\MySQL();  \n// 报错，提示说 D:\\www\\test\\module\\Lib\\Lib\\Db\\MySQL.php is not exist\n</code></pre><p>这种方式是在 <code>Lib\\</code> 命名空间的基础上来加载的。所以会加载<code>2</code>个 <code>Lib</code>。这种方式相当于<code>相对路径</code>在<code>加载</code>。<br>正确的做法是，如果是在同一个命名空间下平级的2个文件。可以直接调用，不用命名空间。</p>\n<pre><code>new MySQL(); // 直接这样就可以了。\nnew Db\\MySQL(); // 如果有个Db文件夹，就这样。\n</code></pre><p>还有一种方法就是使用 <code>use</code> 。使用 <code>use</code> 就可以带上 <code>Lib</code> 了。<code>use</code> 使用的是<code>绝对路径</code>。<br>如果在 <code>Lib\\Db\\MySQL.php</code> 中调用 <code>Lib\\Register.php</code> 呢？</p>\n<pre><code>use Lib\\Register;\nRegister::getInstance();\n</code></pre><p>因为现在已经在 <code>Lib\\Db</code> 命名空间里了，如果你不用 <code>use</code> ，而是使用 <code>Lib\\Register::getInstance()</code> 或者使用 <code>Register::getInstance()</code> 的话。将是在 <code>Lib\\Db</code> 这个空间下进行<code>相对路径</code>的加载，是错误的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>所谓的<code>自动加载</code>意思就是我们在 <code>new</code> 一个 <code>class</code> 的时候必须先 <code>include</code> 或者 <code>require</code> 的类文件，如果没有 <code>include</code> 或者 <code>require</code>，则会报错。那这样我们就必须在文件头部写上许多 <code>include</code> 或 <code>require</code> 文件，非常麻烦，<br>为了使得没有 <code>include</code> 或者 <code>require</code> 类的时候也正常 <code>new</code> 一个类，所以有了 <code>自动加载</code> 的概念，也就是说 <code>new</code> 一个类之前不用事先包含类文件也可以正常 <code>new</code>，这样我们的文件头部就不用包含许多 <code>include(require)</code>。<br>如何才能<code>自动加载</code>呢？ PHP 5 版本更新了<code>自动加载</code>需要的一个<code>魔术方法</code>—— <code>__autoload($class_name)</code><br><code>注</code>： PHP 7.2.0版本已经废弃。</p>\n<h2 id=\"一、自动加载的原理以及-autoload-的使用\"><a href=\"#一、自动加载的原理以及-autoload-的使用\" class=\"headerlink\" title=\"一、自动加载的原理以及 __autoload 的使用\"></a>一、自动加载的原理以及 __autoload 的使用</h2><p><code>自动加载</code>的原理，就是在我们 <code>new</code> 一个 <code>class</code> 的时候，PHP系统如果找不到你这个类，就会去自动调用本文件中的 <code>__autoload($class_name)</code> 方法，我们 <code>new</code> 的这个 <code>class_name</code> 就成为这个方法的参数。所以我们就可以在这个方法中根据我们需要 <code>new class_name</code> 的各种判断和划分就去 <code>require</code> 对应的路径类文件，从而实现自动加载。</p>\n<p>我们先一步步来，看下__autoload()的自动调用，看个例子： </p>\n<pre><code>// index.php\n$db = new DB();\n</code></pre><p>如果我们不手动导入 <code>DB</code> 类，程序可能会报错，说找不到这个类：</p>\n<pre><code>Fatal error: Class &#39;DB&#39; not found in D:\\www\\test\\index.php on line 2\n</code></pre><p>那么，我们现在加入 <code>__autoload()</code> 这个方法再看看：</p>\n<pre><code>// index.php\n$db = new DB();\n\nfunction __autoload($className)\n{\n    echo $className;\n    exit();\n}\n</code></pre><p>根据上面<code>自动加载</code>机制的描述，会输出：<code>DB</code>， 也就是我们需要 <code>new</code> 的类的类名。所以，这个时候我们就可以在 <code>__autoload()</code> 方法里，根据需要去加载类库文件了。</p>\n<pre><code>// index.php\n$db = new DB();\n\nfunction __autoload($className)\n{\n    require $className . &#39;.php&#39;;\n}\n</code></pre><pre><code>// DB.php\nclass DB\n{\n    public function __construct()\n    {\n        echo &#39;Hello DB&#39;;\n    }\n}\n</code></pre><p>这样子我们就很轻松的将我们需要 <code>new</code> 的 <code>class</code> 全部加载进来，我们就可以轻松的 new N个 class，比如：</p>\n<pre><code>function __autoload($className)\n{\n    require $className . &#39;.php&#39;;\n}\n\n$db = new DB();\n$info = new Info();\n$gender = new Gender();\n$name = new Name();\n\n// 静态方法直接调用的\nHeight::test();\n</code></pre><h2 id=\"二、spl-autoload-register-的使用\"><a href=\"#二、spl-autoload-register-的使用\" class=\"headerlink\" title=\"二、spl_autoload_register 的使用\"></a>二、spl_autoload_register 的使用</h2><p>小的项目，用 <code>__autoload()</code> 就能实现基本的自动加载了。但是如果一个项目过大，或者需要不同的<code>自动加载</code>来加载不同路径的文件，这个时候 <code>__autoload</code> 就不能满足了，原因是一个项目中仅能有一个这样的 <code>__autoload()</code> 函数，因为 PHP 不允许函数重名，也就是说你不能声明2个 <code>__autoload()</code> 函数文件，否则会报致命错误，所以 <code>spl_autoload_register()</code> 函数诞生了，并且取而代之它。它执行效率更高，更灵活<br><code>spl_autoload_register</code> 可以很好地处理需要多个加载器的情况，这种情况下 <code>spl_autoload_register</code> 会按顺序依次调用之前注册过的加载器。作为对比， <code>__autoload</code> 因为是一个函数，所以只能被定义<code>一次</code>。</p>\n<p>当我们去 <code>new</code> 一个找不到的 <code>class</code> 时，PHP 就会去自动调用 <code>sql_autoload_resister</code> 注册的函数，这个函数通过它的参数传进去：</p>\n<p><code>sql_autoload_resister($param)</code> 这个参数可以有多种形式：</p>\n<pre><code>sql_autoload_resister(&#39;loadFunction&#39;); // 函数名\nsql_autoload_resister(array(&#39;loadObject&#39;, &#39;loadFunction&#39;)); // 类和静态方法\nsql_autoload_resister(&#39;loadObject::loadFunction&#39;); // 类和方法的静态调用\n\n// PHP 5.3 之后，也可以像这样支持匿名函数了。\nspl_autoload_register(function($className){\n    if (is_file(&#39;./lib/&#39; . $className . &#39;.php&#39;)) {\n        require &#39;./lib/&#39; . $className . &#39;.php&#39;;\n    }\n});\n</code></pre><pre><code>// index.php\nfunction loader($className)\n{\n    require $className . &#39;.php&#39;;\n}\nspl_autoload_register(&#39;loader&#39;); // 将 loader 函数注册到自动加载队列中。\n$db = new DB(); // 找不到 DB 类，就会自动去调用刚注册的 loader 函数了\n</code></pre><p>上面就是实现了<code>自动加载</code>的方式，我们同样也可以用类加载的方式调用，但是必须是 <code>static</code> 方法：</p>\n<pre><code>class autoLoading\n{\n    //必须是静态方法，不然报错\n    public static function loader($className)\n    {   \n        require $className . &#39;.php&#39;;\n    }\n}\n\nspl_autoload_register(array(&#39;autoLoading&#39;, &#39;loader&#39;)); \nspl_autoload_register(&#39;autoLoading::loader&#39;);// 静态方式调用\n$db = new DB(); //会自动找到\n</code></pre><p><code>注</code>：如你同时使用 <code>spl_autoload_register</code> 和 <code>__autoload</code> ， <code>__autoload</code> 会失效！！！</p>\n<h2 id=\"三、多个-spl-autoload-register-的使用\"><a href=\"#三、多个-spl-autoload-register-的使用\" class=\"headerlink\" title=\"三、多个 spl_autoload_register 的使用\"></a>三、多个 spl_autoload_register 的使用</h2><p><code>spl_autoload_register</code> 是可以多次重复使用的，这一点正是解决了 <code>__autoload</code> 的短板，那么如果一个页面有多个，执行顺序是按照注册的顺序，一个一个往下找，如果找到了就停止。</p>\n<p>我们来看下这个例子， <code>DB.php</code> 就在本目录下，<code>Info.php</code> 在 <code>/lib/</code> 目录下。</p>\n<pre><code>// Info.php\nclass Info\n{\n    public function __construct()\n    {\n        echo &#39;Hello Info&#39;;\n    }\n}\n</code></pre><pre><code>// index.php\n\nfunction loader1($className)\n{\n    echo 1;\n    if (is_file($className . &#39;.php&#39;)) {\n        require $className . &#39;.php&#39;;\n    }\n}\nfunction loader2($className)\n{\n    echo 2;\n    if (is_file(&#39;./app/&#39; . $className . &#39;.php&#39;)) {\n        require &#39;./app/&#39; . $className . &#39;.php&#39;;\n    }\n}\nfunction __autoload($className)\n{\n    echo 3;\n    if (is_file(&#39;./lib/&#39; . $className . &#39;.php&#39;)) {\n        require &#39;./lib/&#39; . $className . &#39;.php&#39;;\n    }\n}\n//注册了3个\nspl_autoload_register(&#39;loader1&#39;);\nspl_autoload_register(&#39;loader2&#39;);\nspl_autoload_register(&#39;__autoload&#39;); \n$db = new DB(); // DB 就在本目录下\n$info = new Info(); // Info 在/lib/Info.php\n</code></pre><p>我们注册了3个自动加载函数。执行结果是啥呢？</p>\n<pre><code>1Hello DB\n123Hello Info\n</code></pre><p>我们分析下：</p>\n<ol>\n<li><code>new DB</code> 的时候，就按照注册顺序，先去找 <code>loader1()</code> 函数了，发现找到了，就停止了，所以输出 <code>1 Hello Word</code></li>\n<li><code>new Info</code> 的时候，先是安装注册顺序，先找 <code>loader1()</code>，所以输出了 1，发现没找到，就去 <code>loader2()</code> 里面去找，所以输出了 2，还是没这个文件，就去 <code>__autoload()</code> 函数里找，所以，先输出了 3，再输出 <code>Hello Info</code></li>\n</ol>\n<p><code>注</code>: <code>spl_autoload_register</code> 使用时， <code>__autoload</code>会无效，有时候，我们希望它继续有效，就可以也将它注册进来，就可以继续使用。<br>我们可以打印 <code>spl_autoload_functions()</code> 函数，来显示一共注册了多少个自动加载：</p>\n<pre><code>var_dump(spl_autoload_functions());\n//数组的形式输出\narray (size=3)\n  0 =&gt; string &#39;load1&#39; (length=5)\n  1 =&gt; string &#39;load2&#39; (length=5)\n  2 =&gt; string &#39;__autoload&#39; (length=10)\n</code></pre><h2 id=\"四、spl-autoload-register-自动加载与-namespace-命名空间的使用\"><a href=\"#四、spl-autoload-register-自动加载与-namespace-命名空间的使用\" class=\"headerlink\" title=\"四、spl_autoload_register 自动加载与 namespace 命名空间的使用\"></a>四、spl_autoload_register 自动加载与 namespace 命名空间的使用</h2><p><code>自动加载</code>现在是PHP现代框架的基石，基本都是 <code>spl_autoload_register</code> 来实现自动加载。<code>namespace</code> 也是使用比较多的。所以 <code>spl_autoload_register</code> + <code>namespace</code> 就成为了一个主流。根据 <code>PSR-0</code> 的规范，<code>namespace</code> 命名已经非常规范化，所以用 <code>namespace</code> 就能找到详细的路径，从而找到类文件。</p>\n<pre><code>namespace AutoLoading;\n\n// AutoLoading\\loading.php\nclass loading \n{\n    public static function autoload($className)\n    {\n        // 根据 PSR-O 的第4点 把 \\ 转换层（目录风格符） DIRECTORY_SEPARATOR , \n        // 便于兼容Linux文件找。Windows 下（/ 和 \\）是通用的\n        // 由于 namspace 很规格，所以直接很快就能找到\n       $fileName = str_replace(&#39;\\\\&#39;, DIRECTORY_SEPARATOR,  DIR . &#39;\\\\&#39;. $className) . &#39;.php&#39;;\n       if (is_file($fileName)) {\n            require $fileName;\n       } else {\n            echo $fileName . &#39; is not exist&#39;; die;\n       }\n    }\n}\n</code></pre><p>上面就是一个自动加载的核心思想方法。下面我们就来 <code>spl_autoload_register</code> 来注册这个函数：</p>\n<pre><code>// index.php\n\n// 定义当前的目录绝对路径\ndefine(&#39;DIR&#39;, dirname(__FILE__));\n\n// 加载这个文件\nrequire DIR . &#39;/loading.php&#39;;\n\n// 采用“命名空间”的方式注册。php 5.3 加入的\n// 也必须是 static 静态方法调用，然后就像加载 namespace 的方式调用，注意：不能使用 use\nspl_autoload_register(&quot;\\\\AutoLoading\\\\loading::autoload&quot;); \n\n// 调用三个 namespace 类\n//定位到 Lib 目录下的 Name.php \nLib\\Name::test();\n\n// 定位到App目录下 Android 目录下的 Name.php\nApp\\Android\\Name::test();\n\n// 定位到App目录下 Ios 目录下的 Name.php\nApp\\Ios\\Name::test();\n</code></pre><p>由于我们是采用PSR-O方式来定义namespace的命名的，所以很好的定位到这个文件的在哪个目录下了。</p>\n<pre><code>// APP\\Android\\Name\n\nnamespace App\\Android;\n\nclass Name\n{\n    public function __construct()\n    {\n        echo __NAMESPACE__ . &quot;&lt;br&gt;&quot;;\n    }\n\n    public static function test()\n    {\n        echo  __NAMESPACE__ . &#39; static function test &lt;br&gt;&#39;;\n    }\n}\n</code></pre><p>所以就会很容易找到文件，并输出：</p>\n<pre><code>Lib static function test \nApp\\Android static function test \nApp\\Ios static function test\n</code></pre><h2 id=\"五、同命名空间下的相互调用\"><a href=\"#五、同命名空间下的相互调用\" class=\"headerlink\" title=\"五、同命名空间下的相互调用\"></a>五、同命名空间下的相互调用</h2><p>在平时我们使用命令空间时，有时候可能是在同一个命名空间下的2个类文件在相互调用。这个时候就要注意，在自动调用的问题了。</p>\n<p>比如在 <code>Lib\\Factory.php</code> 中调用 <code>Lib\\Db\\MySQL.php</code>。怎么调用呢？以下是错误的示范：</p>\n<pre><code>new Lib\\Db\\MySQL();  \n// 报错，提示说 D:\\www\\test\\module\\Lib\\Lib\\Db\\MySQL.php is not exist\n</code></pre><p>这种方式是在 <code>Lib\\</code> 命名空间的基础上来加载的。所以会加载<code>2</code>个 <code>Lib</code>。这种方式相当于<code>相对路径</code>在<code>加载</code>。<br>正确的做法是，如果是在同一个命名空间下平级的2个文件。可以直接调用，不用命名空间。</p>\n<pre><code>new MySQL(); // 直接这样就可以了。\nnew Db\\MySQL(); // 如果有个Db文件夹，就这样。\n</code></pre><p>还有一种方法就是使用 <code>use</code> 。使用 <code>use</code> 就可以带上 <code>Lib</code> 了。<code>use</code> 使用的是<code>绝对路径</code>。<br>如果在 <code>Lib\\Db\\MySQL.php</code> 中调用 <code>Lib\\Register.php</code> 呢？</p>\n<pre><code>use Lib\\Register;\nRegister::getInstance();\n</code></pre><p>因为现在已经在 <code>Lib\\Db</code> 命名空间里了，如果你不用 <code>use</code> ，而是使用 <code>Lib\\Register::getInstance()</code> 或者使用 <code>Register::getInstance()</code> 的话。将是在 <code>Lib\\Db</code> 这个空间下进行<code>相对路径</code>的加载，是错误的。</p>\n"},{"title":"PHP汉字转拼音","date":"2017-02-15T22:25:18.000Z","_content":"```\nclass Pinyin {\n    /**\n     * 拼音字符转换图\n     * @var array\n     */\n    private $data = array(\n        'a'=>-20319,'ai'=>-20317,'an'=>-20304,'ang'=>-20295,'ao'=>-20292,\n        'ba'=>-20283,'bai'=>-20265,'ban'=>-20257,'bang'=>-20242,'bao'=>-20230,'bei'=>-20051,'ben'=>-20036,'beng'=>-20032,'bi'=>-20026,'bian'=>-20002,'biao'=>-19990,'bie'=>-19986,'bin'=>-19982,'bing'=>-19976,'bo'=>-19805,'bu'=>-19784,\n        'ca'=>-19775,'cai'=>-19774,'can'=>-19763,'cang'=>-19756,'cao'=>-19751,'ce'=>-19746,'ceng'=>-19741,'cha'=>-19739,'chai'=>-19728,'chan'=>-19725,'chang'=>-19715,'chao'=>-19540,'che'=>-19531,'chen'=>-19525,'cheng'=>-19515,'chi'=>-19500,'chong'=>-19484,'chou'=>-19479,'chu'=>-19467,'chuai'=>-19289,'chuan'=>-19288,'chuang'=>-19281,'chui'=>-19275,'chun'=>-19270,'chuo'=>-19263,'ci'=>-19261,'cong'=>-19249,'cou'=>-19243,'cu'=>-19242,'cuan'=>-19238,'cui'=>-19235,'cun'=>-19227,'cuo'=>-19224,\n        'da'=>-19218,'dai'=>-19212,'dan'=>-19038,'dang'=>-19023,'dao'=>-19018,'de'=>-19006,'deng'=>-19003,'di'=>-18996,'dian'=>-18977,'diao'=>-18961,'die'=>-18952,'ding'=>-18783,'diu'=>-18774,'dong'=>-18773,'dou'=>-18763,'du'=>-18756,'duan'=>-18741,'dui'=>-18735,'dun'=>-18731,'duo'=>-18722,\n        'e'=>-18710,'en'=>-18697,'er'=>-18696,\n        'fa'=>-18526,'fan'=>-18518,'fang'=>-18501,'fei'=>-18490,'fen'=>-18478,'feng'=>-18463,'fo'=>-18448,'fou'=>-18447,'fu'=>-18446,\n        'ga'=>-18239,'gai'=>-18237,'gan'=>-18231,'gang'=>-18220,'gao'=>-18211,'ge'=>-18201,'gei'=>-18184,'gen'=>-18183,'geng'=>-18181,'gong'=>-18012,'gou'=>-17997,'gu'=>-17988,'gua'=>-17970,'guai'=>-17964,'guan'=>-17961,'guang'=>-17950,'gui'=>-17947,'gun'=>-17931,'guo'=>-17928,\n        'ha'=>-17922,'hai'=>-17759,'han'=>-17752,'hang'=>-17733,'hao'=>-17730,'he'=>-17721,'hei'=>-17703,'hen'=>-17701,'heng'=>-17697,'hong'=>-17692,'hou'=>-17683,'hu'=>-17676,'hua'=>-17496,'huai'=>-17487,'huan'=>-17482,'huang'=>-17468,'hui'=>-17454,'hun'=>-17433,'huo'=>-17427,\n        'ji'=>-17417,'jia'=>-17202,'jian'=>-17185,'jiang'=>-16983,'jiao'=>-16970,'jie'=>-16942,'jin'=>-16915,'jing'=>-16733,'jiong'=>-16708,'jiu'=>-16706,'ju'=>-16689,'juan'=>-16664,'jue'=>-16657,'jun'=>-16647,\n        'ka'=>-16474,'kai'=>-16470,'kan'=>-16465,'kang'=>-16459,'kao'=>-16452,'ke'=>-16448,'ken'=>-16433,'keng'=>-16429,'kong'=>-16427,'kou'=>-16423,'ku'=>-16419,'kua'=>-16412,'kuai'=>-16407,'kuan'=>-16403,'kuang'=>-16401,'kui'=>-16393,'kun'=>-16220,'kuo'=>-16216,\n        'la'=>-16212,'lai'=>-16205,'lan'=>-16202,'lang'=>-16187,'lao'=>-16180,'le'=>-16171,'lei'=>-16169,'leng'=>-16158,'li'=>-16155,'lia'=>-15959,'lian'=>-15958,'liang'=>-15944,'liao'=>-15933,'lie'=>-15920,'lin'=>-15915,'ling'=>-15903,'liu'=>-15889,'long'=>-15878,'lou'=>-15707,'lu'=>-15701,'lv'=>-15681,'luan'=>-15667,'lue'=>-15661,'lun'=>-15659,'luo'=>-15652,\n        'ma'=>-15640,'mai'=>-15631,'man'=>-15625,'mang'=>-15454,'mao'=>-15448,'me'=>-15436,'mei'=>-15435,'men'=>-15419,'meng'=>-15416,'mi'=>-15408,'mian'=>-15394,'miao'=>-15385,'mie'=>-15377,'min'=>-15375,'ming'=>-15369,'miu'=>-15363,'mo'=>-15362,'mou'=>-15183,'mu'=>-15180,\n        'na'=>-15165,'nai'=>-15158,'nan'=>-15153,'nang'=>-15150,'nao'=>-15149,'ne'=>-15144,'nei'=>-15143,'nen'=>-15141,'neng'=>-15140,'ni'=>-15139,'nian'=>-15128,'niang'=>-15121,'niao'=>-15119,'nie'=>-15117,'nin'=>-15110,'ning'=>-15109,'niu'=>-14941,'nong'=>-14937,'nu'=>-14933,'nv'=>-14930,'nuan'=>-14929,'nue'=>-14928,'nuo'=>-14926,\n        'o'=>-14922,'ou'=>-14921,\n        'pa'=>-14914,'pai'=>-14908,'pan'=>-14902,'pang'=>-14894,'pao'=>-14889,'pei'=>-14882,'pen'=>-14873,'peng'=>-14871,'pi'=>-14857,'pian'=>-14678,'piao'=>-14674,'pie'=>-14670,'pin'=>-14668,'ping'=>-14663,'po'=>-14654,'pu'=>-14645,\n        'qi'=>-14630,'qia'=>-14594,'qian'=>-14429,'qiang'=>-14407,'qiao'=>-14399,'qie'=>-14384,'qin'=>-14379,'qing'=>-14368,'qiong'=>-14355,'qiu'=>-14353,'qu'=>-14345,'quan'=>-14170,'que'=>-14159,'qun'=>-14151,\n        'ran'=>-14149,'rang'=>-14145,'rao'=>-14140,'re'=>-14137,'ren'=>-14135,'reng'=>-14125,'ri'=>-14123,'rong'=>-14122,'rou'=>-14112,'ru'=>-14109,'ruan'=>-14099,'rui'=>-14097,'run'=>-14094,'ruo'=>-14092,\n        'sa'=>-14090,'sai'=>-14087,'san'=>-14083,'sang'=>-13917,'sao'=>-13914,'se'=>-13910,'sen'=>-13907,'seng'=>-13906,'sha'=>-13905,'shai'=>-13896,'shan'=>-13894,'shang'=>-13878,'shao'=>-13870,'she'=>-13859,'shen'=>-13847,'sheng'=>-13831,'shi'=>-13658,'shou'=>-13611,'shu'=>-13601,'shua'=>-13406,'shuai'=>-13404,'shuan'=>-13400,'shuang'=>-13398,'shui'=>-13395,'shun'=>-13391,'shuo'=>-13387,'si'=>-13383,'song'=>-13367,'sou'=>-13359,'su'=>-13356,'suan'=>-13343,'sui'=>-13340,'sun'=>-13329,'suo'=>-13326,\n        'ta'=>-13318,'tai'=>-13147,'tan'=>-13138,'tang'=>-13120,'tao'=>-13107,'te'=>-13096,'teng'=>-13095,'ti'=>-13091,'tian'=>-13076,'tiao'=>-13068,'tie'=>-13063,'ting'=>-13060,'tong'=>-12888,'tou'=>-12875,'tu'=>-12871,'tuan'=>-12860,'tui'=>-12858,'tun'=>-12852,'tuo'=>-12849,\n        'wa'=>-12838,'wai'=>-12831,'wan'=>-12829,'wang'=>-12812,'wei'=>-12802,'wen'=>-12607,'weng'=>-12597,'wo'=>-12594,'wu'=>-12585,\n        'xi'=>-12556,'xia'=>-12359,'xian'=>-12346,'xiang'=>-12320,'xiao'=>-12300,'xie'=>-12120,'xin'=>-12099,'xing'=>-12089,'xiong'=>-12074,'xiu'=>-12067,'xu'=>-12058,'xuan'=>-12039,'xue'=>-11867,'xun'=>-11861,\n        'ya'=>-11847,'yan'=>-11831,'yang'=>-11798,'yao'=>-11781,'ye'=>-11604,'yi'=>-11589,'yin'=>-11536,'ying'=>-11358,'yo'=>-11340,'yong'=>-11339,'you'=>-11324,'yu'=>-11303,'yuan'=>-11097,'yue'=>-11077,'yun'=>-11067,\n        'za'=>-11055,'zai'=>-11052,'zan'=>-11045,'zang'=>-11041,'zao'=>-11038,'ze'=>-11024,'zei'=>-11020,'zen'=>-11019,'zeng'=>-11018,'zha'=>-11014,'zhai'=>-10838,'zhan'=>-10832,'zhang'=>-10815,'zhao'=>-10800,'zhe'=>-10790,'zhen'=>-10780,'zheng'=>-10764,'zhi'=>-10587,'zhong'=>-10544,'zhou'=>-10533,'zhu'=>-10519,'zhua'=>-10331,'zhuai'=>-10329,'zhuan'=>-10328,'zhuang'=>-10322,'zhui'=>-10315,'zhun'=>-10309,'zhuo'=>-10307,'zi'=>-10296,'zong'=>-10281,'zou'=>-10274,'zu'=>-10270,'zuan'=>-10262,'zui'=>-10260,'zun'=>-10256,'zuo'=>-10254\n    );\n\n    /**\n     * 将中文编码成拼音\n     * @param string $str 要转换为拼音的字符串\n     * @param string $RetFormat 返回格式 [first:每个字的首字母|all:全拼音|one:字符串字母]\n     * @return string\n     */\n    public function get_pinyin($str, $RetFormat='first')\n    {\n        $GBK = iconv('UTF-8', 'GBK', $str);\n        $UTF8 = iconv('GBK', 'UTF-8', $GBK);\n        if($UTF8 != $str) $GBK = $str;\n        $Buf = array();\n        for ($i=0, $iLoop=strlen($GBK); $i<$iLoop; $i++) {\n            $Chr = ord($GBK{$i});\n            if ($Chr>160) {\n                $Chr = ($Chr<<8) + ord($GBK{++$i}) - 65536;\n            }\n            if ('first' == $RetFormat || 'one' == $RetFormat) {\n                $Buf[] = substr($this->zh2py($Chr),0,1);\n            }else{\n                $Buf[] = $this->zh2py($Chr);\n            }\n\n        }\n        if ('first' === $RetFormat) {\n            return implode('', $Buf);\n        }elseif('one' == $RetFormat) {\n            return $Buf[0];\n        }else{\n            return implode(' ', $Buf);\n        }\n    }\n\n    /**\n     * 中文转换到拼音(每次处理一个字符)\n     * @param number $iWORD 待处理字符双字节\n     * @return string 拼音\n     */\n    private function zh2py($iWORD) \n    {\n        if($iWORD>0 && $iWORD<160 ) {\n            return chr($iWORD);\n        } elseif ($iWORD<-20319||$iWORD>-10247) {\n            return '';\n        } else {\n            foreach ($this->data as $py => $code) {\n                if($code > $iWORD) break;\n                $result = $py;\n            }\n            return $result;\n        }\n    }\n}\n\n$Pinyin = new Pinyin();\n//结果为拼音首字母\necho $Pinyin->get_pinyin('测试文字'), '<br/>'; \n//结果为全拼音\necho $Pinyin->get_pinyin('测试文字', 'all'), '<br/>'; \n//结果为第一个拼音\necho $Pinyin->get_pinyin('测试文字', 'one'), '<br/>'; \n```","source":"_posts/PHP汉字转拼音.md","raw":"---\ntitle: PHP汉字转拼音\ndate: 2017-02-16 06:25:18\ncategories:\n- PHP\n---\n```\nclass Pinyin {\n    /**\n     * 拼音字符转换图\n     * @var array\n     */\n    private $data = array(\n        'a'=>-20319,'ai'=>-20317,'an'=>-20304,'ang'=>-20295,'ao'=>-20292,\n        'ba'=>-20283,'bai'=>-20265,'ban'=>-20257,'bang'=>-20242,'bao'=>-20230,'bei'=>-20051,'ben'=>-20036,'beng'=>-20032,'bi'=>-20026,'bian'=>-20002,'biao'=>-19990,'bie'=>-19986,'bin'=>-19982,'bing'=>-19976,'bo'=>-19805,'bu'=>-19784,\n        'ca'=>-19775,'cai'=>-19774,'can'=>-19763,'cang'=>-19756,'cao'=>-19751,'ce'=>-19746,'ceng'=>-19741,'cha'=>-19739,'chai'=>-19728,'chan'=>-19725,'chang'=>-19715,'chao'=>-19540,'che'=>-19531,'chen'=>-19525,'cheng'=>-19515,'chi'=>-19500,'chong'=>-19484,'chou'=>-19479,'chu'=>-19467,'chuai'=>-19289,'chuan'=>-19288,'chuang'=>-19281,'chui'=>-19275,'chun'=>-19270,'chuo'=>-19263,'ci'=>-19261,'cong'=>-19249,'cou'=>-19243,'cu'=>-19242,'cuan'=>-19238,'cui'=>-19235,'cun'=>-19227,'cuo'=>-19224,\n        'da'=>-19218,'dai'=>-19212,'dan'=>-19038,'dang'=>-19023,'dao'=>-19018,'de'=>-19006,'deng'=>-19003,'di'=>-18996,'dian'=>-18977,'diao'=>-18961,'die'=>-18952,'ding'=>-18783,'diu'=>-18774,'dong'=>-18773,'dou'=>-18763,'du'=>-18756,'duan'=>-18741,'dui'=>-18735,'dun'=>-18731,'duo'=>-18722,\n        'e'=>-18710,'en'=>-18697,'er'=>-18696,\n        'fa'=>-18526,'fan'=>-18518,'fang'=>-18501,'fei'=>-18490,'fen'=>-18478,'feng'=>-18463,'fo'=>-18448,'fou'=>-18447,'fu'=>-18446,\n        'ga'=>-18239,'gai'=>-18237,'gan'=>-18231,'gang'=>-18220,'gao'=>-18211,'ge'=>-18201,'gei'=>-18184,'gen'=>-18183,'geng'=>-18181,'gong'=>-18012,'gou'=>-17997,'gu'=>-17988,'gua'=>-17970,'guai'=>-17964,'guan'=>-17961,'guang'=>-17950,'gui'=>-17947,'gun'=>-17931,'guo'=>-17928,\n        'ha'=>-17922,'hai'=>-17759,'han'=>-17752,'hang'=>-17733,'hao'=>-17730,'he'=>-17721,'hei'=>-17703,'hen'=>-17701,'heng'=>-17697,'hong'=>-17692,'hou'=>-17683,'hu'=>-17676,'hua'=>-17496,'huai'=>-17487,'huan'=>-17482,'huang'=>-17468,'hui'=>-17454,'hun'=>-17433,'huo'=>-17427,\n        'ji'=>-17417,'jia'=>-17202,'jian'=>-17185,'jiang'=>-16983,'jiao'=>-16970,'jie'=>-16942,'jin'=>-16915,'jing'=>-16733,'jiong'=>-16708,'jiu'=>-16706,'ju'=>-16689,'juan'=>-16664,'jue'=>-16657,'jun'=>-16647,\n        'ka'=>-16474,'kai'=>-16470,'kan'=>-16465,'kang'=>-16459,'kao'=>-16452,'ke'=>-16448,'ken'=>-16433,'keng'=>-16429,'kong'=>-16427,'kou'=>-16423,'ku'=>-16419,'kua'=>-16412,'kuai'=>-16407,'kuan'=>-16403,'kuang'=>-16401,'kui'=>-16393,'kun'=>-16220,'kuo'=>-16216,\n        'la'=>-16212,'lai'=>-16205,'lan'=>-16202,'lang'=>-16187,'lao'=>-16180,'le'=>-16171,'lei'=>-16169,'leng'=>-16158,'li'=>-16155,'lia'=>-15959,'lian'=>-15958,'liang'=>-15944,'liao'=>-15933,'lie'=>-15920,'lin'=>-15915,'ling'=>-15903,'liu'=>-15889,'long'=>-15878,'lou'=>-15707,'lu'=>-15701,'lv'=>-15681,'luan'=>-15667,'lue'=>-15661,'lun'=>-15659,'luo'=>-15652,\n        'ma'=>-15640,'mai'=>-15631,'man'=>-15625,'mang'=>-15454,'mao'=>-15448,'me'=>-15436,'mei'=>-15435,'men'=>-15419,'meng'=>-15416,'mi'=>-15408,'mian'=>-15394,'miao'=>-15385,'mie'=>-15377,'min'=>-15375,'ming'=>-15369,'miu'=>-15363,'mo'=>-15362,'mou'=>-15183,'mu'=>-15180,\n        'na'=>-15165,'nai'=>-15158,'nan'=>-15153,'nang'=>-15150,'nao'=>-15149,'ne'=>-15144,'nei'=>-15143,'nen'=>-15141,'neng'=>-15140,'ni'=>-15139,'nian'=>-15128,'niang'=>-15121,'niao'=>-15119,'nie'=>-15117,'nin'=>-15110,'ning'=>-15109,'niu'=>-14941,'nong'=>-14937,'nu'=>-14933,'nv'=>-14930,'nuan'=>-14929,'nue'=>-14928,'nuo'=>-14926,\n        'o'=>-14922,'ou'=>-14921,\n        'pa'=>-14914,'pai'=>-14908,'pan'=>-14902,'pang'=>-14894,'pao'=>-14889,'pei'=>-14882,'pen'=>-14873,'peng'=>-14871,'pi'=>-14857,'pian'=>-14678,'piao'=>-14674,'pie'=>-14670,'pin'=>-14668,'ping'=>-14663,'po'=>-14654,'pu'=>-14645,\n        'qi'=>-14630,'qia'=>-14594,'qian'=>-14429,'qiang'=>-14407,'qiao'=>-14399,'qie'=>-14384,'qin'=>-14379,'qing'=>-14368,'qiong'=>-14355,'qiu'=>-14353,'qu'=>-14345,'quan'=>-14170,'que'=>-14159,'qun'=>-14151,\n        'ran'=>-14149,'rang'=>-14145,'rao'=>-14140,'re'=>-14137,'ren'=>-14135,'reng'=>-14125,'ri'=>-14123,'rong'=>-14122,'rou'=>-14112,'ru'=>-14109,'ruan'=>-14099,'rui'=>-14097,'run'=>-14094,'ruo'=>-14092,\n        'sa'=>-14090,'sai'=>-14087,'san'=>-14083,'sang'=>-13917,'sao'=>-13914,'se'=>-13910,'sen'=>-13907,'seng'=>-13906,'sha'=>-13905,'shai'=>-13896,'shan'=>-13894,'shang'=>-13878,'shao'=>-13870,'she'=>-13859,'shen'=>-13847,'sheng'=>-13831,'shi'=>-13658,'shou'=>-13611,'shu'=>-13601,'shua'=>-13406,'shuai'=>-13404,'shuan'=>-13400,'shuang'=>-13398,'shui'=>-13395,'shun'=>-13391,'shuo'=>-13387,'si'=>-13383,'song'=>-13367,'sou'=>-13359,'su'=>-13356,'suan'=>-13343,'sui'=>-13340,'sun'=>-13329,'suo'=>-13326,\n        'ta'=>-13318,'tai'=>-13147,'tan'=>-13138,'tang'=>-13120,'tao'=>-13107,'te'=>-13096,'teng'=>-13095,'ti'=>-13091,'tian'=>-13076,'tiao'=>-13068,'tie'=>-13063,'ting'=>-13060,'tong'=>-12888,'tou'=>-12875,'tu'=>-12871,'tuan'=>-12860,'tui'=>-12858,'tun'=>-12852,'tuo'=>-12849,\n        'wa'=>-12838,'wai'=>-12831,'wan'=>-12829,'wang'=>-12812,'wei'=>-12802,'wen'=>-12607,'weng'=>-12597,'wo'=>-12594,'wu'=>-12585,\n        'xi'=>-12556,'xia'=>-12359,'xian'=>-12346,'xiang'=>-12320,'xiao'=>-12300,'xie'=>-12120,'xin'=>-12099,'xing'=>-12089,'xiong'=>-12074,'xiu'=>-12067,'xu'=>-12058,'xuan'=>-12039,'xue'=>-11867,'xun'=>-11861,\n        'ya'=>-11847,'yan'=>-11831,'yang'=>-11798,'yao'=>-11781,'ye'=>-11604,'yi'=>-11589,'yin'=>-11536,'ying'=>-11358,'yo'=>-11340,'yong'=>-11339,'you'=>-11324,'yu'=>-11303,'yuan'=>-11097,'yue'=>-11077,'yun'=>-11067,\n        'za'=>-11055,'zai'=>-11052,'zan'=>-11045,'zang'=>-11041,'zao'=>-11038,'ze'=>-11024,'zei'=>-11020,'zen'=>-11019,'zeng'=>-11018,'zha'=>-11014,'zhai'=>-10838,'zhan'=>-10832,'zhang'=>-10815,'zhao'=>-10800,'zhe'=>-10790,'zhen'=>-10780,'zheng'=>-10764,'zhi'=>-10587,'zhong'=>-10544,'zhou'=>-10533,'zhu'=>-10519,'zhua'=>-10331,'zhuai'=>-10329,'zhuan'=>-10328,'zhuang'=>-10322,'zhui'=>-10315,'zhun'=>-10309,'zhuo'=>-10307,'zi'=>-10296,'zong'=>-10281,'zou'=>-10274,'zu'=>-10270,'zuan'=>-10262,'zui'=>-10260,'zun'=>-10256,'zuo'=>-10254\n    );\n\n    /**\n     * 将中文编码成拼音\n     * @param string $str 要转换为拼音的字符串\n     * @param string $RetFormat 返回格式 [first:每个字的首字母|all:全拼音|one:字符串字母]\n     * @return string\n     */\n    public function get_pinyin($str, $RetFormat='first')\n    {\n        $GBK = iconv('UTF-8', 'GBK', $str);\n        $UTF8 = iconv('GBK', 'UTF-8', $GBK);\n        if($UTF8 != $str) $GBK = $str;\n        $Buf = array();\n        for ($i=0, $iLoop=strlen($GBK); $i<$iLoop; $i++) {\n            $Chr = ord($GBK{$i});\n            if ($Chr>160) {\n                $Chr = ($Chr<<8) + ord($GBK{++$i}) - 65536;\n            }\n            if ('first' == $RetFormat || 'one' == $RetFormat) {\n                $Buf[] = substr($this->zh2py($Chr),0,1);\n            }else{\n                $Buf[] = $this->zh2py($Chr);\n            }\n\n        }\n        if ('first' === $RetFormat) {\n            return implode('', $Buf);\n        }elseif('one' == $RetFormat) {\n            return $Buf[0];\n        }else{\n            return implode(' ', $Buf);\n        }\n    }\n\n    /**\n     * 中文转换到拼音(每次处理一个字符)\n     * @param number $iWORD 待处理字符双字节\n     * @return string 拼音\n     */\n    private function zh2py($iWORD) \n    {\n        if($iWORD>0 && $iWORD<160 ) {\n            return chr($iWORD);\n        } elseif ($iWORD<-20319||$iWORD>-10247) {\n            return '';\n        } else {\n            foreach ($this->data as $py => $code) {\n                if($code > $iWORD) break;\n                $result = $py;\n            }\n            return $result;\n        }\n    }\n}\n\n$Pinyin = new Pinyin();\n//结果为拼音首字母\necho $Pinyin->get_pinyin('测试文字'), '<br/>'; \n//结果为全拼音\necho $Pinyin->get_pinyin('测试文字', 'all'), '<br/>'; \n//结果为第一个拼音\necho $Pinyin->get_pinyin('测试文字', 'one'), '<br/>'; \n```","slug":"PHP汉字转拼音","published":1,"updated":"2018-01-04T01:37:41.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyer40011u8w6ow85vka3","content":"<pre><code>class Pinyin {\n    /**\n     * 拼音字符转换图\n     * @var array\n     */\n    private $data = array(\n        &#39;a&#39;=&gt;-20319,&#39;ai&#39;=&gt;-20317,&#39;an&#39;=&gt;-20304,&#39;ang&#39;=&gt;-20295,&#39;ao&#39;=&gt;-20292,\n        &#39;ba&#39;=&gt;-20283,&#39;bai&#39;=&gt;-20265,&#39;ban&#39;=&gt;-20257,&#39;bang&#39;=&gt;-20242,&#39;bao&#39;=&gt;-20230,&#39;bei&#39;=&gt;-20051,&#39;ben&#39;=&gt;-20036,&#39;beng&#39;=&gt;-20032,&#39;bi&#39;=&gt;-20026,&#39;bian&#39;=&gt;-20002,&#39;biao&#39;=&gt;-19990,&#39;bie&#39;=&gt;-19986,&#39;bin&#39;=&gt;-19982,&#39;bing&#39;=&gt;-19976,&#39;bo&#39;=&gt;-19805,&#39;bu&#39;=&gt;-19784,\n        &#39;ca&#39;=&gt;-19775,&#39;cai&#39;=&gt;-19774,&#39;can&#39;=&gt;-19763,&#39;cang&#39;=&gt;-19756,&#39;cao&#39;=&gt;-19751,&#39;ce&#39;=&gt;-19746,&#39;ceng&#39;=&gt;-19741,&#39;cha&#39;=&gt;-19739,&#39;chai&#39;=&gt;-19728,&#39;chan&#39;=&gt;-19725,&#39;chang&#39;=&gt;-19715,&#39;chao&#39;=&gt;-19540,&#39;che&#39;=&gt;-19531,&#39;chen&#39;=&gt;-19525,&#39;cheng&#39;=&gt;-19515,&#39;chi&#39;=&gt;-19500,&#39;chong&#39;=&gt;-19484,&#39;chou&#39;=&gt;-19479,&#39;chu&#39;=&gt;-19467,&#39;chuai&#39;=&gt;-19289,&#39;chuan&#39;=&gt;-19288,&#39;chuang&#39;=&gt;-19281,&#39;chui&#39;=&gt;-19275,&#39;chun&#39;=&gt;-19270,&#39;chuo&#39;=&gt;-19263,&#39;ci&#39;=&gt;-19261,&#39;cong&#39;=&gt;-19249,&#39;cou&#39;=&gt;-19243,&#39;cu&#39;=&gt;-19242,&#39;cuan&#39;=&gt;-19238,&#39;cui&#39;=&gt;-19235,&#39;cun&#39;=&gt;-19227,&#39;cuo&#39;=&gt;-19224,\n        &#39;da&#39;=&gt;-19218,&#39;dai&#39;=&gt;-19212,&#39;dan&#39;=&gt;-19038,&#39;dang&#39;=&gt;-19023,&#39;dao&#39;=&gt;-19018,&#39;de&#39;=&gt;-19006,&#39;deng&#39;=&gt;-19003,&#39;di&#39;=&gt;-18996,&#39;dian&#39;=&gt;-18977,&#39;diao&#39;=&gt;-18961,&#39;die&#39;=&gt;-18952,&#39;ding&#39;=&gt;-18783,&#39;diu&#39;=&gt;-18774,&#39;dong&#39;=&gt;-18773,&#39;dou&#39;=&gt;-18763,&#39;du&#39;=&gt;-18756,&#39;duan&#39;=&gt;-18741,&#39;dui&#39;=&gt;-18735,&#39;dun&#39;=&gt;-18731,&#39;duo&#39;=&gt;-18722,\n        &#39;e&#39;=&gt;-18710,&#39;en&#39;=&gt;-18697,&#39;er&#39;=&gt;-18696,\n        &#39;fa&#39;=&gt;-18526,&#39;fan&#39;=&gt;-18518,&#39;fang&#39;=&gt;-18501,&#39;fei&#39;=&gt;-18490,&#39;fen&#39;=&gt;-18478,&#39;feng&#39;=&gt;-18463,&#39;fo&#39;=&gt;-18448,&#39;fou&#39;=&gt;-18447,&#39;fu&#39;=&gt;-18446,\n        &#39;ga&#39;=&gt;-18239,&#39;gai&#39;=&gt;-18237,&#39;gan&#39;=&gt;-18231,&#39;gang&#39;=&gt;-18220,&#39;gao&#39;=&gt;-18211,&#39;ge&#39;=&gt;-18201,&#39;gei&#39;=&gt;-18184,&#39;gen&#39;=&gt;-18183,&#39;geng&#39;=&gt;-18181,&#39;gong&#39;=&gt;-18012,&#39;gou&#39;=&gt;-17997,&#39;gu&#39;=&gt;-17988,&#39;gua&#39;=&gt;-17970,&#39;guai&#39;=&gt;-17964,&#39;guan&#39;=&gt;-17961,&#39;guang&#39;=&gt;-17950,&#39;gui&#39;=&gt;-17947,&#39;gun&#39;=&gt;-17931,&#39;guo&#39;=&gt;-17928,\n        &#39;ha&#39;=&gt;-17922,&#39;hai&#39;=&gt;-17759,&#39;han&#39;=&gt;-17752,&#39;hang&#39;=&gt;-17733,&#39;hao&#39;=&gt;-17730,&#39;he&#39;=&gt;-17721,&#39;hei&#39;=&gt;-17703,&#39;hen&#39;=&gt;-17701,&#39;heng&#39;=&gt;-17697,&#39;hong&#39;=&gt;-17692,&#39;hou&#39;=&gt;-17683,&#39;hu&#39;=&gt;-17676,&#39;hua&#39;=&gt;-17496,&#39;huai&#39;=&gt;-17487,&#39;huan&#39;=&gt;-17482,&#39;huang&#39;=&gt;-17468,&#39;hui&#39;=&gt;-17454,&#39;hun&#39;=&gt;-17433,&#39;huo&#39;=&gt;-17427,\n        &#39;ji&#39;=&gt;-17417,&#39;jia&#39;=&gt;-17202,&#39;jian&#39;=&gt;-17185,&#39;jiang&#39;=&gt;-16983,&#39;jiao&#39;=&gt;-16970,&#39;jie&#39;=&gt;-16942,&#39;jin&#39;=&gt;-16915,&#39;jing&#39;=&gt;-16733,&#39;jiong&#39;=&gt;-16708,&#39;jiu&#39;=&gt;-16706,&#39;ju&#39;=&gt;-16689,&#39;juan&#39;=&gt;-16664,&#39;jue&#39;=&gt;-16657,&#39;jun&#39;=&gt;-16647,\n        &#39;ka&#39;=&gt;-16474,&#39;kai&#39;=&gt;-16470,&#39;kan&#39;=&gt;-16465,&#39;kang&#39;=&gt;-16459,&#39;kao&#39;=&gt;-16452,&#39;ke&#39;=&gt;-16448,&#39;ken&#39;=&gt;-16433,&#39;keng&#39;=&gt;-16429,&#39;kong&#39;=&gt;-16427,&#39;kou&#39;=&gt;-16423,&#39;ku&#39;=&gt;-16419,&#39;kua&#39;=&gt;-16412,&#39;kuai&#39;=&gt;-16407,&#39;kuan&#39;=&gt;-16403,&#39;kuang&#39;=&gt;-16401,&#39;kui&#39;=&gt;-16393,&#39;kun&#39;=&gt;-16220,&#39;kuo&#39;=&gt;-16216,\n        &#39;la&#39;=&gt;-16212,&#39;lai&#39;=&gt;-16205,&#39;lan&#39;=&gt;-16202,&#39;lang&#39;=&gt;-16187,&#39;lao&#39;=&gt;-16180,&#39;le&#39;=&gt;-16171,&#39;lei&#39;=&gt;-16169,&#39;leng&#39;=&gt;-16158,&#39;li&#39;=&gt;-16155,&#39;lia&#39;=&gt;-15959,&#39;lian&#39;=&gt;-15958,&#39;liang&#39;=&gt;-15944,&#39;liao&#39;=&gt;-15933,&#39;lie&#39;=&gt;-15920,&#39;lin&#39;=&gt;-15915,&#39;ling&#39;=&gt;-15903,&#39;liu&#39;=&gt;-15889,&#39;long&#39;=&gt;-15878,&#39;lou&#39;=&gt;-15707,&#39;lu&#39;=&gt;-15701,&#39;lv&#39;=&gt;-15681,&#39;luan&#39;=&gt;-15667,&#39;lue&#39;=&gt;-15661,&#39;lun&#39;=&gt;-15659,&#39;luo&#39;=&gt;-15652,\n        &#39;ma&#39;=&gt;-15640,&#39;mai&#39;=&gt;-15631,&#39;man&#39;=&gt;-15625,&#39;mang&#39;=&gt;-15454,&#39;mao&#39;=&gt;-15448,&#39;me&#39;=&gt;-15436,&#39;mei&#39;=&gt;-15435,&#39;men&#39;=&gt;-15419,&#39;meng&#39;=&gt;-15416,&#39;mi&#39;=&gt;-15408,&#39;mian&#39;=&gt;-15394,&#39;miao&#39;=&gt;-15385,&#39;mie&#39;=&gt;-15377,&#39;min&#39;=&gt;-15375,&#39;ming&#39;=&gt;-15369,&#39;miu&#39;=&gt;-15363,&#39;mo&#39;=&gt;-15362,&#39;mou&#39;=&gt;-15183,&#39;mu&#39;=&gt;-15180,\n        &#39;na&#39;=&gt;-15165,&#39;nai&#39;=&gt;-15158,&#39;nan&#39;=&gt;-15153,&#39;nang&#39;=&gt;-15150,&#39;nao&#39;=&gt;-15149,&#39;ne&#39;=&gt;-15144,&#39;nei&#39;=&gt;-15143,&#39;nen&#39;=&gt;-15141,&#39;neng&#39;=&gt;-15140,&#39;ni&#39;=&gt;-15139,&#39;nian&#39;=&gt;-15128,&#39;niang&#39;=&gt;-15121,&#39;niao&#39;=&gt;-15119,&#39;nie&#39;=&gt;-15117,&#39;nin&#39;=&gt;-15110,&#39;ning&#39;=&gt;-15109,&#39;niu&#39;=&gt;-14941,&#39;nong&#39;=&gt;-14937,&#39;nu&#39;=&gt;-14933,&#39;nv&#39;=&gt;-14930,&#39;nuan&#39;=&gt;-14929,&#39;nue&#39;=&gt;-14928,&#39;nuo&#39;=&gt;-14926,\n        &#39;o&#39;=&gt;-14922,&#39;ou&#39;=&gt;-14921,\n        &#39;pa&#39;=&gt;-14914,&#39;pai&#39;=&gt;-14908,&#39;pan&#39;=&gt;-14902,&#39;pang&#39;=&gt;-14894,&#39;pao&#39;=&gt;-14889,&#39;pei&#39;=&gt;-14882,&#39;pen&#39;=&gt;-14873,&#39;peng&#39;=&gt;-14871,&#39;pi&#39;=&gt;-14857,&#39;pian&#39;=&gt;-14678,&#39;piao&#39;=&gt;-14674,&#39;pie&#39;=&gt;-14670,&#39;pin&#39;=&gt;-14668,&#39;ping&#39;=&gt;-14663,&#39;po&#39;=&gt;-14654,&#39;pu&#39;=&gt;-14645,\n        &#39;qi&#39;=&gt;-14630,&#39;qia&#39;=&gt;-14594,&#39;qian&#39;=&gt;-14429,&#39;qiang&#39;=&gt;-14407,&#39;qiao&#39;=&gt;-14399,&#39;qie&#39;=&gt;-14384,&#39;qin&#39;=&gt;-14379,&#39;qing&#39;=&gt;-14368,&#39;qiong&#39;=&gt;-14355,&#39;qiu&#39;=&gt;-14353,&#39;qu&#39;=&gt;-14345,&#39;quan&#39;=&gt;-14170,&#39;que&#39;=&gt;-14159,&#39;qun&#39;=&gt;-14151,\n        &#39;ran&#39;=&gt;-14149,&#39;rang&#39;=&gt;-14145,&#39;rao&#39;=&gt;-14140,&#39;re&#39;=&gt;-14137,&#39;ren&#39;=&gt;-14135,&#39;reng&#39;=&gt;-14125,&#39;ri&#39;=&gt;-14123,&#39;rong&#39;=&gt;-14122,&#39;rou&#39;=&gt;-14112,&#39;ru&#39;=&gt;-14109,&#39;ruan&#39;=&gt;-14099,&#39;rui&#39;=&gt;-14097,&#39;run&#39;=&gt;-14094,&#39;ruo&#39;=&gt;-14092,\n        &#39;sa&#39;=&gt;-14090,&#39;sai&#39;=&gt;-14087,&#39;san&#39;=&gt;-14083,&#39;sang&#39;=&gt;-13917,&#39;sao&#39;=&gt;-13914,&#39;se&#39;=&gt;-13910,&#39;sen&#39;=&gt;-13907,&#39;seng&#39;=&gt;-13906,&#39;sha&#39;=&gt;-13905,&#39;shai&#39;=&gt;-13896,&#39;shan&#39;=&gt;-13894,&#39;shang&#39;=&gt;-13878,&#39;shao&#39;=&gt;-13870,&#39;she&#39;=&gt;-13859,&#39;shen&#39;=&gt;-13847,&#39;sheng&#39;=&gt;-13831,&#39;shi&#39;=&gt;-13658,&#39;shou&#39;=&gt;-13611,&#39;shu&#39;=&gt;-13601,&#39;shua&#39;=&gt;-13406,&#39;shuai&#39;=&gt;-13404,&#39;shuan&#39;=&gt;-13400,&#39;shuang&#39;=&gt;-13398,&#39;shui&#39;=&gt;-13395,&#39;shun&#39;=&gt;-13391,&#39;shuo&#39;=&gt;-13387,&#39;si&#39;=&gt;-13383,&#39;song&#39;=&gt;-13367,&#39;sou&#39;=&gt;-13359,&#39;su&#39;=&gt;-13356,&#39;suan&#39;=&gt;-13343,&#39;sui&#39;=&gt;-13340,&#39;sun&#39;=&gt;-13329,&#39;suo&#39;=&gt;-13326,\n        &#39;ta&#39;=&gt;-13318,&#39;tai&#39;=&gt;-13147,&#39;tan&#39;=&gt;-13138,&#39;tang&#39;=&gt;-13120,&#39;tao&#39;=&gt;-13107,&#39;te&#39;=&gt;-13096,&#39;teng&#39;=&gt;-13095,&#39;ti&#39;=&gt;-13091,&#39;tian&#39;=&gt;-13076,&#39;tiao&#39;=&gt;-13068,&#39;tie&#39;=&gt;-13063,&#39;ting&#39;=&gt;-13060,&#39;tong&#39;=&gt;-12888,&#39;tou&#39;=&gt;-12875,&#39;tu&#39;=&gt;-12871,&#39;tuan&#39;=&gt;-12860,&#39;tui&#39;=&gt;-12858,&#39;tun&#39;=&gt;-12852,&#39;tuo&#39;=&gt;-12849,\n        &#39;wa&#39;=&gt;-12838,&#39;wai&#39;=&gt;-12831,&#39;wan&#39;=&gt;-12829,&#39;wang&#39;=&gt;-12812,&#39;wei&#39;=&gt;-12802,&#39;wen&#39;=&gt;-12607,&#39;weng&#39;=&gt;-12597,&#39;wo&#39;=&gt;-12594,&#39;wu&#39;=&gt;-12585,\n        &#39;xi&#39;=&gt;-12556,&#39;xia&#39;=&gt;-12359,&#39;xian&#39;=&gt;-12346,&#39;xiang&#39;=&gt;-12320,&#39;xiao&#39;=&gt;-12300,&#39;xie&#39;=&gt;-12120,&#39;xin&#39;=&gt;-12099,&#39;xing&#39;=&gt;-12089,&#39;xiong&#39;=&gt;-12074,&#39;xiu&#39;=&gt;-12067,&#39;xu&#39;=&gt;-12058,&#39;xuan&#39;=&gt;-12039,&#39;xue&#39;=&gt;-11867,&#39;xun&#39;=&gt;-11861,\n        &#39;ya&#39;=&gt;-11847,&#39;yan&#39;=&gt;-11831,&#39;yang&#39;=&gt;-11798,&#39;yao&#39;=&gt;-11781,&#39;ye&#39;=&gt;-11604,&#39;yi&#39;=&gt;-11589,&#39;yin&#39;=&gt;-11536,&#39;ying&#39;=&gt;-11358,&#39;yo&#39;=&gt;-11340,&#39;yong&#39;=&gt;-11339,&#39;you&#39;=&gt;-11324,&#39;yu&#39;=&gt;-11303,&#39;yuan&#39;=&gt;-11097,&#39;yue&#39;=&gt;-11077,&#39;yun&#39;=&gt;-11067,\n        &#39;za&#39;=&gt;-11055,&#39;zai&#39;=&gt;-11052,&#39;zan&#39;=&gt;-11045,&#39;zang&#39;=&gt;-11041,&#39;zao&#39;=&gt;-11038,&#39;ze&#39;=&gt;-11024,&#39;zei&#39;=&gt;-11020,&#39;zen&#39;=&gt;-11019,&#39;zeng&#39;=&gt;-11018,&#39;zha&#39;=&gt;-11014,&#39;zhai&#39;=&gt;-10838,&#39;zhan&#39;=&gt;-10832,&#39;zhang&#39;=&gt;-10815,&#39;zhao&#39;=&gt;-10800,&#39;zhe&#39;=&gt;-10790,&#39;zhen&#39;=&gt;-10780,&#39;zheng&#39;=&gt;-10764,&#39;zhi&#39;=&gt;-10587,&#39;zhong&#39;=&gt;-10544,&#39;zhou&#39;=&gt;-10533,&#39;zhu&#39;=&gt;-10519,&#39;zhua&#39;=&gt;-10331,&#39;zhuai&#39;=&gt;-10329,&#39;zhuan&#39;=&gt;-10328,&#39;zhuang&#39;=&gt;-10322,&#39;zhui&#39;=&gt;-10315,&#39;zhun&#39;=&gt;-10309,&#39;zhuo&#39;=&gt;-10307,&#39;zi&#39;=&gt;-10296,&#39;zong&#39;=&gt;-10281,&#39;zou&#39;=&gt;-10274,&#39;zu&#39;=&gt;-10270,&#39;zuan&#39;=&gt;-10262,&#39;zui&#39;=&gt;-10260,&#39;zun&#39;=&gt;-10256,&#39;zuo&#39;=&gt;-10254\n    );\n\n    /**\n     * 将中文编码成拼音\n     * @param string $str 要转换为拼音的字符串\n     * @param string $RetFormat 返回格式 [first:每个字的首字母|all:全拼音|one:字符串字母]\n     * @return string\n     */\n    public function get_pinyin($str, $RetFormat=&#39;first&#39;)\n    {\n        $GBK = iconv(&#39;UTF-8&#39;, &#39;GBK&#39;, $str);\n        $UTF8 = iconv(&#39;GBK&#39;, &#39;UTF-8&#39;, $GBK);\n        if($UTF8 != $str) $GBK = $str;\n        $Buf = array();\n        for ($i=0, $iLoop=strlen($GBK); $i&lt;$iLoop; $i++) {\n            $Chr = ord($GBK{$i});\n            if ($Chr&gt;160) {\n                $Chr = ($Chr&lt;&lt;8) + ord($GBK{++$i}) - 65536;\n            }\n            if (&#39;first&#39; == $RetFormat || &#39;one&#39; == $RetFormat) {\n                $Buf[] = substr($this-&gt;zh2py($Chr),0,1);\n            }else{\n                $Buf[] = $this-&gt;zh2py($Chr);\n            }\n\n        }\n        if (&#39;first&#39; === $RetFormat) {\n            return implode(&#39;&#39;, $Buf);\n        }elseif(&#39;one&#39; == $RetFormat) {\n            return $Buf[0];\n        }else{\n            return implode(&#39; &#39;, $Buf);\n        }\n    }\n\n    /**\n     * 中文转换到拼音(每次处理一个字符)\n     * @param number $iWORD 待处理字符双字节\n     * @return string 拼音\n     */\n    private function zh2py($iWORD) \n    {\n        if($iWORD&gt;0 &amp;&amp; $iWORD&lt;160 ) {\n            return chr($iWORD);\n        } elseif ($iWORD&lt;-20319||$iWORD&gt;-10247) {\n            return &#39;&#39;;\n        } else {\n            foreach ($this-&gt;data as $py =&gt; $code) {\n                if($code &gt; $iWORD) break;\n                $result = $py;\n            }\n            return $result;\n        }\n    }\n}\n\n$Pinyin = new Pinyin();\n//结果为拼音首字母\necho $Pinyin-&gt;get_pinyin(&#39;测试文字&#39;), &#39;&lt;br/&gt;&#39;; \n//结果为全拼音\necho $Pinyin-&gt;get_pinyin(&#39;测试文字&#39;, &#39;all&#39;), &#39;&lt;br/&gt;&#39;; \n//结果为第一个拼音\necho $Pinyin-&gt;get_pinyin(&#39;测试文字&#39;, &#39;one&#39;), &#39;&lt;br/&gt;&#39;;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>class Pinyin {\n    /**\n     * 拼音字符转换图\n     * @var array\n     */\n    private $data = array(\n        &#39;a&#39;=&gt;-20319,&#39;ai&#39;=&gt;-20317,&#39;an&#39;=&gt;-20304,&#39;ang&#39;=&gt;-20295,&#39;ao&#39;=&gt;-20292,\n        &#39;ba&#39;=&gt;-20283,&#39;bai&#39;=&gt;-20265,&#39;ban&#39;=&gt;-20257,&#39;bang&#39;=&gt;-20242,&#39;bao&#39;=&gt;-20230,&#39;bei&#39;=&gt;-20051,&#39;ben&#39;=&gt;-20036,&#39;beng&#39;=&gt;-20032,&#39;bi&#39;=&gt;-20026,&#39;bian&#39;=&gt;-20002,&#39;biao&#39;=&gt;-19990,&#39;bie&#39;=&gt;-19986,&#39;bin&#39;=&gt;-19982,&#39;bing&#39;=&gt;-19976,&#39;bo&#39;=&gt;-19805,&#39;bu&#39;=&gt;-19784,\n        &#39;ca&#39;=&gt;-19775,&#39;cai&#39;=&gt;-19774,&#39;can&#39;=&gt;-19763,&#39;cang&#39;=&gt;-19756,&#39;cao&#39;=&gt;-19751,&#39;ce&#39;=&gt;-19746,&#39;ceng&#39;=&gt;-19741,&#39;cha&#39;=&gt;-19739,&#39;chai&#39;=&gt;-19728,&#39;chan&#39;=&gt;-19725,&#39;chang&#39;=&gt;-19715,&#39;chao&#39;=&gt;-19540,&#39;che&#39;=&gt;-19531,&#39;chen&#39;=&gt;-19525,&#39;cheng&#39;=&gt;-19515,&#39;chi&#39;=&gt;-19500,&#39;chong&#39;=&gt;-19484,&#39;chou&#39;=&gt;-19479,&#39;chu&#39;=&gt;-19467,&#39;chuai&#39;=&gt;-19289,&#39;chuan&#39;=&gt;-19288,&#39;chuang&#39;=&gt;-19281,&#39;chui&#39;=&gt;-19275,&#39;chun&#39;=&gt;-19270,&#39;chuo&#39;=&gt;-19263,&#39;ci&#39;=&gt;-19261,&#39;cong&#39;=&gt;-19249,&#39;cou&#39;=&gt;-19243,&#39;cu&#39;=&gt;-19242,&#39;cuan&#39;=&gt;-19238,&#39;cui&#39;=&gt;-19235,&#39;cun&#39;=&gt;-19227,&#39;cuo&#39;=&gt;-19224,\n        &#39;da&#39;=&gt;-19218,&#39;dai&#39;=&gt;-19212,&#39;dan&#39;=&gt;-19038,&#39;dang&#39;=&gt;-19023,&#39;dao&#39;=&gt;-19018,&#39;de&#39;=&gt;-19006,&#39;deng&#39;=&gt;-19003,&#39;di&#39;=&gt;-18996,&#39;dian&#39;=&gt;-18977,&#39;diao&#39;=&gt;-18961,&#39;die&#39;=&gt;-18952,&#39;ding&#39;=&gt;-18783,&#39;diu&#39;=&gt;-18774,&#39;dong&#39;=&gt;-18773,&#39;dou&#39;=&gt;-18763,&#39;du&#39;=&gt;-18756,&#39;duan&#39;=&gt;-18741,&#39;dui&#39;=&gt;-18735,&#39;dun&#39;=&gt;-18731,&#39;duo&#39;=&gt;-18722,\n        &#39;e&#39;=&gt;-18710,&#39;en&#39;=&gt;-18697,&#39;er&#39;=&gt;-18696,\n        &#39;fa&#39;=&gt;-18526,&#39;fan&#39;=&gt;-18518,&#39;fang&#39;=&gt;-18501,&#39;fei&#39;=&gt;-18490,&#39;fen&#39;=&gt;-18478,&#39;feng&#39;=&gt;-18463,&#39;fo&#39;=&gt;-18448,&#39;fou&#39;=&gt;-18447,&#39;fu&#39;=&gt;-18446,\n        &#39;ga&#39;=&gt;-18239,&#39;gai&#39;=&gt;-18237,&#39;gan&#39;=&gt;-18231,&#39;gang&#39;=&gt;-18220,&#39;gao&#39;=&gt;-18211,&#39;ge&#39;=&gt;-18201,&#39;gei&#39;=&gt;-18184,&#39;gen&#39;=&gt;-18183,&#39;geng&#39;=&gt;-18181,&#39;gong&#39;=&gt;-18012,&#39;gou&#39;=&gt;-17997,&#39;gu&#39;=&gt;-17988,&#39;gua&#39;=&gt;-17970,&#39;guai&#39;=&gt;-17964,&#39;guan&#39;=&gt;-17961,&#39;guang&#39;=&gt;-17950,&#39;gui&#39;=&gt;-17947,&#39;gun&#39;=&gt;-17931,&#39;guo&#39;=&gt;-17928,\n        &#39;ha&#39;=&gt;-17922,&#39;hai&#39;=&gt;-17759,&#39;han&#39;=&gt;-17752,&#39;hang&#39;=&gt;-17733,&#39;hao&#39;=&gt;-17730,&#39;he&#39;=&gt;-17721,&#39;hei&#39;=&gt;-17703,&#39;hen&#39;=&gt;-17701,&#39;heng&#39;=&gt;-17697,&#39;hong&#39;=&gt;-17692,&#39;hou&#39;=&gt;-17683,&#39;hu&#39;=&gt;-17676,&#39;hua&#39;=&gt;-17496,&#39;huai&#39;=&gt;-17487,&#39;huan&#39;=&gt;-17482,&#39;huang&#39;=&gt;-17468,&#39;hui&#39;=&gt;-17454,&#39;hun&#39;=&gt;-17433,&#39;huo&#39;=&gt;-17427,\n        &#39;ji&#39;=&gt;-17417,&#39;jia&#39;=&gt;-17202,&#39;jian&#39;=&gt;-17185,&#39;jiang&#39;=&gt;-16983,&#39;jiao&#39;=&gt;-16970,&#39;jie&#39;=&gt;-16942,&#39;jin&#39;=&gt;-16915,&#39;jing&#39;=&gt;-16733,&#39;jiong&#39;=&gt;-16708,&#39;jiu&#39;=&gt;-16706,&#39;ju&#39;=&gt;-16689,&#39;juan&#39;=&gt;-16664,&#39;jue&#39;=&gt;-16657,&#39;jun&#39;=&gt;-16647,\n        &#39;ka&#39;=&gt;-16474,&#39;kai&#39;=&gt;-16470,&#39;kan&#39;=&gt;-16465,&#39;kang&#39;=&gt;-16459,&#39;kao&#39;=&gt;-16452,&#39;ke&#39;=&gt;-16448,&#39;ken&#39;=&gt;-16433,&#39;keng&#39;=&gt;-16429,&#39;kong&#39;=&gt;-16427,&#39;kou&#39;=&gt;-16423,&#39;ku&#39;=&gt;-16419,&#39;kua&#39;=&gt;-16412,&#39;kuai&#39;=&gt;-16407,&#39;kuan&#39;=&gt;-16403,&#39;kuang&#39;=&gt;-16401,&#39;kui&#39;=&gt;-16393,&#39;kun&#39;=&gt;-16220,&#39;kuo&#39;=&gt;-16216,\n        &#39;la&#39;=&gt;-16212,&#39;lai&#39;=&gt;-16205,&#39;lan&#39;=&gt;-16202,&#39;lang&#39;=&gt;-16187,&#39;lao&#39;=&gt;-16180,&#39;le&#39;=&gt;-16171,&#39;lei&#39;=&gt;-16169,&#39;leng&#39;=&gt;-16158,&#39;li&#39;=&gt;-16155,&#39;lia&#39;=&gt;-15959,&#39;lian&#39;=&gt;-15958,&#39;liang&#39;=&gt;-15944,&#39;liao&#39;=&gt;-15933,&#39;lie&#39;=&gt;-15920,&#39;lin&#39;=&gt;-15915,&#39;ling&#39;=&gt;-15903,&#39;liu&#39;=&gt;-15889,&#39;long&#39;=&gt;-15878,&#39;lou&#39;=&gt;-15707,&#39;lu&#39;=&gt;-15701,&#39;lv&#39;=&gt;-15681,&#39;luan&#39;=&gt;-15667,&#39;lue&#39;=&gt;-15661,&#39;lun&#39;=&gt;-15659,&#39;luo&#39;=&gt;-15652,\n        &#39;ma&#39;=&gt;-15640,&#39;mai&#39;=&gt;-15631,&#39;man&#39;=&gt;-15625,&#39;mang&#39;=&gt;-15454,&#39;mao&#39;=&gt;-15448,&#39;me&#39;=&gt;-15436,&#39;mei&#39;=&gt;-15435,&#39;men&#39;=&gt;-15419,&#39;meng&#39;=&gt;-15416,&#39;mi&#39;=&gt;-15408,&#39;mian&#39;=&gt;-15394,&#39;miao&#39;=&gt;-15385,&#39;mie&#39;=&gt;-15377,&#39;min&#39;=&gt;-15375,&#39;ming&#39;=&gt;-15369,&#39;miu&#39;=&gt;-15363,&#39;mo&#39;=&gt;-15362,&#39;mou&#39;=&gt;-15183,&#39;mu&#39;=&gt;-15180,\n        &#39;na&#39;=&gt;-15165,&#39;nai&#39;=&gt;-15158,&#39;nan&#39;=&gt;-15153,&#39;nang&#39;=&gt;-15150,&#39;nao&#39;=&gt;-15149,&#39;ne&#39;=&gt;-15144,&#39;nei&#39;=&gt;-15143,&#39;nen&#39;=&gt;-15141,&#39;neng&#39;=&gt;-15140,&#39;ni&#39;=&gt;-15139,&#39;nian&#39;=&gt;-15128,&#39;niang&#39;=&gt;-15121,&#39;niao&#39;=&gt;-15119,&#39;nie&#39;=&gt;-15117,&#39;nin&#39;=&gt;-15110,&#39;ning&#39;=&gt;-15109,&#39;niu&#39;=&gt;-14941,&#39;nong&#39;=&gt;-14937,&#39;nu&#39;=&gt;-14933,&#39;nv&#39;=&gt;-14930,&#39;nuan&#39;=&gt;-14929,&#39;nue&#39;=&gt;-14928,&#39;nuo&#39;=&gt;-14926,\n        &#39;o&#39;=&gt;-14922,&#39;ou&#39;=&gt;-14921,\n        &#39;pa&#39;=&gt;-14914,&#39;pai&#39;=&gt;-14908,&#39;pan&#39;=&gt;-14902,&#39;pang&#39;=&gt;-14894,&#39;pao&#39;=&gt;-14889,&#39;pei&#39;=&gt;-14882,&#39;pen&#39;=&gt;-14873,&#39;peng&#39;=&gt;-14871,&#39;pi&#39;=&gt;-14857,&#39;pian&#39;=&gt;-14678,&#39;piao&#39;=&gt;-14674,&#39;pie&#39;=&gt;-14670,&#39;pin&#39;=&gt;-14668,&#39;ping&#39;=&gt;-14663,&#39;po&#39;=&gt;-14654,&#39;pu&#39;=&gt;-14645,\n        &#39;qi&#39;=&gt;-14630,&#39;qia&#39;=&gt;-14594,&#39;qian&#39;=&gt;-14429,&#39;qiang&#39;=&gt;-14407,&#39;qiao&#39;=&gt;-14399,&#39;qie&#39;=&gt;-14384,&#39;qin&#39;=&gt;-14379,&#39;qing&#39;=&gt;-14368,&#39;qiong&#39;=&gt;-14355,&#39;qiu&#39;=&gt;-14353,&#39;qu&#39;=&gt;-14345,&#39;quan&#39;=&gt;-14170,&#39;que&#39;=&gt;-14159,&#39;qun&#39;=&gt;-14151,\n        &#39;ran&#39;=&gt;-14149,&#39;rang&#39;=&gt;-14145,&#39;rao&#39;=&gt;-14140,&#39;re&#39;=&gt;-14137,&#39;ren&#39;=&gt;-14135,&#39;reng&#39;=&gt;-14125,&#39;ri&#39;=&gt;-14123,&#39;rong&#39;=&gt;-14122,&#39;rou&#39;=&gt;-14112,&#39;ru&#39;=&gt;-14109,&#39;ruan&#39;=&gt;-14099,&#39;rui&#39;=&gt;-14097,&#39;run&#39;=&gt;-14094,&#39;ruo&#39;=&gt;-14092,\n        &#39;sa&#39;=&gt;-14090,&#39;sai&#39;=&gt;-14087,&#39;san&#39;=&gt;-14083,&#39;sang&#39;=&gt;-13917,&#39;sao&#39;=&gt;-13914,&#39;se&#39;=&gt;-13910,&#39;sen&#39;=&gt;-13907,&#39;seng&#39;=&gt;-13906,&#39;sha&#39;=&gt;-13905,&#39;shai&#39;=&gt;-13896,&#39;shan&#39;=&gt;-13894,&#39;shang&#39;=&gt;-13878,&#39;shao&#39;=&gt;-13870,&#39;she&#39;=&gt;-13859,&#39;shen&#39;=&gt;-13847,&#39;sheng&#39;=&gt;-13831,&#39;shi&#39;=&gt;-13658,&#39;shou&#39;=&gt;-13611,&#39;shu&#39;=&gt;-13601,&#39;shua&#39;=&gt;-13406,&#39;shuai&#39;=&gt;-13404,&#39;shuan&#39;=&gt;-13400,&#39;shuang&#39;=&gt;-13398,&#39;shui&#39;=&gt;-13395,&#39;shun&#39;=&gt;-13391,&#39;shuo&#39;=&gt;-13387,&#39;si&#39;=&gt;-13383,&#39;song&#39;=&gt;-13367,&#39;sou&#39;=&gt;-13359,&#39;su&#39;=&gt;-13356,&#39;suan&#39;=&gt;-13343,&#39;sui&#39;=&gt;-13340,&#39;sun&#39;=&gt;-13329,&#39;suo&#39;=&gt;-13326,\n        &#39;ta&#39;=&gt;-13318,&#39;tai&#39;=&gt;-13147,&#39;tan&#39;=&gt;-13138,&#39;tang&#39;=&gt;-13120,&#39;tao&#39;=&gt;-13107,&#39;te&#39;=&gt;-13096,&#39;teng&#39;=&gt;-13095,&#39;ti&#39;=&gt;-13091,&#39;tian&#39;=&gt;-13076,&#39;tiao&#39;=&gt;-13068,&#39;tie&#39;=&gt;-13063,&#39;ting&#39;=&gt;-13060,&#39;tong&#39;=&gt;-12888,&#39;tou&#39;=&gt;-12875,&#39;tu&#39;=&gt;-12871,&#39;tuan&#39;=&gt;-12860,&#39;tui&#39;=&gt;-12858,&#39;tun&#39;=&gt;-12852,&#39;tuo&#39;=&gt;-12849,\n        &#39;wa&#39;=&gt;-12838,&#39;wai&#39;=&gt;-12831,&#39;wan&#39;=&gt;-12829,&#39;wang&#39;=&gt;-12812,&#39;wei&#39;=&gt;-12802,&#39;wen&#39;=&gt;-12607,&#39;weng&#39;=&gt;-12597,&#39;wo&#39;=&gt;-12594,&#39;wu&#39;=&gt;-12585,\n        &#39;xi&#39;=&gt;-12556,&#39;xia&#39;=&gt;-12359,&#39;xian&#39;=&gt;-12346,&#39;xiang&#39;=&gt;-12320,&#39;xiao&#39;=&gt;-12300,&#39;xie&#39;=&gt;-12120,&#39;xin&#39;=&gt;-12099,&#39;xing&#39;=&gt;-12089,&#39;xiong&#39;=&gt;-12074,&#39;xiu&#39;=&gt;-12067,&#39;xu&#39;=&gt;-12058,&#39;xuan&#39;=&gt;-12039,&#39;xue&#39;=&gt;-11867,&#39;xun&#39;=&gt;-11861,\n        &#39;ya&#39;=&gt;-11847,&#39;yan&#39;=&gt;-11831,&#39;yang&#39;=&gt;-11798,&#39;yao&#39;=&gt;-11781,&#39;ye&#39;=&gt;-11604,&#39;yi&#39;=&gt;-11589,&#39;yin&#39;=&gt;-11536,&#39;ying&#39;=&gt;-11358,&#39;yo&#39;=&gt;-11340,&#39;yong&#39;=&gt;-11339,&#39;you&#39;=&gt;-11324,&#39;yu&#39;=&gt;-11303,&#39;yuan&#39;=&gt;-11097,&#39;yue&#39;=&gt;-11077,&#39;yun&#39;=&gt;-11067,\n        &#39;za&#39;=&gt;-11055,&#39;zai&#39;=&gt;-11052,&#39;zan&#39;=&gt;-11045,&#39;zang&#39;=&gt;-11041,&#39;zao&#39;=&gt;-11038,&#39;ze&#39;=&gt;-11024,&#39;zei&#39;=&gt;-11020,&#39;zen&#39;=&gt;-11019,&#39;zeng&#39;=&gt;-11018,&#39;zha&#39;=&gt;-11014,&#39;zhai&#39;=&gt;-10838,&#39;zhan&#39;=&gt;-10832,&#39;zhang&#39;=&gt;-10815,&#39;zhao&#39;=&gt;-10800,&#39;zhe&#39;=&gt;-10790,&#39;zhen&#39;=&gt;-10780,&#39;zheng&#39;=&gt;-10764,&#39;zhi&#39;=&gt;-10587,&#39;zhong&#39;=&gt;-10544,&#39;zhou&#39;=&gt;-10533,&#39;zhu&#39;=&gt;-10519,&#39;zhua&#39;=&gt;-10331,&#39;zhuai&#39;=&gt;-10329,&#39;zhuan&#39;=&gt;-10328,&#39;zhuang&#39;=&gt;-10322,&#39;zhui&#39;=&gt;-10315,&#39;zhun&#39;=&gt;-10309,&#39;zhuo&#39;=&gt;-10307,&#39;zi&#39;=&gt;-10296,&#39;zong&#39;=&gt;-10281,&#39;zou&#39;=&gt;-10274,&#39;zu&#39;=&gt;-10270,&#39;zuan&#39;=&gt;-10262,&#39;zui&#39;=&gt;-10260,&#39;zun&#39;=&gt;-10256,&#39;zuo&#39;=&gt;-10254\n    );\n\n    /**\n     * 将中文编码成拼音\n     * @param string $str 要转换为拼音的字符串\n     * @param string $RetFormat 返回格式 [first:每个字的首字母|all:全拼音|one:字符串字母]\n     * @return string\n     */\n    public function get_pinyin($str, $RetFormat=&#39;first&#39;)\n    {\n        $GBK = iconv(&#39;UTF-8&#39;, &#39;GBK&#39;, $str);\n        $UTF8 = iconv(&#39;GBK&#39;, &#39;UTF-8&#39;, $GBK);\n        if($UTF8 != $str) $GBK = $str;\n        $Buf = array();\n        for ($i=0, $iLoop=strlen($GBK); $i&lt;$iLoop; $i++) {\n            $Chr = ord($GBK{$i});\n            if ($Chr&gt;160) {\n                $Chr = ($Chr&lt;&lt;8) + ord($GBK{++$i}) - 65536;\n            }\n            if (&#39;first&#39; == $RetFormat || &#39;one&#39; == $RetFormat) {\n                $Buf[] = substr($this-&gt;zh2py($Chr),0,1);\n            }else{\n                $Buf[] = $this-&gt;zh2py($Chr);\n            }\n\n        }\n        if (&#39;first&#39; === $RetFormat) {\n            return implode(&#39;&#39;, $Buf);\n        }elseif(&#39;one&#39; == $RetFormat) {\n            return $Buf[0];\n        }else{\n            return implode(&#39; &#39;, $Buf);\n        }\n    }\n\n    /**\n     * 中文转换到拼音(每次处理一个字符)\n     * @param number $iWORD 待处理字符双字节\n     * @return string 拼音\n     */\n    private function zh2py($iWORD) \n    {\n        if($iWORD&gt;0 &amp;&amp; $iWORD&lt;160 ) {\n            return chr($iWORD);\n        } elseif ($iWORD&lt;-20319||$iWORD&gt;-10247) {\n            return &#39;&#39;;\n        } else {\n            foreach ($this-&gt;data as $py =&gt; $code) {\n                if($code &gt; $iWORD) break;\n                $result = $py;\n            }\n            return $result;\n        }\n    }\n}\n\n$Pinyin = new Pinyin();\n//结果为拼音首字母\necho $Pinyin-&gt;get_pinyin(&#39;测试文字&#39;), &#39;&lt;br/&gt;&#39;; \n//结果为全拼音\necho $Pinyin-&gt;get_pinyin(&#39;测试文字&#39;, &#39;all&#39;), &#39;&lt;br/&gt;&#39;; \n//结果为第一个拼音\necho $Pinyin-&gt;get_pinyin(&#39;测试文字&#39;, &#39;one&#39;), &#39;&lt;br/&gt;&#39;;\n</code></pre>"},{"title":"PHP知识结构图","date":"2017-02-21T22:26:35.000Z","_content":"前端时间一个大牛根据他自己现在情况总结了一个**PHP知识结构图**，分享一下，这样能充分的认识自己还需要学习什么样的技术\n![PHP知识结构图](http://olln3wpar.bkt.clouddn.com/%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E5%9B%BE%20.png)","source":"_posts/PHP知识结构图.md","raw":"---\ntitle: PHP知识结构图\ndate: 2017-02-22 06:26:35\ncategories:\n- PHP\n---\n前端时间一个大牛根据他自己现在情况总结了一个**PHP知识结构图**，分享一下，这样能充分的认识自己还需要学习什么样的技术\n![PHP知识结构图](http://olln3wpar.bkt.clouddn.com/%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E5%9B%BE%20.png)","slug":"PHP知识结构图","published":1,"updated":"2018-01-04T01:37:41.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyer70015u8w6d5h9tqk7","content":"<p>前端时间一个大牛根据他自己现在情况总结了一个<strong>PHP知识结构图</strong>，分享一下，这样能充分的认识自己还需要学习什么样的技术<br><img src=\"http://olln3wpar.bkt.clouddn.com/%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E5%9B%BE%20.png\" alt=\"PHP知识结构图\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前端时间一个大牛根据他自己现在情况总结了一个<strong>PHP知识结构图</strong>，分享一下，这样能充分的认识自己还需要学习什么样的技术<br><img src=\"http://olln3wpar.bkt.clouddn.com/%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E5%9B%BE%20.png\" alt=\"PHP知识结构图\"></p>\n"},{"title":"PHP高效导出Excel(CSV)","date":"2017-02-16T22:25:18.000Z","_content":"`CSV`，是Comma Separated Value（`逗号分隔值`）的英文缩写，通常都是纯文本文件。\n如果你导出的Excel没有什么`高级用法`的话，`只是做导出数据`用那么建议使用本方法,要比`PHPexcel`要高效的多。\n二十万数据导出大概需要`2`到`3`秒。\n\n```\n /**\n * 导出excel(csv)\n * @data 导出数据\n * @headlist 第一行,列名\n * @fileName 输出Excel文件名\n */\nfunction csv_export($data = array(), $headlist = array(), $fileName) {\n  \n    header('Content-Type: application/vnd.ms-excel');\n    header('Content-Disposition: attachment;filename=\"'.$fileName.'.csv\"');\n    header('Cache-Control: max-age=0');\n  \n    //打开PHP文件句柄,php://output 表示直接输出到浏览器\n    $fp = fopen('php://output', 'a');\n    \n    //输出Excel列名信息\n    foreach ($headlist as $key => $value) {\n        //CSV的Excel支持GBK编码，一定要转换，否则乱码\n        $headlist[$key] = iconv('utf-8', 'gbk', $value);\n    }\n  \n    //将数据通过fputcsv写到文件句柄\n    fputcsv($fp, $headlist);\n    \n    //计数器\n    $num = 0;\n    \n    //每隔$limit行，刷新一下输出buffer，不要太大，也不要太小\n    $limit = 100000;\n    \n    //逐行取出数据，不浪费内存\n    $count = count($data);\n    for ($i = 0; $i < $count; $i++) {\n    \n        $num++;\n        \n        //刷新一下输出buffer，防止由于数据过多造成问题\n        if ($limit == $num) { \n            ob_flush();\n            flush();\n            $num = 0;\n        }\n        \n        $row = $data[$i];\n        foreach ($row as $key => $value) {\n            $row[$key] = iconv('utf-8', 'gbk', $value);\n        }\n\n        fputcsv($fp, $row);\n    }\n  }\n```","source":"_posts/PHP高效导出Excel-CSV.md","raw":"---\ntitle: PHP高效导出Excel(CSV)\ndate: 2017-02-17 06:25:18\ncategories:\n- PHP\n---\n`CSV`，是Comma Separated Value（`逗号分隔值`）的英文缩写，通常都是纯文本文件。\n如果你导出的Excel没有什么`高级用法`的话，`只是做导出数据`用那么建议使用本方法,要比`PHPexcel`要高效的多。\n二十万数据导出大概需要`2`到`3`秒。\n\n```\n /**\n * 导出excel(csv)\n * @data 导出数据\n * @headlist 第一行,列名\n * @fileName 输出Excel文件名\n */\nfunction csv_export($data = array(), $headlist = array(), $fileName) {\n  \n    header('Content-Type: application/vnd.ms-excel');\n    header('Content-Disposition: attachment;filename=\"'.$fileName.'.csv\"');\n    header('Cache-Control: max-age=0');\n  \n    //打开PHP文件句柄,php://output 表示直接输出到浏览器\n    $fp = fopen('php://output', 'a');\n    \n    //输出Excel列名信息\n    foreach ($headlist as $key => $value) {\n        //CSV的Excel支持GBK编码，一定要转换，否则乱码\n        $headlist[$key] = iconv('utf-8', 'gbk', $value);\n    }\n  \n    //将数据通过fputcsv写到文件句柄\n    fputcsv($fp, $headlist);\n    \n    //计数器\n    $num = 0;\n    \n    //每隔$limit行，刷新一下输出buffer，不要太大，也不要太小\n    $limit = 100000;\n    \n    //逐行取出数据，不浪费内存\n    $count = count($data);\n    for ($i = 0; $i < $count; $i++) {\n    \n        $num++;\n        \n        //刷新一下输出buffer，防止由于数据过多造成问题\n        if ($limit == $num) { \n            ob_flush();\n            flush();\n            $num = 0;\n        }\n        \n        $row = $data[$i];\n        foreach ($row as $key => $value) {\n            $row[$key] = iconv('utf-8', 'gbk', $value);\n        }\n\n        fputcsv($fp, $row);\n    }\n  }\n```","slug":"PHP高效导出Excel-CSV","published":1,"updated":"2018-01-04T01:37:41.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyera0017u8w6tco7kq56","content":"<p><code>CSV</code>，是Comma Separated Value（<code>逗号分隔值</code>）的英文缩写，通常都是纯文本文件。<br>如果你导出的Excel没有什么<code>高级用法</code>的话，<code>只是做导出数据</code>用那么建议使用本方法,要比<code>PHPexcel</code>要高效的多。<br>二十万数据导出大概需要<code>2</code>到<code>3</code>秒。</p>\n<pre><code> /**\n * 导出excel(csv)\n * @data 导出数据\n * @headlist 第一行,列名\n * @fileName 输出Excel文件名\n */\nfunction csv_export($data = array(), $headlist = array(), $fileName) {\n\n    header(&#39;Content-Type: application/vnd.ms-excel&#39;);\n    header(&#39;Content-Disposition: attachment;filename=&quot;&#39;.$fileName.&#39;.csv&quot;&#39;);\n    header(&#39;Cache-Control: max-age=0&#39;);\n\n    //打开PHP文件句柄,php://output 表示直接输出到浏览器\n    $fp = fopen(&#39;php://output&#39;, &#39;a&#39;);\n\n    //输出Excel列名信息\n    foreach ($headlist as $key =&gt; $value) {\n        //CSV的Excel支持GBK编码，一定要转换，否则乱码\n        $headlist[$key] = iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $value);\n    }\n\n    //将数据通过fputcsv写到文件句柄\n    fputcsv($fp, $headlist);\n\n    //计数器\n    $num = 0;\n\n    //每隔$limit行，刷新一下输出buffer，不要太大，也不要太小\n    $limit = 100000;\n\n    //逐行取出数据，不浪费内存\n    $count = count($data);\n    for ($i = 0; $i &lt; $count; $i++) {\n\n        $num++;\n\n        //刷新一下输出buffer，防止由于数据过多造成问题\n        if ($limit == $num) { \n            ob_flush();\n            flush();\n            $num = 0;\n        }\n\n        $row = $data[$i];\n        foreach ($row as $key =&gt; $value) {\n            $row[$key] = iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $value);\n        }\n\n        fputcsv($fp, $row);\n    }\n  }\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p><code>CSV</code>，是Comma Separated Value（<code>逗号分隔值</code>）的英文缩写，通常都是纯文本文件。<br>如果你导出的Excel没有什么<code>高级用法</code>的话，<code>只是做导出数据</code>用那么建议使用本方法,要比<code>PHPexcel</code>要高效的多。<br>二十万数据导出大概需要<code>2</code>到<code>3</code>秒。</p>\n<pre><code> /**\n * 导出excel(csv)\n * @data 导出数据\n * @headlist 第一行,列名\n * @fileName 输出Excel文件名\n */\nfunction csv_export($data = array(), $headlist = array(), $fileName) {\n\n    header(&#39;Content-Type: application/vnd.ms-excel&#39;);\n    header(&#39;Content-Disposition: attachment;filename=&quot;&#39;.$fileName.&#39;.csv&quot;&#39;);\n    header(&#39;Cache-Control: max-age=0&#39;);\n\n    //打开PHP文件句柄,php://output 表示直接输出到浏览器\n    $fp = fopen(&#39;php://output&#39;, &#39;a&#39;);\n\n    //输出Excel列名信息\n    foreach ($headlist as $key =&gt; $value) {\n        //CSV的Excel支持GBK编码，一定要转换，否则乱码\n        $headlist[$key] = iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $value);\n    }\n\n    //将数据通过fputcsv写到文件句柄\n    fputcsv($fp, $headlist);\n\n    //计数器\n    $num = 0;\n\n    //每隔$limit行，刷新一下输出buffer，不要太大，也不要太小\n    $limit = 100000;\n\n    //逐行取出数据，不浪费内存\n    $count = count($data);\n    for ($i = 0; $i &lt; $count; $i++) {\n\n        $num++;\n\n        //刷新一下输出buffer，防止由于数据过多造成问题\n        if ($limit == $num) { \n            ob_flush();\n            flush();\n            $num = 0;\n        }\n\n        $row = $data[$i];\n        foreach ($row as $key =&gt; $value) {\n            $row[$key] = iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $value);\n        }\n\n        fputcsv($fp, $row);\n    }\n  }\n</code></pre>"},{"title":"PhpStorm 中简单使用 PHP_CodeSniffer 规范 PHP 代码(Windows)","date":"2017-04-29T04:58:27.000Z","_content":"\n什么是 PHP_CodeSniffer？\n-------\n`PHP_CodeSniffer` 是 `PEAR` 中的一个用PHP5写的用来检查嗅探 `PHP 代码`是否有`违反`一组`预先设置`好的`编码标准`的`一个包`，它是确保你的`代码简洁`一致的必不可少的`开发工具`，甚至还可以帮助程序员`减少`一些语义`错误`。\n\n什么是 PEAR\n-------\n`PEAR` 是 `PHP 扩展`与`应用库`(the PHP Extension and Application Repository)的`缩写`。它是一个 `PHP扩展及应用`的一个`代码仓库`，简单地说，`PEAR` 之于 `PHP` 就像是CPAN(Comprehensive Perl Archive Network)之于 `PEAR`。\n` PEAR` 的基本目标是发展成为 `PHP 扩展`和`库代码`的`知识库`，而这个项目最有雄心的目标则是试图`定义`一种`标准`，这种`标准`将`帮助`开发者编写可`移植`、`可重用`的`代码`。\n\n那么对于一个开发团队统一的编码风格，有助于他人对代码的理解和维护，对于大项目来说尤其重要。\n\n安装 PEAR\n-------\n1、下载 [PEAR][1]到 PHP 目录\n2、打开 `dos 命令窗口`(win + R 输入 cmd )，进入到 `PHP` 目录下\n```\nphp go-pear.phar\n```\n![][2]\n输入命令，直接`回车`默认 `system` 继续\n![][3]\n直接回车，出现如下，表示安装`成功`\n![][6]\n\n安装 PHP_CodeSniffer\n-------\n```\npear install PHP_CodeSniffer\n```\n如果出现报错,修改 `pear` 配置（路径为 `php 目录`）\n\n![][4]\n```\npear config-set doc_dir D:\\PDT\\php_7.0.14\npear config-set cfg_dir D:\\PDT\\php_7.0.14\npear config-set data_dir D:\\PDT\\php_7.0.14\npear config-set test_dir D:\\PDT\\php_7.0.14\npear config-set www_dir D:\\PDT\\php_7.0.14\npear install PHP_CodeSniffer\n```\n\n\nPhpStorm 配置\n-------\n打开 `PhpStorm` 的配置框，找到 `Languages & Frameworks -> php-> Code Sniffer`，不同版本的 `PhpStorm` 可能会有出入，直接搜索 `Code Sniffer` 也可以。\n点击如下进行编辑：\n![][7]\n设置 `PHP Code Sniffer path` 为 `phpcs.bat` 的路径。\n![][8]\n点击 `Validate`，出现如下图表示设置`成功`：\n![][9]\n打开配置搜索 `Inspections`, 展开 `PHP`，勾选 `PHP Code Sniffer validation`, 选择 `Coding standard` 为 `PSR2` , 点击OK确定\n![][10]\n接下来，在编码 `PHP` 的时候就会出现`规范提示`:\n![][11]\n\n\n  [1]: http://pear.php.net/go-pear.phar\n  [2]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/2.png\n  [4]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/3.png\n  [5]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/4.png\n  [6]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/5.png\n  [7]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/6.png\n  [8]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/7.png\n  [9]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/8.png\n  [10]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/9.png\n  [11]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/10.png","source":"_posts/PhpStorm-中简单使用-PHP-CodeSniffer-规范-PHP-代码-Windows.md","raw":"---\ntitle: PhpStorm 中简单使用 PHP_CodeSniffer 规范 PHP 代码(Windows)\ndate: 2017-04-29 12:58:27\ntags:\ncategories:\n- PHP\n---\n\n什么是 PHP_CodeSniffer？\n-------\n`PHP_CodeSniffer` 是 `PEAR` 中的一个用PHP5写的用来检查嗅探 `PHP 代码`是否有`违反`一组`预先设置`好的`编码标准`的`一个包`，它是确保你的`代码简洁`一致的必不可少的`开发工具`，甚至还可以帮助程序员`减少`一些语义`错误`。\n\n什么是 PEAR\n-------\n`PEAR` 是 `PHP 扩展`与`应用库`(the PHP Extension and Application Repository)的`缩写`。它是一个 `PHP扩展及应用`的一个`代码仓库`，简单地说，`PEAR` 之于 `PHP` 就像是CPAN(Comprehensive Perl Archive Network)之于 `PEAR`。\n` PEAR` 的基本目标是发展成为 `PHP 扩展`和`库代码`的`知识库`，而这个项目最有雄心的目标则是试图`定义`一种`标准`，这种`标准`将`帮助`开发者编写可`移植`、`可重用`的`代码`。\n\n那么对于一个开发团队统一的编码风格，有助于他人对代码的理解和维护，对于大项目来说尤其重要。\n\n安装 PEAR\n-------\n1、下载 [PEAR][1]到 PHP 目录\n2、打开 `dos 命令窗口`(win + R 输入 cmd )，进入到 `PHP` 目录下\n```\nphp go-pear.phar\n```\n![][2]\n输入命令，直接`回车`默认 `system` 继续\n![][3]\n直接回车，出现如下，表示安装`成功`\n![][6]\n\n安装 PHP_CodeSniffer\n-------\n```\npear install PHP_CodeSniffer\n```\n如果出现报错,修改 `pear` 配置（路径为 `php 目录`）\n\n![][4]\n```\npear config-set doc_dir D:\\PDT\\php_7.0.14\npear config-set cfg_dir D:\\PDT\\php_7.0.14\npear config-set data_dir D:\\PDT\\php_7.0.14\npear config-set test_dir D:\\PDT\\php_7.0.14\npear config-set www_dir D:\\PDT\\php_7.0.14\npear install PHP_CodeSniffer\n```\n\n\nPhpStorm 配置\n-------\n打开 `PhpStorm` 的配置框，找到 `Languages & Frameworks -> php-> Code Sniffer`，不同版本的 `PhpStorm` 可能会有出入，直接搜索 `Code Sniffer` 也可以。\n点击如下进行编辑：\n![][7]\n设置 `PHP Code Sniffer path` 为 `phpcs.bat` 的路径。\n![][8]\n点击 `Validate`，出现如下图表示设置`成功`：\n![][9]\n打开配置搜索 `Inspections`, 展开 `PHP`，勾选 `PHP Code Sniffer validation`, 选择 `Coding standard` 为 `PSR2` , 点击OK确定\n![][10]\n接下来，在编码 `PHP` 的时候就会出现`规范提示`:\n![][11]\n\n\n  [1]: http://pear.php.net/go-pear.phar\n  [2]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/2.png\n  [4]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/3.png\n  [5]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/4.png\n  [6]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/5.png\n  [7]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/6.png\n  [8]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/7.png\n  [9]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/8.png\n  [10]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/9.png\n  [11]: http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/10.png","slug":"PhpStorm-中简单使用-PHP-CodeSniffer-规范-PHP-代码-Windows","published":1,"updated":"2018-01-03T02:05:08.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyerf001bu8w6bk5xy1sb","content":"<h2 id=\"什么是-PHP-CodeSniffer？\"><a href=\"#什么是-PHP-CodeSniffer？\" class=\"headerlink\" title=\"什么是 PHP_CodeSniffer？\"></a>什么是 PHP_CodeSniffer？</h2><p><code>PHP_CodeSniffer</code> 是 <code>PEAR</code> 中的一个用PHP5写的用来检查嗅探 <code>PHP 代码</code>是否有<code>违反</code>一组<code>预先设置</code>好的<code>编码标准</code>的<code>一个包</code>，它是确保你的<code>代码简洁</code>一致的必不可少的<code>开发工具</code>，甚至还可以帮助程序员<code>减少</code>一些语义<code>错误</code>。</p>\n<h2 id=\"什么是-PEAR\"><a href=\"#什么是-PEAR\" class=\"headerlink\" title=\"什么是 PEAR\"></a>什么是 PEAR</h2><p><code>PEAR</code> 是 <code>PHP 扩展</code>与<code>应用库</code>(the PHP Extension and Application Repository)的<code>缩写</code>。它是一个 <code>PHP扩展及应用</code>的一个<code>代码仓库</code>，简单地说，<code>PEAR</code> 之于 <code>PHP</code> 就像是CPAN(Comprehensive Perl Archive Network)之于 <code>PEAR</code>。<br><code>PEAR</code> 的基本目标是发展成为 <code>PHP 扩展</code>和<code>库代码</code>的<code>知识库</code>，而这个项目最有雄心的目标则是试图<code>定义</code>一种<code>标准</code>，这种<code>标准</code>将<code>帮助</code>开发者编写可<code>移植</code>、<code>可重用</code>的<code>代码</code>。</p>\n<p>那么对于一个开发团队统一的编码风格，有助于他人对代码的理解和维护，对于大项目来说尤其重要。</p>\n<h2 id=\"安装-PEAR\"><a href=\"#安装-PEAR\" class=\"headerlink\" title=\"安装 PEAR\"></a>安装 PEAR</h2><p>1、下载 <a href=\"http://pear.php.net/go-pear.phar\" target=\"_blank\" rel=\"noopener\">PEAR</a>到 PHP 目录<br>2、打开 <code>dos 命令窗口</code>(win + R 输入 cmd )，进入到 <code>PHP</code> 目录下</p>\n<pre><code>php go-pear.phar\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/1.png\" alt=\"\"><br>输入命令，直接<code>回车</code>默认 <code>system</code> 继续<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/2.png\" alt=\"\"><br>直接回车，出现如下，表示安装<code>成功</code><br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/5.png\" alt=\"\"></p>\n<h2 id=\"安装-PHP-CodeSniffer\"><a href=\"#安装-PHP-CodeSniffer\" class=\"headerlink\" title=\"安装 PHP_CodeSniffer\"></a>安装 PHP_CodeSniffer</h2><pre><code>pear install PHP_CodeSniffer\n</code></pre><p>如果出现报错,修改 <code>pear</code> 配置（路径为 <code>php 目录</code>）</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/3.png\" alt=\"\"></p>\n<pre><code>pear config-set doc_dir D:\\PDT\\php_7.0.14\npear config-set cfg_dir D:\\PDT\\php_7.0.14\npear config-set data_dir D:\\PDT\\php_7.0.14\npear config-set test_dir D:\\PDT\\php_7.0.14\npear config-set www_dir D:\\PDT\\php_7.0.14\npear install PHP_CodeSniffer\n</code></pre><h2 id=\"PhpStorm-配置\"><a href=\"#PhpStorm-配置\" class=\"headerlink\" title=\"PhpStorm 配置\"></a>PhpStorm 配置</h2><p>打开 <code>PhpStorm</code> 的配置框，找到 <code>Languages &amp; Frameworks -&gt; php-&gt; Code Sniffer</code>，不同版本的 <code>PhpStorm</code> 可能会有出入，直接搜索 <code>Code Sniffer</code> 也可以。<br>点击如下进行编辑：<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/6.png\" alt=\"\"><br>设置 <code>PHP Code Sniffer path</code> 为 <code>phpcs.bat</code> 的路径。<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/7.png\" alt=\"\"><br>点击 <code>Validate</code>，出现如下图表示设置<code>成功</code>：<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/8.png\" alt=\"\"><br>打开配置搜索 <code>Inspections</code>, 展开 <code>PHP</code>，勾选 <code>PHP Code Sniffer validation</code>, 选择 <code>Coding standard</code> 为 <code>PSR2</code> , 点击OK确定<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/9.png\" alt=\"\"><br>接下来，在编码 <code>PHP</code> 的时候就会出现<code>规范提示</code>:<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/10.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是-PHP-CodeSniffer？\"><a href=\"#什么是-PHP-CodeSniffer？\" class=\"headerlink\" title=\"什么是 PHP_CodeSniffer？\"></a>什么是 PHP_CodeSniffer？</h2><p><code>PHP_CodeSniffer</code> 是 <code>PEAR</code> 中的一个用PHP5写的用来检查嗅探 <code>PHP 代码</code>是否有<code>违反</code>一组<code>预先设置</code>好的<code>编码标准</code>的<code>一个包</code>，它是确保你的<code>代码简洁</code>一致的必不可少的<code>开发工具</code>，甚至还可以帮助程序员<code>减少</code>一些语义<code>错误</code>。</p>\n<h2 id=\"什么是-PEAR\"><a href=\"#什么是-PEAR\" class=\"headerlink\" title=\"什么是 PEAR\"></a>什么是 PEAR</h2><p><code>PEAR</code> 是 <code>PHP 扩展</code>与<code>应用库</code>(the PHP Extension and Application Repository)的<code>缩写</code>。它是一个 <code>PHP扩展及应用</code>的一个<code>代码仓库</code>，简单地说，<code>PEAR</code> 之于 <code>PHP</code> 就像是CPAN(Comprehensive Perl Archive Network)之于 <code>PEAR</code>。<br><code>PEAR</code> 的基本目标是发展成为 <code>PHP 扩展</code>和<code>库代码</code>的<code>知识库</code>，而这个项目最有雄心的目标则是试图<code>定义</code>一种<code>标准</code>，这种<code>标准</code>将<code>帮助</code>开发者编写可<code>移植</code>、<code>可重用</code>的<code>代码</code>。</p>\n<p>那么对于一个开发团队统一的编码风格，有助于他人对代码的理解和维护，对于大项目来说尤其重要。</p>\n<h2 id=\"安装-PEAR\"><a href=\"#安装-PEAR\" class=\"headerlink\" title=\"安装 PEAR\"></a>安装 PEAR</h2><p>1、下载 <a href=\"http://pear.php.net/go-pear.phar\" target=\"_blank\" rel=\"noopener\">PEAR</a>到 PHP 目录<br>2、打开 <code>dos 命令窗口</code>(win + R 输入 cmd )，进入到 <code>PHP</code> 目录下</p>\n<pre><code>php go-pear.phar\n</code></pre><p><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/1.png\" alt=\"\"><br>输入命令，直接<code>回车</code>默认 <code>system</code> 继续<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/2.png\" alt=\"\"><br>直接回车，出现如下，表示安装<code>成功</code><br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/5.png\" alt=\"\"></p>\n<h2 id=\"安装-PHP-CodeSniffer\"><a href=\"#安装-PHP-CodeSniffer\" class=\"headerlink\" title=\"安装 PHP_CodeSniffer\"></a>安装 PHP_CodeSniffer</h2><pre><code>pear install PHP_CodeSniffer\n</code></pre><p>如果出现报错,修改 <code>pear</code> 配置（路径为 <code>php 目录</code>）</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/3.png\" alt=\"\"></p>\n<pre><code>pear config-set doc_dir D:\\PDT\\php_7.0.14\npear config-set cfg_dir D:\\PDT\\php_7.0.14\npear config-set data_dir D:\\PDT\\php_7.0.14\npear config-set test_dir D:\\PDT\\php_7.0.14\npear config-set www_dir D:\\PDT\\php_7.0.14\npear install PHP_CodeSniffer\n</code></pre><h2 id=\"PhpStorm-配置\"><a href=\"#PhpStorm-配置\" class=\"headerlink\" title=\"PhpStorm 配置\"></a>PhpStorm 配置</h2><p>打开 <code>PhpStorm</code> 的配置框，找到 <code>Languages &amp; Frameworks -&gt; php-&gt; Code Sniffer</code>，不同版本的 <code>PhpStorm</code> 可能会有出入，直接搜索 <code>Code Sniffer</code> 也可以。<br>点击如下进行编辑：<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/6.png\" alt=\"\"><br>设置 <code>PHP Code Sniffer path</code> 为 <code>phpcs.bat</code> 的路径。<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/7.png\" alt=\"\"><br>点击 <code>Validate</code>，出现如下图表示设置<code>成功</code>：<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/8.png\" alt=\"\"><br>打开配置搜索 <code>Inspections</code>, 展开 <code>PHP</code>，勾选 <code>PHP Code Sniffer validation</code>, 选择 <code>Coding standard</code> 为 <code>PSR2</code> , 点击OK确定<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/9.png\" alt=\"\"><br>接下来，在编码 <code>PHP</code> 的时候就会出现<code>规范提示</code>:<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/PHP_CodeSniffer/10.png\" alt=\"\"></p>\n"},{"title":"Redis主从配置（三）","date":"2017-03-06T22:43:42.000Z","_content":"工具\n----------------\n - VMware版本号：12.0.0 \n - CentOS版本：7.0\n - 两台虚拟机(IP)：192.168.29.18、192.168.29.19\n\n安装 Redis \n----------------\n\n下载，解压，编译:\n```\n$ cd /usr/local/\n$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n```\n\n修改配置文件(redis.conf)\n----------------\n\n```\n##192.168.29.18(主)\nport         8000                        //端口        \nbind         192.168.18 127.0.0.1        //redis 在 server 上所有有效的网络接口上监听客户端连接，多个IP用空格隔开\ndaemonize    yes                         //redis后台运行\npidfile      /var/run/redis_8000.pid\nrequirepass  root                        //设置认证密码\n\n##192.168.29.19(从)\nport        8001                         //端口        \nbind        192.168.19 127.0.0.1         //redis 在 server 上所有有效的网络接口上监听客户端连接，多个IP用空格隔开\ndaemonize   yes                          //redis后台运行\npidfile     /var/run/redis_8001.pid\nslaveof     192.168.29.19 8001           //slaveof 主机ip 端口号\nmasterauth  root                         //主机认证密码\n```\n\n关闭防火墙\n----------------\n```\n$ firewall-cmd --state      ##查看防火墙状态\nrunning                     ##防火墙开启\n\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running                 ##防火墙关闭\n```\n`注`: `CentOS 7` 关闭防火墙与 `CentOS 6` 有所不同\n\n启动 Redis\n----------------\n\n```\n$ /usr/local/redis-3.2.8/src/redis-server /usr/local/redis-3.2.8/redis.conf\n```\n\n检查各 Redis 启动情况\n----------------\n```\n##192.168.29.18(主)\n$ ps -ef | grep redis           //redis是否启动成功\n$ netstat -tnlp | grep redis    //监听redis端口\n```\n![图片描述][1]\n\n客户端连接-测试同步\n----------------\n\n```\n##主 -p 端口号 -a 主机验证密码 -h 默认为127.0.0.1\n$ /usr/local/redis-3.2.8/src/redis-cli -p 8000 -a root  \n\n##从\n$ /usr/local/redis-3.2.8/src/redis-cli -p 8001            \n```\n`注:`\n1、因为 `redis.conf` 文件中`bind`参数为：`192.168.29.19 127.0.0.1`\n所以这里不用添加参数：`/usr/local/redis-3.2.8/src/redis-cli -h 192.168.29.19 -p 8000 -a root`\n2、从机`redis.conf` 文件中`masterauth`参数`已配置过`验证密码，所以不用添加参数 `-a`\n\n查看连接状态\n```\n##主\n127.0.0.1:8000> info Replication \n```\n\n![图片描述][2]\n```\n127.0.0.1:8001> info Replication \n```\n![图片描述][3]\n\n在`主机`上执行命令\n\n```\n127.0.0.1:8000> set name redis\n```\n\n在`从机`上查看\n\n```\n127.0.0.1:8001> get name\n```\n![图片描述][4]\n\n说明`主从配置成功`\nPS：计算机不存在`玄学` /捂脸\n\n\n----------\n**相关链接：**\n\n[Linux下PHP安装Redis扩展（二）][5]\n[Redis集群搭建与简单使用（四）][6]\n\n\n  [1]: /img/bVJGHd\n  [2]: /img/bVJGSR\n  [3]: /img/bVJGTN\n  [4]: /img/bVJGWL\n  [5]: https://segmentfault.com/a/1190000008420258\n  [6]: https://segmentfault.com/a/1190000008448919","source":"_posts/Redis主从配置（三）.md","raw":"---\ntitle: Redis主从配置（三）\ndate: 2017-03-07 06:43:42\ntags:\n- Redis\ncategories:\n- NoSQL\n---\n工具\n----------------\n - VMware版本号：12.0.0 \n - CentOS版本：7.0\n - 两台虚拟机(IP)：192.168.29.18、192.168.29.19\n\n安装 Redis \n----------------\n\n下载，解压，编译:\n```\n$ cd /usr/local/\n$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n```\n\n修改配置文件(redis.conf)\n----------------\n\n```\n##192.168.29.18(主)\nport         8000                        //端口        \nbind         192.168.18 127.0.0.1        //redis 在 server 上所有有效的网络接口上监听客户端连接，多个IP用空格隔开\ndaemonize    yes                         //redis后台运行\npidfile      /var/run/redis_8000.pid\nrequirepass  root                        //设置认证密码\n\n##192.168.29.19(从)\nport        8001                         //端口        \nbind        192.168.19 127.0.0.1         //redis 在 server 上所有有效的网络接口上监听客户端连接，多个IP用空格隔开\ndaemonize   yes                          //redis后台运行\npidfile     /var/run/redis_8001.pid\nslaveof     192.168.29.19 8001           //slaveof 主机ip 端口号\nmasterauth  root                         //主机认证密码\n```\n\n关闭防火墙\n----------------\n```\n$ firewall-cmd --state      ##查看防火墙状态\nrunning                     ##防火墙开启\n\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running                 ##防火墙关闭\n```\n`注`: `CentOS 7` 关闭防火墙与 `CentOS 6` 有所不同\n\n启动 Redis\n----------------\n\n```\n$ /usr/local/redis-3.2.8/src/redis-server /usr/local/redis-3.2.8/redis.conf\n```\n\n检查各 Redis 启动情况\n----------------\n```\n##192.168.29.18(主)\n$ ps -ef | grep redis           //redis是否启动成功\n$ netstat -tnlp | grep redis    //监听redis端口\n```\n![图片描述][1]\n\n客户端连接-测试同步\n----------------\n\n```\n##主 -p 端口号 -a 主机验证密码 -h 默认为127.0.0.1\n$ /usr/local/redis-3.2.8/src/redis-cli -p 8000 -a root  \n\n##从\n$ /usr/local/redis-3.2.8/src/redis-cli -p 8001            \n```\n`注:`\n1、因为 `redis.conf` 文件中`bind`参数为：`192.168.29.19 127.0.0.1`\n所以这里不用添加参数：`/usr/local/redis-3.2.8/src/redis-cli -h 192.168.29.19 -p 8000 -a root`\n2、从机`redis.conf` 文件中`masterauth`参数`已配置过`验证密码，所以不用添加参数 `-a`\n\n查看连接状态\n```\n##主\n127.0.0.1:8000> info Replication \n```\n\n![图片描述][2]\n```\n127.0.0.1:8001> info Replication \n```\n![图片描述][3]\n\n在`主机`上执行命令\n\n```\n127.0.0.1:8000> set name redis\n```\n\n在`从机`上查看\n\n```\n127.0.0.1:8001> get name\n```\n![图片描述][4]\n\n说明`主从配置成功`\nPS：计算机不存在`玄学` /捂脸\n\n\n----------\n**相关链接：**\n\n[Linux下PHP安装Redis扩展（二）][5]\n[Redis集群搭建与简单使用（四）][6]\n\n\n  [1]: /img/bVJGHd\n  [2]: /img/bVJGSR\n  [3]: /img/bVJGTN\n  [4]: /img/bVJGWL\n  [5]: https://segmentfault.com/a/1190000008420258\n  [6]: https://segmentfault.com/a/1190000008448919","slug":"Redis主从配置（三）","published":1,"updated":"2018-01-04T01:37:41.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyerj001du8w6jm4by46f","content":"<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>VMware版本号：12.0.0 </li>\n<li>CentOS版本：7.0</li>\n<li>两台虚拟机(IP)：192.168.29.18、192.168.29.19</li>\n</ul>\n<h2 id=\"安装-Redis\"><a href=\"#安装-Redis\" class=\"headerlink\" title=\"安装 Redis \"></a>安装 Redis </h2><p>下载，解压，编译:</p>\n<pre><code>$ cd /usr/local/\n$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n</code></pre><h2 id=\"修改配置文件-redis-conf\"><a href=\"#修改配置文件-redis-conf\" class=\"headerlink\" title=\"修改配置文件(redis.conf)\"></a>修改配置文件(redis.conf)</h2><pre><code>##192.168.29.18(主)\nport         8000                        //端口        \nbind         192.168.18 127.0.0.1        //redis 在 server 上所有有效的网络接口上监听客户端连接，多个IP用空格隔开\ndaemonize    yes                         //redis后台运行\npidfile      /var/run/redis_8000.pid\nrequirepass  root                        //设置认证密码\n\n##192.168.29.19(从)\nport        8001                         //端口        \nbind        192.168.19 127.0.0.1         //redis 在 server 上所有有效的网络接口上监听客户端连接，多个IP用空格隔开\ndaemonize   yes                          //redis后台运行\npidfile     /var/run/redis_8001.pid\nslaveof     192.168.29.19 8001           //slaveof 主机ip 端口号\nmasterauth  root                         //主机认证密码\n</code></pre><h2 id=\"关闭防火墙\"><a href=\"#关闭防火墙\" class=\"headerlink\" title=\"关闭防火墙\"></a>关闭防火墙</h2><pre><code>$ firewall-cmd --state      ##查看防火墙状态\nrunning                     ##防火墙开启\n\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running                 ##防火墙关闭\n</code></pre><p><code>注</code>: <code>CentOS 7</code> 关闭防火墙与 <code>CentOS 6</code> 有所不同</p>\n<h2 id=\"启动-Redis\"><a href=\"#启动-Redis\" class=\"headerlink\" title=\"启动 Redis\"></a>启动 Redis</h2><pre><code>$ /usr/local/redis-3.2.8/src/redis-server /usr/local/redis-3.2.8/redis.conf\n</code></pre><h2 id=\"检查各-Redis-启动情况\"><a href=\"#检查各-Redis-启动情况\" class=\"headerlink\" title=\"检查各 Redis 启动情况\"></a>检查各 Redis 启动情况</h2><pre><code>##192.168.29.18(主)\n$ ps -ef | grep redis           //redis是否启动成功\n$ netstat -tnlp | grep redis    //监听redis端口\n</code></pre><p><img src=\"/img/bVJGHd\" alt=\"图片描述\"></p>\n<h2 id=\"客户端连接-测试同步\"><a href=\"#客户端连接-测试同步\" class=\"headerlink\" title=\"客户端连接-测试同步\"></a>客户端连接-测试同步</h2><pre><code>##主 -p 端口号 -a 主机验证密码 -h 默认为127.0.0.1\n$ /usr/local/redis-3.2.8/src/redis-cli -p 8000 -a root  \n\n##从\n$ /usr/local/redis-3.2.8/src/redis-cli -p 8001\n</code></pre><p><code>注:</code><br>1、因为 <code>redis.conf</code> 文件中<code>bind</code>参数为：<code>192.168.29.19 127.0.0.1</code><br>所以这里不用添加参数：<code>/usr/local/redis-3.2.8/src/redis-cli -h 192.168.29.19 -p 8000 -a root</code><br>2、从机<code>redis.conf</code> 文件中<code>masterauth</code>参数<code>已配置过</code>验证密码，所以不用添加参数 <code>-a</code></p>\n<p>查看连接状态</p>\n<pre><code>##主\n127.0.0.1:8000&gt; info Replication\n</code></pre><p><img src=\"/img/bVJGSR\" alt=\"图片描述\"></p>\n<pre><code>127.0.0.1:8001&gt; info Replication\n</code></pre><p><img src=\"/img/bVJGTN\" alt=\"图片描述\"></p>\n<p>在<code>主机</code>上执行命令</p>\n<pre><code>127.0.0.1:8000&gt; set name redis\n</code></pre><p>在<code>从机</code>上查看</p>\n<pre><code>127.0.0.1:8001&gt; get name\n</code></pre><p><img src=\"/img/bVJGWL\" alt=\"图片描述\"></p>\n<p>说明<code>主从配置成功</code><br>PS：计算机不存在<code>玄学</code> /捂脸</p>\n<hr>\n<p><strong>相关链接：</strong></p>\n<p><a href=\"https://segmentfault.com/a/1190000008420258\" target=\"_blank\" rel=\"noopener\">Linux下PHP安装Redis扩展（二）</a><br><a href=\"https://segmentfault.com/a/1190000008448919\" target=\"_blank\" rel=\"noopener\">Redis集群搭建与简单使用（四）</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>VMware版本号：12.0.0 </li>\n<li>CentOS版本：7.0</li>\n<li>两台虚拟机(IP)：192.168.29.18、192.168.29.19</li>\n</ul>\n<h2 id=\"安装-Redis\"><a href=\"#安装-Redis\" class=\"headerlink\" title=\"安装 Redis \"></a>安装 Redis </h2><p>下载，解压，编译:</p>\n<pre><code>$ cd /usr/local/\n$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n</code></pre><h2 id=\"修改配置文件-redis-conf\"><a href=\"#修改配置文件-redis-conf\" class=\"headerlink\" title=\"修改配置文件(redis.conf)\"></a>修改配置文件(redis.conf)</h2><pre><code>##192.168.29.18(主)\nport         8000                        //端口        \nbind         192.168.18 127.0.0.1        //redis 在 server 上所有有效的网络接口上监听客户端连接，多个IP用空格隔开\ndaemonize    yes                         //redis后台运行\npidfile      /var/run/redis_8000.pid\nrequirepass  root                        //设置认证密码\n\n##192.168.29.19(从)\nport        8001                         //端口        \nbind        192.168.19 127.0.0.1         //redis 在 server 上所有有效的网络接口上监听客户端连接，多个IP用空格隔开\ndaemonize   yes                          //redis后台运行\npidfile     /var/run/redis_8001.pid\nslaveof     192.168.29.19 8001           //slaveof 主机ip 端口号\nmasterauth  root                         //主机认证密码\n</code></pre><h2 id=\"关闭防火墙\"><a href=\"#关闭防火墙\" class=\"headerlink\" title=\"关闭防火墙\"></a>关闭防火墙</h2><pre><code>$ firewall-cmd --state      ##查看防火墙状态\nrunning                     ##防火墙开启\n\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running                 ##防火墙关闭\n</code></pre><p><code>注</code>: <code>CentOS 7</code> 关闭防火墙与 <code>CentOS 6</code> 有所不同</p>\n<h2 id=\"启动-Redis\"><a href=\"#启动-Redis\" class=\"headerlink\" title=\"启动 Redis\"></a>启动 Redis</h2><pre><code>$ /usr/local/redis-3.2.8/src/redis-server /usr/local/redis-3.2.8/redis.conf\n</code></pre><h2 id=\"检查各-Redis-启动情况\"><a href=\"#检查各-Redis-启动情况\" class=\"headerlink\" title=\"检查各 Redis 启动情况\"></a>检查各 Redis 启动情况</h2><pre><code>##192.168.29.18(主)\n$ ps -ef | grep redis           //redis是否启动成功\n$ netstat -tnlp | grep redis    //监听redis端口\n</code></pre><p><img src=\"/img/bVJGHd\" alt=\"图片描述\"></p>\n<h2 id=\"客户端连接-测试同步\"><a href=\"#客户端连接-测试同步\" class=\"headerlink\" title=\"客户端连接-测试同步\"></a>客户端连接-测试同步</h2><pre><code>##主 -p 端口号 -a 主机验证密码 -h 默认为127.0.0.1\n$ /usr/local/redis-3.2.8/src/redis-cli -p 8000 -a root  \n\n##从\n$ /usr/local/redis-3.2.8/src/redis-cli -p 8001\n</code></pre><p><code>注:</code><br>1、因为 <code>redis.conf</code> 文件中<code>bind</code>参数为：<code>192.168.29.19 127.0.0.1</code><br>所以这里不用添加参数：<code>/usr/local/redis-3.2.8/src/redis-cli -h 192.168.29.19 -p 8000 -a root</code><br>2、从机<code>redis.conf</code> 文件中<code>masterauth</code>参数<code>已配置过</code>验证密码，所以不用添加参数 <code>-a</code></p>\n<p>查看连接状态</p>\n<pre><code>##主\n127.0.0.1:8000&gt; info Replication\n</code></pre><p><img src=\"/img/bVJGSR\" alt=\"图片描述\"></p>\n<pre><code>127.0.0.1:8001&gt; info Replication\n</code></pre><p><img src=\"/img/bVJGTN\" alt=\"图片描述\"></p>\n<p>在<code>主机</code>上执行命令</p>\n<pre><code>127.0.0.1:8000&gt; set name redis\n</code></pre><p>在<code>从机</code>上查看</p>\n<pre><code>127.0.0.1:8001&gt; get name\n</code></pre><p><img src=\"/img/bVJGWL\" alt=\"图片描述\"></p>\n<p>说明<code>主从配置成功</code><br>PS：计算机不存在<code>玄学</code> /捂脸</p>\n<hr>\n<p><strong>相关链接：</strong></p>\n<p><a href=\"https://segmentfault.com/a/1190000008420258\" target=\"_blank\" rel=\"noopener\">Linux下PHP安装Redis扩展（二）</a><br><a href=\"https://segmentfault.com/a/1190000008448919\" target=\"_blank\" rel=\"noopener\">Redis集群搭建与简单使用（四）</a></p>\n"},{"title":"Redis持久化（五）","date":"2017-03-08T22:43:42.000Z","_content":"Redis持久化\n----------------\n`Redis` 为了`内部数据`的`安全考虑`，会把本身的数据以`文件`的形式`保存`到`硬盘中`一份，在服务器`重启`后会`自动`把`硬盘`的数据`恢复`到`内存`(Redis)里面\n\n`Redis持久化`分为：\n - RDB 持久化方式\n - AOF 持久化方式\n\n两种持久化可以同时开启\n\nRDB(Redis DataBase)持久化方式\n----------------\n`RDB 持久化`是指在`指定的时间间隔内`将`内存中`的`数据`快照`写入磁盘`，实际操作过程是 `fork `一个子进程，先将`数据`写入`临时文件`，写入成功后，再`替换`之前的文件，用二进制压缩存储\n\n![此处输入图片的描述][1]\n\nRedis 将数据库快照保存在名字为 `dump.rdb` 的二进制文件中\n\n![此处输入图片的描述][2]\n\nRDB 持久化快照名称与路径(redis.conf 文件)：\n\n![此处输入图片的描述][3]\n\nRDB持久化备份频率：\n\n![此处输入图片的描述][4]\n```\n$ save 900 1       #900秒内如果超过1个key被修改，则发起快照保存 \n$ save 300 10\t  #300秒内如果超过10个key被修改，则发起快照保存 \n$ save 60 10000    #60秒内如果超过10000个key被修改，则发起快照保存\n```\n\n**优点：**\n 1. 非常适合于备份，比如你可以在`每个小时`保存一下过去24小时内的数据，同时`每天保存`过去30天的数据，这样即使出了问题你也可以根据需求`恢复`到`不同版本`的数据\n 2. 很方便传送到远端数据中心，非常适用于`灾难恢复`\n 3. `RDB` 在保存 `RDB` 文件时`父进程`唯一需要做的就是 `fork` 出一个子进程，接下来的工作全部由`子进程`来做，父进程不需要再做其他 `IO` 操作，所以 `RDB` 持久化方式可以最大化 `Redis` 的性能\n 4.与 `AOF` 相比，在恢复大的数据的时候，`RDB` 效率更高\n\n\n**缺点：**\n\n 1. 如果你想保证数据的`高可用性`，即`最大限度`的`避免数据丢失`，那么 `RDB` 将不是一个很好的选择。因为系统一旦在定时持久化之前出现`宕机现象`，你可能会`丢失几分钟的数据`\n 2. 由于 `RDB` 是通过 `fork`子进程来协助完成数据持久化工作的，因此，如果当`数据较大`时，可能会导致整个服务器`停止`服务`几百毫秒`，甚至是`1秒钟`\n\n手动发起RDB持久化方式：\n输入 `save` \n\n![此处输入图片的描述][5]\n\n或者 `bgsave` (bgsave 是开启单独线程) \n\n![此处输入图片的描述][6]\n\nAOF(Append Only File)持久化方式\n----------------\n`AOF 持久化`以日志的形式记录服务器所处理的`每一个写、删除操作，查询操作`，当服务器`重启`的时候会`重新执行`这些命令来`恢复`原始的数据\n\n![此处输入图片的描述][7]\n\n\n开启 `AOF` 持久化(redis.conf)\n\n![此处输入图片的描述][8]\n\n`注：`重启 Redis 才生效\n\n![此处输入图片的描述][9]\n\nAOF 持久化名称与路径：\n\n![此处输入图片的描述][10]\n\nAOF 持久化备份频率：\n\n![此处输入图片的描述][11]\n```\n# 每次有新命令追加到 AOF 文件时就执行一次同步 ：非常慢，也非常安全\n$ always \n\n# 每秒同步一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据\n# 推荐（并且也是默认）的措施为每秒同步一次， 这种策略可以兼顾速度和安全性\n$ everysec\n\n# 从不同步：将数据交给操作系统来处理。更快，也更不安全的选择\n$ no\n```\n\nAOF 持久化备份优化:\n因为 `AOF` 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， `AOF` 文件的体积也会变得越来越大\n例如， 如果你对一个计数器调用了 `100` 次 `INCR` ， 那么仅仅是为了保存这个计数器的当前值， `AOF` 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 `SET` 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的\n\n输入 `bgrewriteaof` 命令优化 `AOF` 文件\n![此处输入图片的描述][12]\n\nAOF 文件损坏：\n服务器可能在程序正在对 `AOF` 文件进行写入时`宕机`， 宕机会造成了 `AOF` 文件出错（corrupt）， 那么 `Redis` 在重启时会`拒绝载入`这个 `AOF` 文件， 从而确保`数据`的`一致性`不会被破坏。\n\n修复出错的 `AOF` 文件：\n\n - 为现有的 `AOF` 文件创建一个备份\n - 使用 `Redis` 附带的 `redis-check-aof` 程序，对`原来的 AOF` 文件进行修复：\n ```\n $ redis-check-aof –fix \n ```\n - 使用 `diff -u` 对比`修复后的 AOF` 文件和`原始 AOF` 文件的备份，`查看`两个文件之间的`不同`之处\n - `重启 Redis` 服务器，等待服务器载入`修复后的 AOF` 文件，并进行`数据恢复`\n\n**优点：**\n\n 1.  `AOF` 持久化可以带来更高的数据安全性。`Redis` 中提供了`3种`同步策略，即`每秒同步`、`每修改同步`和`不同步`。使用默认的`每秒同步`其效率也是非常高的(同步是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，你`最多丢失1秒`的数据\n 2.  `AOF` 文件是一个只进行`追加`的日志文件，所以不需要写入 `seek`，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 `redis-check-aof` 工具修复这些问题\n 3.  `Redis` 可以在 `AOF` 文件体积变得过大时，自动地在后台对 `AOF` 进行重写： 重写后的`新 AOF` 文件包含了`恢复当前数据`所需的最小命令集合。 整个重写操作是`绝对安全`的，因为 `Redis` 在创建新 `AOF` 文件的过程中，会继续将命令`追加`到现有的 `AOF` 文件里面，即使`重写过程中发生宕机`，`现有的 AOF` 文件也不会丢失。 而一旦`新 AOF` 文件创建完毕，`Redis` 就会从`旧 AOF` 文件切换到`新 AOF` 文件，并开始对`新 AOF` 文件进行`追加`操作\n 4.  `AOF` 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 `Redis` 协议的格式保存， 因此 `AOF` 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） `AOF` 文件也非常简单： 举个例子， 如果你不小心执行了 `FLUSHALL` 命令， 但只要 `AOF` 文件未被重写， 那么只要停止服务器， 移除 `AOF` 文件末尾的 `FLUSHALL` 命令， 并重启 `Redis` ， 就可以将数据集恢复到 `FLUSHALL` 执行之前的状态\n\n**缺点：**\n\n 1. 对于`相同`的数据来说，`AOF` 文件通常要大于 `RDB` 文件\n 2. 根据`同步策略`的`不同`，`AOF` 的`运行效率`可能会慢于 `RDB` 。总之，`每秒同步`策略的效率是比较高的，`同步禁用`策略的效率和 `RDB` 一样高效。不过在处理`巨大的写入载入`时，`RDB` 可以提供更有保证的最大延迟时间（latency）\n\n从RDB方式切换为AOF方式\n----------------\n在 `Redis 2.2` 或以上版本，可以在`不重启`的情况下，从 `RDB` 切换到 `AOF` ：\n\n - 为最新的 dump.rdb 文件创建一个备份\n - 将备份放到一个安全的地方\n - 执行以下两条命令：\n```\n# 开启 AOF 功能，Redis 会阻塞直到初始 AOF 文件创建完成为止 \n# 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾\n$ redis-cli config set appendonly yes\n# 关闭 RDB 功能\n$ redis-cli config set save\n\n```\n - 确保`写命令`会被`正确`地`追加`到 `AOF` 文件的末尾\n`注：` 在`redis.conf` 中打开 `AOF` 功能，否则服务器重启之后， 之前通过 `CONFIG SET` 设置的配置就会被`遗忘`， 程序会按`原来`的`配置`来`启动`服务器。\n\n总结：\n----------------\n\n - 如果你对`数据安全性非常重视`的话，你应该同时使用`两种持久化`功能\n - 如果你承受`数分钟以内的数据丢失`，你可以只使用 `RDB 持久化`\n\n二者选择的标准，就是看是否愿意牺牲`一些性能`，换取更高的`缓存一致性`（AOF），还是愿意`写`操作`频繁`的时候，`不启用备份`来换取`更高的性能`，待手动运行 `save` 的时候，再做备份（RDB）。\n`注：` 未来 `Redis` 可能会将 `AOF` 和 `RDB` 整合成`单个持久化模型`.\n\n\n----------\n**相关文档：**\n英文：https://redis.io/topics/persistence\n中文：http://www.redis.cn/topics/persistence.html\n\n\n----------\n\n**相关链接：**\n[Linux下PHP安装Redis扩展（二） ][13]\n[Redis主从配置（三）][14]\n[Redis集群搭建与简单使用（四）][15]\n\n\n  [1]: http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-1.png\n  [2]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-2.png\n  [4]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-3.png\n  [5]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-4.png\n  [6]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-5.png\n  [7]: http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-2.png\n  [8]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-7.png\n  [9]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-8.png\n  [10]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-9.png\n  [11]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-10.png\n  [12]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-11.png\n  [13]: https://segmentfault.com/a/1190000008420258\n  [14]: https://segmentfault.com/a/1190000008469182\n  [15]: https://segmentfault.com/a/1190000008448919","source":"_posts/Redis持久化（五）.md","raw":"---\ntitle: Redis持久化（五）\ndate: 2017-03-09 06:43:42\ntags:\n- Redis\ncategories:\n- NoSQL\n---\nRedis持久化\n----------------\n`Redis` 为了`内部数据`的`安全考虑`，会把本身的数据以`文件`的形式`保存`到`硬盘中`一份，在服务器`重启`后会`自动`把`硬盘`的数据`恢复`到`内存`(Redis)里面\n\n`Redis持久化`分为：\n - RDB 持久化方式\n - AOF 持久化方式\n\n两种持久化可以同时开启\n\nRDB(Redis DataBase)持久化方式\n----------------\n`RDB 持久化`是指在`指定的时间间隔内`将`内存中`的`数据`快照`写入磁盘`，实际操作过程是 `fork `一个子进程，先将`数据`写入`临时文件`，写入成功后，再`替换`之前的文件，用二进制压缩存储\n\n![此处输入图片的描述][1]\n\nRedis 将数据库快照保存在名字为 `dump.rdb` 的二进制文件中\n\n![此处输入图片的描述][2]\n\nRDB 持久化快照名称与路径(redis.conf 文件)：\n\n![此处输入图片的描述][3]\n\nRDB持久化备份频率：\n\n![此处输入图片的描述][4]\n```\n$ save 900 1       #900秒内如果超过1个key被修改，则发起快照保存 \n$ save 300 10\t  #300秒内如果超过10个key被修改，则发起快照保存 \n$ save 60 10000    #60秒内如果超过10000个key被修改，则发起快照保存\n```\n\n**优点：**\n 1. 非常适合于备份，比如你可以在`每个小时`保存一下过去24小时内的数据，同时`每天保存`过去30天的数据，这样即使出了问题你也可以根据需求`恢复`到`不同版本`的数据\n 2. 很方便传送到远端数据中心，非常适用于`灾难恢复`\n 3. `RDB` 在保存 `RDB` 文件时`父进程`唯一需要做的就是 `fork` 出一个子进程，接下来的工作全部由`子进程`来做，父进程不需要再做其他 `IO` 操作，所以 `RDB` 持久化方式可以最大化 `Redis` 的性能\n 4.与 `AOF` 相比，在恢复大的数据的时候，`RDB` 效率更高\n\n\n**缺点：**\n\n 1. 如果你想保证数据的`高可用性`，即`最大限度`的`避免数据丢失`，那么 `RDB` 将不是一个很好的选择。因为系统一旦在定时持久化之前出现`宕机现象`，你可能会`丢失几分钟的数据`\n 2. 由于 `RDB` 是通过 `fork`子进程来协助完成数据持久化工作的，因此，如果当`数据较大`时，可能会导致整个服务器`停止`服务`几百毫秒`，甚至是`1秒钟`\n\n手动发起RDB持久化方式：\n输入 `save` \n\n![此处输入图片的描述][5]\n\n或者 `bgsave` (bgsave 是开启单独线程) \n\n![此处输入图片的描述][6]\n\nAOF(Append Only File)持久化方式\n----------------\n`AOF 持久化`以日志的形式记录服务器所处理的`每一个写、删除操作，查询操作`，当服务器`重启`的时候会`重新执行`这些命令来`恢复`原始的数据\n\n![此处输入图片的描述][7]\n\n\n开启 `AOF` 持久化(redis.conf)\n\n![此处输入图片的描述][8]\n\n`注：`重启 Redis 才生效\n\n![此处输入图片的描述][9]\n\nAOF 持久化名称与路径：\n\n![此处输入图片的描述][10]\n\nAOF 持久化备份频率：\n\n![此处输入图片的描述][11]\n```\n# 每次有新命令追加到 AOF 文件时就执行一次同步 ：非常慢，也非常安全\n$ always \n\n# 每秒同步一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据\n# 推荐（并且也是默认）的措施为每秒同步一次， 这种策略可以兼顾速度和安全性\n$ everysec\n\n# 从不同步：将数据交给操作系统来处理。更快，也更不安全的选择\n$ no\n```\n\nAOF 持久化备份优化:\n因为 `AOF` 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， `AOF` 文件的体积也会变得越来越大\n例如， 如果你对一个计数器调用了 `100` 次 `INCR` ， 那么仅仅是为了保存这个计数器的当前值， `AOF` 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 `SET` 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的\n\n输入 `bgrewriteaof` 命令优化 `AOF` 文件\n![此处输入图片的描述][12]\n\nAOF 文件损坏：\n服务器可能在程序正在对 `AOF` 文件进行写入时`宕机`， 宕机会造成了 `AOF` 文件出错（corrupt）， 那么 `Redis` 在重启时会`拒绝载入`这个 `AOF` 文件， 从而确保`数据`的`一致性`不会被破坏。\n\n修复出错的 `AOF` 文件：\n\n - 为现有的 `AOF` 文件创建一个备份\n - 使用 `Redis` 附带的 `redis-check-aof` 程序，对`原来的 AOF` 文件进行修复：\n ```\n $ redis-check-aof –fix \n ```\n - 使用 `diff -u` 对比`修复后的 AOF` 文件和`原始 AOF` 文件的备份，`查看`两个文件之间的`不同`之处\n - `重启 Redis` 服务器，等待服务器载入`修复后的 AOF` 文件，并进行`数据恢复`\n\n**优点：**\n\n 1.  `AOF` 持久化可以带来更高的数据安全性。`Redis` 中提供了`3种`同步策略，即`每秒同步`、`每修改同步`和`不同步`。使用默认的`每秒同步`其效率也是非常高的(同步是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，你`最多丢失1秒`的数据\n 2.  `AOF` 文件是一个只进行`追加`的日志文件，所以不需要写入 `seek`，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 `redis-check-aof` 工具修复这些问题\n 3.  `Redis` 可以在 `AOF` 文件体积变得过大时，自动地在后台对 `AOF` 进行重写： 重写后的`新 AOF` 文件包含了`恢复当前数据`所需的最小命令集合。 整个重写操作是`绝对安全`的，因为 `Redis` 在创建新 `AOF` 文件的过程中，会继续将命令`追加`到现有的 `AOF` 文件里面，即使`重写过程中发生宕机`，`现有的 AOF` 文件也不会丢失。 而一旦`新 AOF` 文件创建完毕，`Redis` 就会从`旧 AOF` 文件切换到`新 AOF` 文件，并开始对`新 AOF` 文件进行`追加`操作\n 4.  `AOF` 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 `Redis` 协议的格式保存， 因此 `AOF` 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） `AOF` 文件也非常简单： 举个例子， 如果你不小心执行了 `FLUSHALL` 命令， 但只要 `AOF` 文件未被重写， 那么只要停止服务器， 移除 `AOF` 文件末尾的 `FLUSHALL` 命令， 并重启 `Redis` ， 就可以将数据集恢复到 `FLUSHALL` 执行之前的状态\n\n**缺点：**\n\n 1. 对于`相同`的数据来说，`AOF` 文件通常要大于 `RDB` 文件\n 2. 根据`同步策略`的`不同`，`AOF` 的`运行效率`可能会慢于 `RDB` 。总之，`每秒同步`策略的效率是比较高的，`同步禁用`策略的效率和 `RDB` 一样高效。不过在处理`巨大的写入载入`时，`RDB` 可以提供更有保证的最大延迟时间（latency）\n\n从RDB方式切换为AOF方式\n----------------\n在 `Redis 2.2` 或以上版本，可以在`不重启`的情况下，从 `RDB` 切换到 `AOF` ：\n\n - 为最新的 dump.rdb 文件创建一个备份\n - 将备份放到一个安全的地方\n - 执行以下两条命令：\n```\n# 开启 AOF 功能，Redis 会阻塞直到初始 AOF 文件创建完成为止 \n# 之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾\n$ redis-cli config set appendonly yes\n# 关闭 RDB 功能\n$ redis-cli config set save\n\n```\n - 确保`写命令`会被`正确`地`追加`到 `AOF` 文件的末尾\n`注：` 在`redis.conf` 中打开 `AOF` 功能，否则服务器重启之后， 之前通过 `CONFIG SET` 设置的配置就会被`遗忘`， 程序会按`原来`的`配置`来`启动`服务器。\n\n总结：\n----------------\n\n - 如果你对`数据安全性非常重视`的话，你应该同时使用`两种持久化`功能\n - 如果你承受`数分钟以内的数据丢失`，你可以只使用 `RDB 持久化`\n\n二者选择的标准，就是看是否愿意牺牲`一些性能`，换取更高的`缓存一致性`（AOF），还是愿意`写`操作`频繁`的时候，`不启用备份`来换取`更高的性能`，待手动运行 `save` 的时候，再做备份（RDB）。\n`注：` 未来 `Redis` 可能会将 `AOF` 和 `RDB` 整合成`单个持久化模型`.\n\n\n----------\n**相关文档：**\n英文：https://redis.io/topics/persistence\n中文：http://www.redis.cn/topics/persistence.html\n\n\n----------\n\n**相关链接：**\n[Linux下PHP安装Redis扩展（二） ][13]\n[Redis主从配置（三）][14]\n[Redis集群搭建与简单使用（四）][15]\n\n\n  [1]: http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-1.png\n  [2]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-1.png\n  [3]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-2.png\n  [4]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-3.png\n  [5]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-4.png\n  [6]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-5.png\n  [7]: http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-2.png\n  [8]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-7.png\n  [9]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-8.png\n  [10]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-9.png\n  [11]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-10.png\n  [12]: http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-11.png\n  [13]: https://segmentfault.com/a/1190000008420258\n  [14]: https://segmentfault.com/a/1190000008469182\n  [15]: https://segmentfault.com/a/1190000008448919","slug":"Redis持久化（五）","published":1,"updated":"2018-01-04T01:37:41.163Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyerm001hu8w6rtqckdpr","content":"<h2 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h2><p><code>Redis</code> 为了<code>内部数据</code>的<code>安全考虑</code>，会把本身的数据以<code>文件</code>的形式<code>保存</code>到<code>硬盘中</code>一份，在服务器<code>重启</code>后会<code>自动</code>把<code>硬盘</code>的数据<code>恢复</code>到<code>内存</code>(Redis)里面</p>\n<p><code>Redis持久化</code>分为：</p>\n<ul>\n<li>RDB 持久化方式</li>\n<li>AOF 持久化方式</li>\n</ul>\n<p>两种持久化可以同时开启</p>\n<h2 id=\"RDB-Redis-DataBase-持久化方式\"><a href=\"#RDB-Redis-DataBase-持久化方式\" class=\"headerlink\" title=\"RDB(Redis DataBase)持久化方式\"></a>RDB(Redis DataBase)持久化方式</h2><p><code>RDB 持久化</code>是指在<code>指定的时间间隔内</code>将<code>内存中</code>的<code>数据</code>快照<code>写入磁盘</code>，实际操作过程是 <code>fork</code>一个子进程，先将<code>数据</code>写入<code>临时文件</code>，写入成功后，再<code>替换</code>之前的文件，用二进制压缩存储</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-1.png\" alt=\"此处输入图片的描述\"></p>\n<p>Redis 将数据库快照保存在名字为 <code>dump.rdb</code> 的二进制文件中</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-1.png\" alt=\"此处输入图片的描述\"></p>\n<p>RDB 持久化快照名称与路径(redis.conf 文件)：</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-2.png\" alt=\"此处输入图片的描述\"></p>\n<p>RDB持久化备份频率：</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-3.png\" alt=\"此处输入图片的描述\"></p>\n<pre><code>$ save 900 1       #900秒内如果超过1个key被修改，则发起快照保存 \n$ save 300 10      #300秒内如果超过10个key被修改，则发起快照保存 \n$ save 60 10000    #60秒内如果超过10000个key被修改，则发起快照保存\n</code></pre><p><strong>优点：</strong></p>\n<ol>\n<li>非常适合于备份，比如你可以在<code>每个小时</code>保存一下过去24小时内的数据，同时<code>每天保存</code>过去30天的数据，这样即使出了问题你也可以根据需求<code>恢复</code>到<code>不同版本</code>的数据</li>\n<li>很方便传送到远端数据中心，非常适用于<code>灾难恢复</code></li>\n<li><code>RDB</code> 在保存 <code>RDB</code> 文件时<code>父进程</code>唯一需要做的就是 <code>fork</code> 出一个子进程，接下来的工作全部由<code>子进程</code>来做，父进程不需要再做其他 <code>IO</code> 操作，所以 <code>RDB</code> 持久化方式可以最大化 <code>Redis</code> 的性能<br>4.与 <code>AOF</code> 相比，在恢复大的数据的时候，<code>RDB</code> 效率更高</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>如果你想保证数据的<code>高可用性</code>，即<code>最大限度</code>的<code>避免数据丢失</code>，那么 <code>RDB</code> 将不是一个很好的选择。因为系统一旦在定时持久化之前出现<code>宕机现象</code>，你可能会<code>丢失几分钟的数据</code></li>\n<li>由于 <code>RDB</code> 是通过 <code>fork</code>子进程来协助完成数据持久化工作的，因此，如果当<code>数据较大</code>时，可能会导致整个服务器<code>停止</code>服务<code>几百毫秒</code>，甚至是<code>1秒钟</code></li>\n</ol>\n<p>手动发起RDB持久化方式：<br>输入 <code>save</code> </p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-4.png\" alt=\"此处输入图片的描述\"></p>\n<p>或者 <code>bgsave</code> (bgsave 是开启单独线程) </p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-5.png\" alt=\"此处输入图片的描述\"></p>\n<h2 id=\"AOF-Append-Only-File-持久化方式\"><a href=\"#AOF-Append-Only-File-持久化方式\" class=\"headerlink\" title=\"AOF(Append Only File)持久化方式\"></a>AOF(Append Only File)持久化方式</h2><p><code>AOF 持久化</code>以日志的形式记录服务器所处理的<code>每一个写、删除操作，查询操作</code>，当服务器<code>重启</code>的时候会<code>重新执行</code>这些命令来<code>恢复</code>原始的数据</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-2.png\" alt=\"此处输入图片的描述\"></p>\n<p>开启 <code>AOF</code> 持久化(redis.conf)</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-7.png\" alt=\"此处输入图片的描述\"></p>\n<p><code>注：</code>重启 Redis 才生效</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-8.png\" alt=\"此处输入图片的描述\"></p>\n<p>AOF 持久化名称与路径：</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-9.png\" alt=\"此处输入图片的描述\"></p>\n<p>AOF 持久化备份频率：</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-10.png\" alt=\"此处输入图片的描述\"></p>\n<pre><code># 每次有新命令追加到 AOF 文件时就执行一次同步 ：非常慢，也非常安全\n$ always \n\n# 每秒同步一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据\n# 推荐（并且也是默认）的措施为每秒同步一次， 这种策略可以兼顾速度和安全性\n$ everysec\n\n# 从不同步：将数据交给操作系统来处理。更快，也更不安全的选择\n$ no\n</code></pre><p>AOF 持久化备份优化:<br>因为 <code>AOF</code> 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， <code>AOF</code> 文件的体积也会变得越来越大<br>例如， 如果你对一个计数器调用了 <code>100</code> 次 <code>INCR</code> ， 那么仅仅是为了保存这个计数器的当前值， <code>AOF</code> 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 <code>SET</code> 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的</p>\n<p>输入 <code>bgrewriteaof</code> 命令优化 <code>AOF</code> 文件<br><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-11.png\" alt=\"此处输入图片的描述\"></p>\n<p>AOF 文件损坏：<br>服务器可能在程序正在对 <code>AOF</code> 文件进行写入时<code>宕机</code>， 宕机会造成了 <code>AOF</code> 文件出错（corrupt）， 那么 <code>Redis</code> 在重启时会<code>拒绝载入</code>这个 <code>AOF</code> 文件， 从而确保<code>数据</code>的<code>一致性</code>不会被破坏。</p>\n<p>修复出错的 <code>AOF</code> 文件：</p>\n<ul>\n<li>为现有的 <code>AOF</code> 文件创建一个备份</li>\n<li>使用 <code>Redis</code> 附带的 <code>redis-check-aof</code> 程序，对<code>原来的 AOF</code> 文件进行修复：<pre><code>$ redis-check-aof –fix\n</code></pre></li>\n<li>使用 <code>diff -u</code> 对比<code>修复后的 AOF</code> 文件和<code>原始 AOF</code> 文件的备份，<code>查看</code>两个文件之间的<code>不同</code>之处</li>\n<li><code>重启 Redis</code> 服务器，等待服务器载入<code>修复后的 AOF</code> 文件，并进行<code>数据恢复</code></li>\n</ul>\n<p><strong>优点：</strong></p>\n<ol>\n<li><code>AOF</code> 持久化可以带来更高的数据安全性。<code>Redis</code> 中提供了<code>3种</code>同步策略，即<code>每秒同步</code>、<code>每修改同步</code>和<code>不同步</code>。使用默认的<code>每秒同步</code>其效率也是非常高的(同步是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，你<code>最多丢失1秒</code>的数据</li>\n<li><code>AOF</code> 文件是一个只进行<code>追加</code>的日志文件，所以不需要写入 <code>seek</code>，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 <code>redis-check-aof</code> 工具修复这些问题</li>\n<li><code>Redis</code> 可以在 <code>AOF</code> 文件体积变得过大时，自动地在后台对 <code>AOF</code> 进行重写： 重写后的<code>新 AOF</code> 文件包含了<code>恢复当前数据</code>所需的最小命令集合。 整个重写操作是<code>绝对安全</code>的，因为 <code>Redis</code> 在创建新 <code>AOF</code> 文件的过程中，会继续将命令<code>追加</code>到现有的 <code>AOF</code> 文件里面，即使<code>重写过程中发生宕机</code>，<code>现有的 AOF</code> 文件也不会丢失。 而一旦<code>新 AOF</code> 文件创建完毕，<code>Redis</code> 就会从<code>旧 AOF</code> 文件切换到<code>新 AOF</code> 文件，并开始对<code>新 AOF</code> 文件进行<code>追加</code>操作</li>\n<li><code>AOF</code> 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 <code>Redis</code> 协议的格式保存， 因此 <code>AOF</code> 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） <code>AOF</code> 文件也非常简单： 举个例子， 如果你不小心执行了 <code>FLUSHALL</code> 命令， 但只要 <code>AOF</code> 文件未被重写， 那么只要停止服务器， 移除 <code>AOF</code> 文件末尾的 <code>FLUSHALL</code> 命令， 并重启 <code>Redis</code> ， 就可以将数据集恢复到 <code>FLUSHALL</code> 执行之前的状态</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>对于<code>相同</code>的数据来说，<code>AOF</code> 文件通常要大于 <code>RDB</code> 文件</li>\n<li>根据<code>同步策略</code>的<code>不同</code>，<code>AOF</code> 的<code>运行效率</code>可能会慢于 <code>RDB</code> 。总之，<code>每秒同步</code>策略的效率是比较高的，<code>同步禁用</code>策略的效率和 <code>RDB</code> 一样高效。不过在处理<code>巨大的写入载入</code>时，<code>RDB</code> 可以提供更有保证的最大延迟时间（latency）</li>\n</ol>\n<h2 id=\"从RDB方式切换为AOF方式\"><a href=\"#从RDB方式切换为AOF方式\" class=\"headerlink\" title=\"从RDB方式切换为AOF方式\"></a>从RDB方式切换为AOF方式</h2><p>在 <code>Redis 2.2</code> 或以上版本，可以在<code>不重启</code>的情况下，从 <code>RDB</code> 切换到 <code>AOF</code> ：</p>\n<ul>\n<li>为最新的 dump.rdb 文件创建一个备份</li>\n<li>将备份放到一个安全的地方</li>\n<li>执行以下两条命令：<br>```<h1 id=\"开启-AOF-功能，Redis-会阻塞直到初始-AOF-文件创建完成为止\"><a href=\"#开启-AOF-功能，Redis-会阻塞直到初始-AOF-文件创建完成为止\" class=\"headerlink\" title=\"开启 AOF 功能，Redis 会阻塞直到初始 AOF 文件创建完成为止\"></a>开启 AOF 功能，Redis 会阻塞直到初始 AOF 文件创建完成为止</h1><h1 id=\"之后-Redis-会继续处理命令请求，-并开始将写入命令追加到-AOF-文件末尾\"><a href=\"#之后-Redis-会继续处理命令请求，-并开始将写入命令追加到-AOF-文件末尾\" class=\"headerlink\" title=\"之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾\"></a>之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾</h1>$ redis-cli config set appendonly yes<h1 id=\"关闭-RDB-功能\"><a href=\"#关闭-RDB-功能\" class=\"headerlink\" title=\"关闭 RDB 功能\"></a>关闭 RDB 功能</h1>$ redis-cli config set save</li>\n</ul>\n<p>```</p>\n<ul>\n<li>确保<code>写命令</code>会被<code>正确</code>地<code>追加</code>到 <code>AOF</code> 文件的末尾<br><code>注：</code> 在<code>redis.conf</code> 中打开 <code>AOF</code> 功能，否则服务器重启之后， 之前通过 <code>CONFIG SET</code> 设置的配置就会被<code>遗忘</code>， 程序会按<code>原来</code>的<code>配置</code>来<code>启动</code>服务器。</li>\n</ul>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li>如果你对<code>数据安全性非常重视</code>的话，你应该同时使用<code>两种持久化</code>功能</li>\n<li>如果你承受<code>数分钟以内的数据丢失</code>，你可以只使用 <code>RDB 持久化</code></li>\n</ul>\n<p>二者选择的标准，就是看是否愿意牺牲<code>一些性能</code>，换取更高的<code>缓存一致性</code>（AOF），还是愿意<code>写</code>操作<code>频繁</code>的时候，<code>不启用备份</code>来换取<code>更高的性能</code>，待手动运行 <code>save</code> 的时候，再做备份（RDB）。<br><code>注：</code> 未来 <code>Redis</code> 可能会将 <code>AOF</code> 和 <code>RDB</code> 整合成<code>单个持久化模型</code>.</p>\n<hr>\n<p><strong>相关文档：</strong><br>英文：<a href=\"https://redis.io/topics/persistence\" target=\"_blank\" rel=\"noopener\">https://redis.io/topics/persistence</a><br>中文：<a href=\"http://www.redis.cn/topics/persistence.html\" target=\"_blank\" rel=\"noopener\">http://www.redis.cn/topics/persistence.html</a></p>\n<hr>\n<p><strong>相关链接：</strong><br><a href=\"https://segmentfault.com/a/1190000008420258\" target=\"_blank\" rel=\"noopener\">Linux下PHP安装Redis扩展（二） </a><br><a href=\"https://segmentfault.com/a/1190000008469182\" target=\"_blank\" rel=\"noopener\">Redis主从配置（三）</a><br><a href=\"https://segmentfault.com/a/1190000008448919\" target=\"_blank\" rel=\"noopener\">Redis集群搭建与简单使用（四）</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Redis持久化\"><a href=\"#Redis持久化\" class=\"headerlink\" title=\"Redis持久化\"></a>Redis持久化</h2><p><code>Redis</code> 为了<code>内部数据</code>的<code>安全考虑</code>，会把本身的数据以<code>文件</code>的形式<code>保存</code>到<code>硬盘中</code>一份，在服务器<code>重启</code>后会<code>自动</code>把<code>硬盘</code>的数据<code>恢复</code>到<code>内存</code>(Redis)里面</p>\n<p><code>Redis持久化</code>分为：</p>\n<ul>\n<li>RDB 持久化方式</li>\n<li>AOF 持久化方式</li>\n</ul>\n<p>两种持久化可以同时开启</p>\n<h2 id=\"RDB-Redis-DataBase-持久化方式\"><a href=\"#RDB-Redis-DataBase-持久化方式\" class=\"headerlink\" title=\"RDB(Redis DataBase)持久化方式\"></a>RDB(Redis DataBase)持久化方式</h2><p><code>RDB 持久化</code>是指在<code>指定的时间间隔内</code>将<code>内存中</code>的<code>数据</code>快照<code>写入磁盘</code>，实际操作过程是 <code>fork</code>一个子进程，先将<code>数据</code>写入<code>临时文件</code>，写入成功后，再<code>替换</code>之前的文件，用二进制压缩存储</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-1.png\" alt=\"此处输入图片的描述\"></p>\n<p>Redis 将数据库快照保存在名字为 <code>dump.rdb</code> 的二进制文件中</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-1.png\" alt=\"此处输入图片的描述\"></p>\n<p>RDB 持久化快照名称与路径(redis.conf 文件)：</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-2.png\" alt=\"此处输入图片的描述\"></p>\n<p>RDB持久化备份频率：</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-3.png\" alt=\"此处输入图片的描述\"></p>\n<pre><code>$ save 900 1       #900秒内如果超过1个key被修改，则发起快照保存 \n$ save 300 10      #300秒内如果超过10个key被修改，则发起快照保存 \n$ save 60 10000    #60秒内如果超过10000个key被修改，则发起快照保存\n</code></pre><p><strong>优点：</strong></p>\n<ol>\n<li>非常适合于备份，比如你可以在<code>每个小时</code>保存一下过去24小时内的数据，同时<code>每天保存</code>过去30天的数据，这样即使出了问题你也可以根据需求<code>恢复</code>到<code>不同版本</code>的数据</li>\n<li>很方便传送到远端数据中心，非常适用于<code>灾难恢复</code></li>\n<li><code>RDB</code> 在保存 <code>RDB</code> 文件时<code>父进程</code>唯一需要做的就是 <code>fork</code> 出一个子进程，接下来的工作全部由<code>子进程</code>来做，父进程不需要再做其他 <code>IO</code> 操作，所以 <code>RDB</code> 持久化方式可以最大化 <code>Redis</code> 的性能<br>4.与 <code>AOF</code> 相比，在恢复大的数据的时候，<code>RDB</code> 效率更高</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>如果你想保证数据的<code>高可用性</code>，即<code>最大限度</code>的<code>避免数据丢失</code>，那么 <code>RDB</code> 将不是一个很好的选择。因为系统一旦在定时持久化之前出现<code>宕机现象</code>，你可能会<code>丢失几分钟的数据</code></li>\n<li>由于 <code>RDB</code> 是通过 <code>fork</code>子进程来协助完成数据持久化工作的，因此，如果当<code>数据较大</code>时，可能会导致整个服务器<code>停止</code>服务<code>几百毫秒</code>，甚至是<code>1秒钟</code></li>\n</ol>\n<p>手动发起RDB持久化方式：<br>输入 <code>save</code> </p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-4.png\" alt=\"此处输入图片的描述\"></p>\n<p>或者 <code>bgsave</code> (bgsave 是开启单独线程) </p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-5.png\" alt=\"此处输入图片的描述\"></p>\n<h2 id=\"AOF-Append-Only-File-持久化方式\"><a href=\"#AOF-Append-Only-File-持久化方式\" class=\"headerlink\" title=\"AOF(Append Only File)持久化方式\"></a>AOF(Append Only File)持久化方式</h2><p><code>AOF 持久化</code>以日志的形式记录服务器所处理的<code>每一个写、删除操作，查询操作</code>，当服务器<code>重启</code>的时候会<code>重新执行</code>这些命令来<code>恢复</code>原始的数据</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-03-10-09-21-2.png\" alt=\"此处输入图片的描述\"></p>\n<p>开启 <code>AOF</code> 持久化(redis.conf)</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-7.png\" alt=\"此处输入图片的描述\"></p>\n<p><code>注：</code>重启 Redis 才生效</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-8.png\" alt=\"此处输入图片的描述\"></p>\n<p>AOF 持久化名称与路径：</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-9.png\" alt=\"此处输入图片的描述\"></p>\n<p>AOF 持久化备份频率：</p>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-10.png\" alt=\"此处输入图片的描述\"></p>\n<pre><code># 每次有新命令追加到 AOF 文件时就执行一次同步 ：非常慢，也非常安全\n$ always \n\n# 每秒同步一次：足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据\n# 推荐（并且也是默认）的措施为每秒同步一次， 这种策略可以兼顾速度和安全性\n$ everysec\n\n# 从不同步：将数据交给操作系统来处理。更快，也更不安全的选择\n$ no\n</code></pre><p>AOF 持久化备份优化:<br>因为 <code>AOF</code> 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， <code>AOF</code> 文件的体积也会变得越来越大<br>例如， 如果你对一个计数器调用了 <code>100</code> 次 <code>INCR</code> ， 那么仅仅是为了保存这个计数器的当前值， <code>AOF</code> 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 <code>SET</code> 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的</p>\n<p>输入 <code>bgrewriteaof</code> 命令优化 <code>AOF</code> 文件<br><img src=\"http://olln3wpar.bkt.clouddn.com/2017-3-9-20-33-11.png\" alt=\"此处输入图片的描述\"></p>\n<p>AOF 文件损坏：<br>服务器可能在程序正在对 <code>AOF</code> 文件进行写入时<code>宕机</code>， 宕机会造成了 <code>AOF</code> 文件出错（corrupt）， 那么 <code>Redis</code> 在重启时会<code>拒绝载入</code>这个 <code>AOF</code> 文件， 从而确保<code>数据</code>的<code>一致性</code>不会被破坏。</p>\n<p>修复出错的 <code>AOF</code> 文件：</p>\n<ul>\n<li>为现有的 <code>AOF</code> 文件创建一个备份</li>\n<li>使用 <code>Redis</code> 附带的 <code>redis-check-aof</code> 程序，对<code>原来的 AOF</code> 文件进行修复：<pre><code>$ redis-check-aof –fix\n</code></pre></li>\n<li>使用 <code>diff -u</code> 对比<code>修复后的 AOF</code> 文件和<code>原始 AOF</code> 文件的备份，<code>查看</code>两个文件之间的<code>不同</code>之处</li>\n<li><code>重启 Redis</code> 服务器，等待服务器载入<code>修复后的 AOF</code> 文件，并进行<code>数据恢复</code></li>\n</ul>\n<p><strong>优点：</strong></p>\n<ol>\n<li><code>AOF</code> 持久化可以带来更高的数据安全性。<code>Redis</code> 中提供了<code>3种</code>同步策略，即<code>每秒同步</code>、<code>每修改同步</code>和<code>不同步</code>。使用默认的<code>每秒同步</code>其效率也是非常高的(同步是由后台线程进行处理的，主线程会尽力处理客户端请求)，一旦出现故障，你<code>最多丢失1秒</code>的数据</li>\n<li><code>AOF</code> 文件是一个只进行<code>追加</code>的日志文件，所以不需要写入 <code>seek</code>，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 <code>redis-check-aof</code> 工具修复这些问题</li>\n<li><code>Redis</code> 可以在 <code>AOF</code> 文件体积变得过大时，自动地在后台对 <code>AOF</code> 进行重写： 重写后的<code>新 AOF</code> 文件包含了<code>恢复当前数据</code>所需的最小命令集合。 整个重写操作是<code>绝对安全</code>的，因为 <code>Redis</code> 在创建新 <code>AOF</code> 文件的过程中，会继续将命令<code>追加</code>到现有的 <code>AOF</code> 文件里面，即使<code>重写过程中发生宕机</code>，<code>现有的 AOF</code> 文件也不会丢失。 而一旦<code>新 AOF</code> 文件创建完毕，<code>Redis</code> 就会从<code>旧 AOF</code> 文件切换到<code>新 AOF</code> 文件，并开始对<code>新 AOF</code> 文件进行<code>追加</code>操作</li>\n<li><code>AOF</code> 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 <code>Redis</code> 协议的格式保存， 因此 <code>AOF</code> 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） <code>AOF</code> 文件也非常简单： 举个例子， 如果你不小心执行了 <code>FLUSHALL</code> 命令， 但只要 <code>AOF</code> 文件未被重写， 那么只要停止服务器， 移除 <code>AOF</code> 文件末尾的 <code>FLUSHALL</code> 命令， 并重启 <code>Redis</code> ， 就可以将数据集恢复到 <code>FLUSHALL</code> 执行之前的状态</li>\n</ol>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>对于<code>相同</code>的数据来说，<code>AOF</code> 文件通常要大于 <code>RDB</code> 文件</li>\n<li>根据<code>同步策略</code>的<code>不同</code>，<code>AOF</code> 的<code>运行效率</code>可能会慢于 <code>RDB</code> 。总之，<code>每秒同步</code>策略的效率是比较高的，<code>同步禁用</code>策略的效率和 <code>RDB</code> 一样高效。不过在处理<code>巨大的写入载入</code>时，<code>RDB</code> 可以提供更有保证的最大延迟时间（latency）</li>\n</ol>\n<h2 id=\"从RDB方式切换为AOF方式\"><a href=\"#从RDB方式切换为AOF方式\" class=\"headerlink\" title=\"从RDB方式切换为AOF方式\"></a>从RDB方式切换为AOF方式</h2><p>在 <code>Redis 2.2</code> 或以上版本，可以在<code>不重启</code>的情况下，从 <code>RDB</code> 切换到 <code>AOF</code> ：</p>\n<ul>\n<li>为最新的 dump.rdb 文件创建一个备份</li>\n<li>将备份放到一个安全的地方</li>\n<li>执行以下两条命令：<br>```<h1 id=\"开启-AOF-功能，Redis-会阻塞直到初始-AOF-文件创建完成为止\"><a href=\"#开启-AOF-功能，Redis-会阻塞直到初始-AOF-文件创建完成为止\" class=\"headerlink\" title=\"开启 AOF 功能，Redis 会阻塞直到初始 AOF 文件创建完成为止\"></a>开启 AOF 功能，Redis 会阻塞直到初始 AOF 文件创建完成为止</h1><h1 id=\"之后-Redis-会继续处理命令请求，-并开始将写入命令追加到-AOF-文件末尾\"><a href=\"#之后-Redis-会继续处理命令请求，-并开始将写入命令追加到-AOF-文件末尾\" class=\"headerlink\" title=\"之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾\"></a>之后 Redis 会继续处理命令请求， 并开始将写入命令追加到 AOF 文件末尾</h1>$ redis-cli config set appendonly yes<h1 id=\"关闭-RDB-功能\"><a href=\"#关闭-RDB-功能\" class=\"headerlink\" title=\"关闭 RDB 功能\"></a>关闭 RDB 功能</h1>$ redis-cli config set save</li>\n</ul>\n<p>```</p>\n<ul>\n<li>确保<code>写命令</code>会被<code>正确</code>地<code>追加</code>到 <code>AOF</code> 文件的末尾<br><code>注：</code> 在<code>redis.conf</code> 中打开 <code>AOF</code> 功能，否则服务器重启之后， 之前通过 <code>CONFIG SET</code> 设置的配置就会被<code>遗忘</code>， 程序会按<code>原来</code>的<code>配置</code>来<code>启动</code>服务器。</li>\n</ul>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><ul>\n<li>如果你对<code>数据安全性非常重视</code>的话，你应该同时使用<code>两种持久化</code>功能</li>\n<li>如果你承受<code>数分钟以内的数据丢失</code>，你可以只使用 <code>RDB 持久化</code></li>\n</ul>\n<p>二者选择的标准，就是看是否愿意牺牲<code>一些性能</code>，换取更高的<code>缓存一致性</code>（AOF），还是愿意<code>写</code>操作<code>频繁</code>的时候，<code>不启用备份</code>来换取<code>更高的性能</code>，待手动运行 <code>save</code> 的时候，再做备份（RDB）。<br><code>注：</code> 未来 <code>Redis</code> 可能会将 <code>AOF</code> 和 <code>RDB</code> 整合成<code>单个持久化模型</code>.</p>\n<hr>\n<p><strong>相关文档：</strong><br>英文：<a href=\"https://redis.io/topics/persistence\" target=\"_blank\" rel=\"noopener\">https://redis.io/topics/persistence</a><br>中文：<a href=\"http://www.redis.cn/topics/persistence.html\" target=\"_blank\" rel=\"noopener\">http://www.redis.cn/topics/persistence.html</a></p>\n<hr>\n<p><strong>相关链接：</strong><br><a href=\"https://segmentfault.com/a/1190000008420258\" target=\"_blank\" rel=\"noopener\">Linux下PHP安装Redis扩展（二） </a><br><a href=\"https://segmentfault.com/a/1190000008469182\" target=\"_blank\" rel=\"noopener\">Redis主从配置（三）</a><br><a href=\"https://segmentfault.com/a/1190000008448919\" target=\"_blank\" rel=\"noopener\">Redis集群搭建与简单使用（四）</a></p>\n"},{"title":"Redis集群搭建与简单使用（四）","date":"2017-03-07T22:43:42.000Z","_content":"工具\n----------------\n - VMware版本号：12.0.0 \n - CentOS版本：7.0\n - 三台虚拟机(IP)：192.168.1.8、192.168.1.9、192.168.1.10    \n![图片描述][1]\n\n安装 Redis \n----------------\n下载，解压，编译:\n```\n$ cd /usr/local/\n$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n```\n\n创建 Redis 节点\n----------------\n首先在 `192.168.1.8` 机器上 `/usr/local/redis-3.2.6` 目录下创建 `redis_cluster` 目录\n```\n$ mkdir /usr/local/redis-3.2.6/redis_cluster　\n```\n在 `redis_cluster` 目录下，创建名为`7000`、`7001`、`7002`的目录，并将 `redis.conf` 拷贝到这三个目录中\n```\n$ mkdir 7000 7001 7002\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7000\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7001\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7002\n```\n分别修改这`三个配置文件`，修改如下内容\n```\nport                  7000                        //端口7000,7002,7003        \nbind                  本机ip                      //默认ip为127.0.0.1，需要改为其他节点机器可访问的ip，否则创建集群时无法访问对应的端口，无法创建集群\ndaemonize             yes                         //redis后台运行\npidfile               /var/run/redis_7000.pid     //pidfile文件对应7000，7001，7002\ncluster-enabled       yes                         //开启集群，把注释#去掉\ncluster-config-file   nodes_7000.conf             //集群的配置，配置文件首次启动自动生成 7000，7001，7002\ncluster-node-timeout  15000                       //请求超时，默认15秒，可自行设置\nappendonly            yes                         //aof日志开启，有需要就开启，它会每次写操作都记录一条日志　\n```\n接着在另外两台机器上(`192.168.1.9`、`192.168.1.10`)重复以上三步，只是把目录改为`7003、7004、7005、7006、7007、7008`对应的`配置文件`也按照这个`规则修改`即可\n\n启动各个节点\n----------------\n\n```\n##第一台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7000/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7001/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7002/redis.conf\n \n##第二台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7003/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7004/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7005/redis.conf \n\n##第三台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7006/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7007/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7008/redis.conf \n```\n\n检查各 Redis 启动情况\n----------------\n\n```\n##第一台机器\n$ ps -ef | grep redis           //redis是否启动成功\n$ netstat -tnlp | grep redis    //监听redis端口\n```\n![图片描述][2]\n`注`：确保每个节点没有配置错误，并且启动起来\n\n\n关闭防火墙\n----------------\n\n```\n$ firewall-cmd --state  ##查看防火墙状态\nrunning\n```\n`running` 说明防火墙是打开状态\n```\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running\n```\n`注`: `CentOS 7` 关闭防火墙与 `CentOS 6` 有所不同\n\n安装 Ruby\n----------------\n\n```\n$ yum -y install ruby ruby-devel rubygems rpm-build\n$ gem install redis\n```\n`注`:`创建集群`时需要安装 `Ruby` 运行`redis-trib.rb`\n\n创建集群\n----------------\n`Redis` 官方提供了 `redis-trib.rb` 这个工具，就在解压目录的 `src` 目录中\n```\n$ /usr/local/redis-3.2.6/src/redis-trib.rb  create  --replicas  1  192.168.1.8:7000 192.168.1.8:7001  192.168.1.8:7002 192.168.1.9:7006  192.168.1.9:7004  192.168.1.9:7005 192.168.1.10:7006 192.168.1.10:7007 192.168.1.10:7008\n```\n其中，前三个 `ip:port` 为第一台机器的节点，中间三个为第二台机器，最后三个为第三台机器\n![图片描述][3]\n 输入 `yes`，然后出现如下内容，说明`安装成功`\n![图片描述][4]\n\n集群验证\n----------------\n在第一台机器上连接集群的`7000节点`，在另外一台连接`7004节点`，连接方式为：\n```\n##加参数 -C 可连接到集群，因为 redis.conf 将 bind 改为了ip地址，所以 -h 参数不可以省略，-p 参数为端口号\n$ /usr/local/redis-3.2.6/src/redis-cli -h 192.168.1.8 -c -p 7000  \n```\n在`7004节点`执行命令：\n```\n192.168.1.9:7004> set name redis\n```\n![图片描述][5]\n\n然后在另两台`7000、7007端口`，查看 `key` 为 `name` 的内容\n```\n192.168.1.8:7000> get name\n```\n![图片描述][6]\n\n```\n192.168.1.10:7007> get name\n```\n![图片描述][7]\n\n说明`集群运作正常`\n\n总结\n----------------\n`redis cluster`在设计的时候，就考虑到了去`中心化`、`去中间件`，也就是说，集群中的`每个节点`都是`平等关系`，都是`对等的`，`每个节点`都`保存`各自的`数据`和整个集群的状态。`每个节点`都和`其他所有节点`连接，而且这些连接`保持活跃`，这样就保证了我们`只需要连接`集群中的`任意一个节点`，就可以获取到`其他节点`的`数据`。\n\n`Redis` 集群没有并使用传统的`一致性哈希来`分配数据，而是采用另外一种叫做`哈希槽 `(hash slot)的方式来分配的。`redis cluster` 默认分配了 `16384` 个 `slot`，当我们 `set `一个 `key` 时，会用`CRC16算法`来取模得到所属的 `slot`，然后将这个 `key` 分到`哈希槽区间的节点`上，具体算法就是：`CRC16(key)` % `16384`。所以我们在测试的时候看到 `set` 和 `get` 的时候，直接跳转到了`7000端口`的节点。\n\n`Redis` 集群会把数据存在一个 `master` 节点，然后在这个 `master` 和其对应的 `salve` 之间进行数据同步。当读取数据时，也根据`一致性哈希算法`到对应的 `master` 节点获取数据。只有当一个 `master` 挂掉之后，才会启动一个对应的 `salve` 节点，充当 `master` 。\n\n需要注意的是：必须要`3个`或`以上`的`主节点`，否则在`创建集群`时会`失败`，并且当`存活`的`主节点数`小于`总节点数`的`一半`时，整个`集群`就`无法提供服务`了。\n\n\n----------\n\n\n**相关文档：**\n中文：http://www.redis.cn/topics/cluster-tutorial.html\n英文：https://redis.io/topics/cluster-tutorial\n\n----------\n**相关链接：**\n[Linux下PHP安装Redis扩展（二）][8]\n[Redis主从配置（三）][9]\n[Redis持久化（五）][10]\n\n\n  [1]: /img/bVJBNY\n  [2]: /img/bVJBUO\n  [3]: /img/bVJBZL\n  [4]: /img/bVJBZZ\n  [5]: /img/bVJB1e\n  [6]: /img/bVJB1V\n  [7]: /img/bVJB2c\n  [8]: https://segmentfault.com/a/1190000008420258\n  [9]: https://segmentfault.com/a/1190000008469182\n  [10]: https://segmentfault.com/a/1190000008639459","source":"_posts/Redis集群搭建与简单使用（四）.md","raw":"---\ntitle: Redis集群搭建与简单使用（四）\ndate: 2017-03-08 06:43:42\ntags:\n- Redis\ncategories:\n- NoSQL\n---\n工具\n----------------\n - VMware版本号：12.0.0 \n - CentOS版本：7.0\n - 三台虚拟机(IP)：192.168.1.8、192.168.1.9、192.168.1.10    \n![图片描述][1]\n\n安装 Redis \n----------------\n下载，解压，编译:\n```\n$ cd /usr/local/\n$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n```\n\n创建 Redis 节点\n----------------\n首先在 `192.168.1.8` 机器上 `/usr/local/redis-3.2.6` 目录下创建 `redis_cluster` 目录\n```\n$ mkdir /usr/local/redis-3.2.6/redis_cluster　\n```\n在 `redis_cluster` 目录下，创建名为`7000`、`7001`、`7002`的目录，并将 `redis.conf` 拷贝到这三个目录中\n```\n$ mkdir 7000 7001 7002\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7000\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7001\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7002\n```\n分别修改这`三个配置文件`，修改如下内容\n```\nport                  7000                        //端口7000,7002,7003        \nbind                  本机ip                      //默认ip为127.0.0.1，需要改为其他节点机器可访问的ip，否则创建集群时无法访问对应的端口，无法创建集群\ndaemonize             yes                         //redis后台运行\npidfile               /var/run/redis_7000.pid     //pidfile文件对应7000，7001，7002\ncluster-enabled       yes                         //开启集群，把注释#去掉\ncluster-config-file   nodes_7000.conf             //集群的配置，配置文件首次启动自动生成 7000，7001，7002\ncluster-node-timeout  15000                       //请求超时，默认15秒，可自行设置\nappendonly            yes                         //aof日志开启，有需要就开启，它会每次写操作都记录一条日志　\n```\n接着在另外两台机器上(`192.168.1.9`、`192.168.1.10`)重复以上三步，只是把目录改为`7003、7004、7005、7006、7007、7008`对应的`配置文件`也按照这个`规则修改`即可\n\n启动各个节点\n----------------\n\n```\n##第一台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7000/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7001/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7002/redis.conf\n \n##第二台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7003/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7004/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7005/redis.conf \n\n##第三台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7006/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7007/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7008/redis.conf \n```\n\n检查各 Redis 启动情况\n----------------\n\n```\n##第一台机器\n$ ps -ef | grep redis           //redis是否启动成功\n$ netstat -tnlp | grep redis    //监听redis端口\n```\n![图片描述][2]\n`注`：确保每个节点没有配置错误，并且启动起来\n\n\n关闭防火墙\n----------------\n\n```\n$ firewall-cmd --state  ##查看防火墙状态\nrunning\n```\n`running` 说明防火墙是打开状态\n```\n$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running\n```\n`注`: `CentOS 7` 关闭防火墙与 `CentOS 6` 有所不同\n\n安装 Ruby\n----------------\n\n```\n$ yum -y install ruby ruby-devel rubygems rpm-build\n$ gem install redis\n```\n`注`:`创建集群`时需要安装 `Ruby` 运行`redis-trib.rb`\n\n创建集群\n----------------\n`Redis` 官方提供了 `redis-trib.rb` 这个工具，就在解压目录的 `src` 目录中\n```\n$ /usr/local/redis-3.2.6/src/redis-trib.rb  create  --replicas  1  192.168.1.8:7000 192.168.1.8:7001  192.168.1.8:7002 192.168.1.9:7006  192.168.1.9:7004  192.168.1.9:7005 192.168.1.10:7006 192.168.1.10:7007 192.168.1.10:7008\n```\n其中，前三个 `ip:port` 为第一台机器的节点，中间三个为第二台机器，最后三个为第三台机器\n![图片描述][3]\n 输入 `yes`，然后出现如下内容，说明`安装成功`\n![图片描述][4]\n\n集群验证\n----------------\n在第一台机器上连接集群的`7000节点`，在另外一台连接`7004节点`，连接方式为：\n```\n##加参数 -C 可连接到集群，因为 redis.conf 将 bind 改为了ip地址，所以 -h 参数不可以省略，-p 参数为端口号\n$ /usr/local/redis-3.2.6/src/redis-cli -h 192.168.1.8 -c -p 7000  \n```\n在`7004节点`执行命令：\n```\n192.168.1.9:7004> set name redis\n```\n![图片描述][5]\n\n然后在另两台`7000、7007端口`，查看 `key` 为 `name` 的内容\n```\n192.168.1.8:7000> get name\n```\n![图片描述][6]\n\n```\n192.168.1.10:7007> get name\n```\n![图片描述][7]\n\n说明`集群运作正常`\n\n总结\n----------------\n`redis cluster`在设计的时候，就考虑到了去`中心化`、`去中间件`，也就是说，集群中的`每个节点`都是`平等关系`，都是`对等的`，`每个节点`都`保存`各自的`数据`和整个集群的状态。`每个节点`都和`其他所有节点`连接，而且这些连接`保持活跃`，这样就保证了我们`只需要连接`集群中的`任意一个节点`，就可以获取到`其他节点`的`数据`。\n\n`Redis` 集群没有并使用传统的`一致性哈希来`分配数据，而是采用另外一种叫做`哈希槽 `(hash slot)的方式来分配的。`redis cluster` 默认分配了 `16384` 个 `slot`，当我们 `set `一个 `key` 时，会用`CRC16算法`来取模得到所属的 `slot`，然后将这个 `key` 分到`哈希槽区间的节点`上，具体算法就是：`CRC16(key)` % `16384`。所以我们在测试的时候看到 `set` 和 `get` 的时候，直接跳转到了`7000端口`的节点。\n\n`Redis` 集群会把数据存在一个 `master` 节点，然后在这个 `master` 和其对应的 `salve` 之间进行数据同步。当读取数据时，也根据`一致性哈希算法`到对应的 `master` 节点获取数据。只有当一个 `master` 挂掉之后，才会启动一个对应的 `salve` 节点，充当 `master` 。\n\n需要注意的是：必须要`3个`或`以上`的`主节点`，否则在`创建集群`时会`失败`，并且当`存活`的`主节点数`小于`总节点数`的`一半`时，整个`集群`就`无法提供服务`了。\n\n\n----------\n\n\n**相关文档：**\n中文：http://www.redis.cn/topics/cluster-tutorial.html\n英文：https://redis.io/topics/cluster-tutorial\n\n----------\n**相关链接：**\n[Linux下PHP安装Redis扩展（二）][8]\n[Redis主从配置（三）][9]\n[Redis持久化（五）][10]\n\n\n  [1]: /img/bVJBNY\n  [2]: /img/bVJBUO\n  [3]: /img/bVJBZL\n  [4]: /img/bVJBZZ\n  [5]: /img/bVJB1e\n  [6]: /img/bVJB1V\n  [7]: /img/bVJB2c\n  [8]: https://segmentfault.com/a/1190000008420258\n  [9]: https://segmentfault.com/a/1190000008469182\n  [10]: https://segmentfault.com/a/1190000008639459","slug":"Redis集群搭建与简单使用（四）","published":1,"updated":"2018-01-04T01:37:41.168Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyerr001ju8w6637c45ln","content":"<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>VMware版本号：12.0.0 </li>\n<li>CentOS版本：7.0</li>\n<li>三台虚拟机(IP)：192.168.1.8、192.168.1.9、192.168.1.10<br><img src=\"/img/bVJBNY\" alt=\"图片描述\"></li>\n</ul>\n<h2 id=\"安装-Redis\"><a href=\"#安装-Redis\" class=\"headerlink\" title=\"安装 Redis \"></a>安装 Redis </h2><p>下载，解压，编译:</p>\n<pre><code>$ cd /usr/local/\n$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n</code></pre><h2 id=\"创建-Redis-节点\"><a href=\"#创建-Redis-节点\" class=\"headerlink\" title=\"创建 Redis 节点\"></a>创建 Redis 节点</h2><p>首先在 <code>192.168.1.8</code> 机器上 <code>/usr/local/redis-3.2.6</code> 目录下创建 <code>redis_cluster</code> 目录</p>\n<pre><code>$ mkdir /usr/local/redis-3.2.6/redis_cluster\n</code></pre><p>在 <code>redis_cluster</code> 目录下，创建名为<code>7000</code>、<code>7001</code>、<code>7002</code>的目录，并将 <code>redis.conf</code> 拷贝到这三个目录中</p>\n<pre><code>$ mkdir 7000 7001 7002\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7000\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7001\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7002\n</code></pre><p>分别修改这<code>三个配置文件</code>，修改如下内容</p>\n<pre><code>port                  7000                        //端口7000,7002,7003        \nbind                  本机ip                      //默认ip为127.0.0.1，需要改为其他节点机器可访问的ip，否则创建集群时无法访问对应的端口，无法创建集群\ndaemonize             yes                         //redis后台运行\npidfile               /var/run/redis_7000.pid     //pidfile文件对应7000，7001，7002\ncluster-enabled       yes                         //开启集群，把注释#去掉\ncluster-config-file   nodes_7000.conf             //集群的配置，配置文件首次启动自动生成 7000，7001，7002\ncluster-node-timeout  15000                       //请求超时，默认15秒，可自行设置\nappendonly            yes                         //aof日志开启，有需要就开启，它会每次写操作都记录一条日志\n</code></pre><p>接着在另外两台机器上(<code>192.168.1.9</code>、<code>192.168.1.10</code>)重复以上三步，只是把目录改为<code>7003、7004、7005、7006、7007、7008</code>对应的<code>配置文件</code>也按照这个<code>规则修改</code>即可</p>\n<h2 id=\"启动各个节点\"><a href=\"#启动各个节点\" class=\"headerlink\" title=\"启动各个节点\"></a>启动各个节点</h2><pre><code>##第一台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7000/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7001/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7002/redis.conf\n\n##第二台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7003/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7004/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7005/redis.conf \n\n##第三台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7006/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7007/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7008/redis.conf\n</code></pre><h2 id=\"检查各-Redis-启动情况\"><a href=\"#检查各-Redis-启动情况\" class=\"headerlink\" title=\"检查各 Redis 启动情况\"></a>检查各 Redis 启动情况</h2><pre><code>##第一台机器\n$ ps -ef | grep redis           //redis是否启动成功\n$ netstat -tnlp | grep redis    //监听redis端口\n</code></pre><p><img src=\"/img/bVJBUO\" alt=\"图片描述\"><br><code>注</code>：确保每个节点没有配置错误，并且启动起来</p>\n<h2 id=\"关闭防火墙\"><a href=\"#关闭防火墙\" class=\"headerlink\" title=\"关闭防火墙\"></a>关闭防火墙</h2><pre><code>$ firewall-cmd --state  ##查看防火墙状态\nrunning\n</code></pre><p><code>running</code> 说明防火墙是打开状态</p>\n<pre><code>$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running\n</code></pre><p><code>注</code>: <code>CentOS 7</code> 关闭防火墙与 <code>CentOS 6</code> 有所不同</p>\n<h2 id=\"安装-Ruby\"><a href=\"#安装-Ruby\" class=\"headerlink\" title=\"安装 Ruby\"></a>安装 Ruby</h2><pre><code>$ yum -y install ruby ruby-devel rubygems rpm-build\n$ gem install redis\n</code></pre><p><code>注</code>:<code>创建集群</code>时需要安装 <code>Ruby</code> 运行<code>redis-trib.rb</code></p>\n<h2 id=\"创建集群\"><a href=\"#创建集群\" class=\"headerlink\" title=\"创建集群\"></a>创建集群</h2><p><code>Redis</code> 官方提供了 <code>redis-trib.rb</code> 这个工具，就在解压目录的 <code>src</code> 目录中</p>\n<pre><code>$ /usr/local/redis-3.2.6/src/redis-trib.rb  create  --replicas  1  192.168.1.8:7000 192.168.1.8:7001  192.168.1.8:7002 192.168.1.9:7006  192.168.1.9:7004  192.168.1.9:7005 192.168.1.10:7006 192.168.1.10:7007 192.168.1.10:7008\n</code></pre><p>其中，前三个 <code>ip:port</code> 为第一台机器的节点，中间三个为第二台机器，最后三个为第三台机器<br><img src=\"/img/bVJBZL\" alt=\"图片描述\"><br> 输入 <code>yes</code>，然后出现如下内容，说明<code>安装成功</code><br><img src=\"/img/bVJBZZ\" alt=\"图片描述\"></p>\n<h2 id=\"集群验证\"><a href=\"#集群验证\" class=\"headerlink\" title=\"集群验证\"></a>集群验证</h2><p>在第一台机器上连接集群的<code>7000节点</code>，在另外一台连接<code>7004节点</code>，连接方式为：</p>\n<pre><code>##加参数 -C 可连接到集群，因为 redis.conf 将 bind 改为了ip地址，所以 -h 参数不可以省略，-p 参数为端口号\n$ /usr/local/redis-3.2.6/src/redis-cli -h 192.168.1.8 -c -p 7000\n</code></pre><p>在<code>7004节点</code>执行命令：</p>\n<pre><code>192.168.1.9:7004&gt; set name redis\n</code></pre><p><img src=\"/img/bVJB1e\" alt=\"图片描述\"></p>\n<p>然后在另两台<code>7000、7007端口</code>，查看 <code>key</code> 为 <code>name</code> 的内容</p>\n<pre><code>192.168.1.8:7000&gt; get name\n</code></pre><p><img src=\"/img/bVJB1V\" alt=\"图片描述\"></p>\n<pre><code>192.168.1.10:7007&gt; get name\n</code></pre><p><img src=\"/img/bVJB2c\" alt=\"图片描述\"></p>\n<p>说明<code>集群运作正常</code></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>redis cluster</code>在设计的时候，就考虑到了去<code>中心化</code>、<code>去中间件</code>，也就是说，集群中的<code>每个节点</code>都是<code>平等关系</code>，都是<code>对等的</code>，<code>每个节点</code>都<code>保存</code>各自的<code>数据</code>和整个集群的状态。<code>每个节点</code>都和<code>其他所有节点</code>连接，而且这些连接<code>保持活跃</code>，这样就保证了我们<code>只需要连接</code>集群中的<code>任意一个节点</code>，就可以获取到<code>其他节点</code>的<code>数据</code>。</p>\n<p><code>Redis</code> 集群没有并使用传统的<code>一致性哈希来</code>分配数据，而是采用另外一种叫做<code>哈希槽</code>(hash slot)的方式来分配的。<code>redis cluster</code> 默认分配了 <code>16384</code> 个 <code>slot</code>，当我们 <code>set</code>一个 <code>key</code> 时，会用<code>CRC16算法</code>来取模得到所属的 <code>slot</code>，然后将这个 <code>key</code> 分到<code>哈希槽区间的节点</code>上，具体算法就是：<code>CRC16(key)</code> % <code>16384</code>。所以我们在测试的时候看到 <code>set</code> 和 <code>get</code> 的时候，直接跳转到了<code>7000端口</code>的节点。</p>\n<p><code>Redis</code> 集群会把数据存在一个 <code>master</code> 节点，然后在这个 <code>master</code> 和其对应的 <code>salve</code> 之间进行数据同步。当读取数据时，也根据<code>一致性哈希算法</code>到对应的 <code>master</code> 节点获取数据。只有当一个 <code>master</code> 挂掉之后，才会启动一个对应的 <code>salve</code> 节点，充当 <code>master</code> 。</p>\n<p>需要注意的是：必须要<code>3个</code>或<code>以上</code>的<code>主节点</code>，否则在<code>创建集群</code>时会<code>失败</code>，并且当<code>存活</code>的<code>主节点数</code>小于<code>总节点数</code>的<code>一半</code>时，整个<code>集群</code>就<code>无法提供服务</code>了。</p>\n<hr>\n<p><strong>相关文档：</strong><br>中文：<a href=\"http://www.redis.cn/topics/cluster-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.redis.cn/topics/cluster-tutorial.html</a><br>英文：<a href=\"https://redis.io/topics/cluster-tutorial\" target=\"_blank\" rel=\"noopener\">https://redis.io/topics/cluster-tutorial</a></p>\n<hr>\n<p><strong>相关链接：</strong><br><a href=\"https://segmentfault.com/a/1190000008420258\" target=\"_blank\" rel=\"noopener\">Linux下PHP安装Redis扩展（二）</a><br><a href=\"https://segmentfault.com/a/1190000008469182\" target=\"_blank\" rel=\"noopener\">Redis主从配置（三）</a><br><a href=\"https://segmentfault.com/a/1190000008639459\" target=\"_blank\" rel=\"noopener\">Redis持久化（五）</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>VMware版本号：12.0.0 </li>\n<li>CentOS版本：7.0</li>\n<li>三台虚拟机(IP)：192.168.1.8、192.168.1.9、192.168.1.10<br><img src=\"/img/bVJBNY\" alt=\"图片描述\"></li>\n</ul>\n<h2 id=\"安装-Redis\"><a href=\"#安装-Redis\" class=\"headerlink\" title=\"安装 Redis \"></a>安装 Redis </h2><p>下载，解压，编译:</p>\n<pre><code>$ cd /usr/local/\n$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ cd redis-3.2.6\n$ make\n</code></pre><h2 id=\"创建-Redis-节点\"><a href=\"#创建-Redis-节点\" class=\"headerlink\" title=\"创建 Redis 节点\"></a>创建 Redis 节点</h2><p>首先在 <code>192.168.1.8</code> 机器上 <code>/usr/local/redis-3.2.6</code> 目录下创建 <code>redis_cluster</code> 目录</p>\n<pre><code>$ mkdir /usr/local/redis-3.2.6/redis_cluster\n</code></pre><p>在 <code>redis_cluster</code> 目录下，创建名为<code>7000</code>、<code>7001</code>、<code>7002</code>的目录，并将 <code>redis.conf</code> 拷贝到这三个目录中</p>\n<pre><code>$ mkdir 7000 7001 7002\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7000\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7001\n$ cp /usr/local/redis-3.2.6/redis.conf /usr/local/redis-3.2.6/redis_cluster/7002\n</code></pre><p>分别修改这<code>三个配置文件</code>，修改如下内容</p>\n<pre><code>port                  7000                        //端口7000,7002,7003        \nbind                  本机ip                      //默认ip为127.0.0.1，需要改为其他节点机器可访问的ip，否则创建集群时无法访问对应的端口，无法创建集群\ndaemonize             yes                         //redis后台运行\npidfile               /var/run/redis_7000.pid     //pidfile文件对应7000，7001，7002\ncluster-enabled       yes                         //开启集群，把注释#去掉\ncluster-config-file   nodes_7000.conf             //集群的配置，配置文件首次启动自动生成 7000，7001，7002\ncluster-node-timeout  15000                       //请求超时，默认15秒，可自行设置\nappendonly            yes                         //aof日志开启，有需要就开启，它会每次写操作都记录一条日志\n</code></pre><p>接着在另外两台机器上(<code>192.168.1.9</code>、<code>192.168.1.10</code>)重复以上三步，只是把目录改为<code>7003、7004、7005、7006、7007、7008</code>对应的<code>配置文件</code>也按照这个<code>规则修改</code>即可</p>\n<h2 id=\"启动各个节点\"><a href=\"#启动各个节点\" class=\"headerlink\" title=\"启动各个节点\"></a>启动各个节点</h2><pre><code>##第一台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7000/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7001/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7002/redis.conf\n\n##第二台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7003/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7004/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7005/redis.conf \n\n##第三台机器上执行\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7006/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7007/redis.conf\n$ /usr/local/redis-3.2.6/src/redis-server /usr/local/redis-3.2.6/redis_cluster/7008/redis.conf\n</code></pre><h2 id=\"检查各-Redis-启动情况\"><a href=\"#检查各-Redis-启动情况\" class=\"headerlink\" title=\"检查各 Redis 启动情况\"></a>检查各 Redis 启动情况</h2><pre><code>##第一台机器\n$ ps -ef | grep redis           //redis是否启动成功\n$ netstat -tnlp | grep redis    //监听redis端口\n</code></pre><p><img src=\"/img/bVJBUO\" alt=\"图片描述\"><br><code>注</code>：确保每个节点没有配置错误，并且启动起来</p>\n<h2 id=\"关闭防火墙\"><a href=\"#关闭防火墙\" class=\"headerlink\" title=\"关闭防火墙\"></a>关闭防火墙</h2><pre><code>$ firewall-cmd --state  ##查看防火墙状态\nrunning\n</code></pre><p><code>running</code> 说明防火墙是打开状态</p>\n<pre><code>$ systemctl stop firewalld  ##关闭防火墙\n$ firewall-cmd --state\nnot running\n</code></pre><p><code>注</code>: <code>CentOS 7</code> 关闭防火墙与 <code>CentOS 6</code> 有所不同</p>\n<h2 id=\"安装-Ruby\"><a href=\"#安装-Ruby\" class=\"headerlink\" title=\"安装 Ruby\"></a>安装 Ruby</h2><pre><code>$ yum -y install ruby ruby-devel rubygems rpm-build\n$ gem install redis\n</code></pre><p><code>注</code>:<code>创建集群</code>时需要安装 <code>Ruby</code> 运行<code>redis-trib.rb</code></p>\n<h2 id=\"创建集群\"><a href=\"#创建集群\" class=\"headerlink\" title=\"创建集群\"></a>创建集群</h2><p><code>Redis</code> 官方提供了 <code>redis-trib.rb</code> 这个工具，就在解压目录的 <code>src</code> 目录中</p>\n<pre><code>$ /usr/local/redis-3.2.6/src/redis-trib.rb  create  --replicas  1  192.168.1.8:7000 192.168.1.8:7001  192.168.1.8:7002 192.168.1.9:7006  192.168.1.9:7004  192.168.1.9:7005 192.168.1.10:7006 192.168.1.10:7007 192.168.1.10:7008\n</code></pre><p>其中，前三个 <code>ip:port</code> 为第一台机器的节点，中间三个为第二台机器，最后三个为第三台机器<br><img src=\"/img/bVJBZL\" alt=\"图片描述\"><br> 输入 <code>yes</code>，然后出现如下内容，说明<code>安装成功</code><br><img src=\"/img/bVJBZZ\" alt=\"图片描述\"></p>\n<h2 id=\"集群验证\"><a href=\"#集群验证\" class=\"headerlink\" title=\"集群验证\"></a>集群验证</h2><p>在第一台机器上连接集群的<code>7000节点</code>，在另外一台连接<code>7004节点</code>，连接方式为：</p>\n<pre><code>##加参数 -C 可连接到集群，因为 redis.conf 将 bind 改为了ip地址，所以 -h 参数不可以省略，-p 参数为端口号\n$ /usr/local/redis-3.2.6/src/redis-cli -h 192.168.1.8 -c -p 7000\n</code></pre><p>在<code>7004节点</code>执行命令：</p>\n<pre><code>192.168.1.9:7004&gt; set name redis\n</code></pre><p><img src=\"/img/bVJB1e\" alt=\"图片描述\"></p>\n<p>然后在另两台<code>7000、7007端口</code>，查看 <code>key</code> 为 <code>name</code> 的内容</p>\n<pre><code>192.168.1.8:7000&gt; get name\n</code></pre><p><img src=\"/img/bVJB1V\" alt=\"图片描述\"></p>\n<pre><code>192.168.1.10:7007&gt; get name\n</code></pre><p><img src=\"/img/bVJB2c\" alt=\"图片描述\"></p>\n<p>说明<code>集群运作正常</code></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>redis cluster</code>在设计的时候，就考虑到了去<code>中心化</code>、<code>去中间件</code>，也就是说，集群中的<code>每个节点</code>都是<code>平等关系</code>，都是<code>对等的</code>，<code>每个节点</code>都<code>保存</code>各自的<code>数据</code>和整个集群的状态。<code>每个节点</code>都和<code>其他所有节点</code>连接，而且这些连接<code>保持活跃</code>，这样就保证了我们<code>只需要连接</code>集群中的<code>任意一个节点</code>，就可以获取到<code>其他节点</code>的<code>数据</code>。</p>\n<p><code>Redis</code> 集群没有并使用传统的<code>一致性哈希来</code>分配数据，而是采用另外一种叫做<code>哈希槽</code>(hash slot)的方式来分配的。<code>redis cluster</code> 默认分配了 <code>16384</code> 个 <code>slot</code>，当我们 <code>set</code>一个 <code>key</code> 时，会用<code>CRC16算法</code>来取模得到所属的 <code>slot</code>，然后将这个 <code>key</code> 分到<code>哈希槽区间的节点</code>上，具体算法就是：<code>CRC16(key)</code> % <code>16384</code>。所以我们在测试的时候看到 <code>set</code> 和 <code>get</code> 的时候，直接跳转到了<code>7000端口</code>的节点。</p>\n<p><code>Redis</code> 集群会把数据存在一个 <code>master</code> 节点，然后在这个 <code>master</code> 和其对应的 <code>salve</code> 之间进行数据同步。当读取数据时，也根据<code>一致性哈希算法</code>到对应的 <code>master</code> 节点获取数据。只有当一个 <code>master</code> 挂掉之后，才会启动一个对应的 <code>salve</code> 节点，充当 <code>master</code> 。</p>\n<p>需要注意的是：必须要<code>3个</code>或<code>以上</code>的<code>主节点</code>，否则在<code>创建集群</code>时会<code>失败</code>，并且当<code>存活</code>的<code>主节点数</code>小于<code>总节点数</code>的<code>一半</code>时，整个<code>集群</code>就<code>无法提供服务</code>了。</p>\n<hr>\n<p><strong>相关文档：</strong><br>中文：<a href=\"http://www.redis.cn/topics/cluster-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.redis.cn/topics/cluster-tutorial.html</a><br>英文：<a href=\"https://redis.io/topics/cluster-tutorial\" target=\"_blank\" rel=\"noopener\">https://redis.io/topics/cluster-tutorial</a></p>\n<hr>\n<p><strong>相关链接：</strong><br><a href=\"https://segmentfault.com/a/1190000008420258\" target=\"_blank\" rel=\"noopener\">Linux下PHP安装Redis扩展（二）</a><br><a href=\"https://segmentfault.com/a/1190000008469182\" target=\"_blank\" rel=\"noopener\">Redis主从配置（三）</a><br><a href=\"https://segmentfault.com/a/1190000008639459\" target=\"_blank\" rel=\"noopener\">Redis持久化（五）</a></p>\n"},{"title":"Sublime一些问题的解决方法","date":"2017-02-19T22:26:10.000Z","_content":"##一、如何关闭Sublime的自动更新 ##\n\n打开`Sublime`，找到`Preferences - Settings`(配置文件)\n![图片描述][1]\n打开后类似这样\n![图片描述][2]\n\n在最后的花括号（`}`）前添加一句：\n\n    \"update_check\":false,\n\n## 二、关闭记住上次打开的文件 ##\n\n\n`同样的位置`(配置文件)中添加\n\n    \"hot_exit\": false,\n    \"remember_open_files\": false\n\n## 三、中文文件名显示方框 ##\n`老地方`(配置文件)添加\n```\n\"dpi_scale\":1.0\n```\n## 四、在GBK编码下的中文乱码问题 ##\n\n 1.安装`Package Control`\n 菜单 `View - Show Console` 或者 `Ctrl` + `~` 快捷键，调出 console，输入下面代码，按回车\n\n```\nimport urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())\n```\n\n2.关闭`Sublime`，重新打开\n\n3.`Ctrl` + `Shift`+ `p`打开命令行模式，输入`Install Package`关键字，然后点击自动出现的下拉菜单里的第一项：`Package Control: Install Package`\n\n4.左下角会有`=`号来回动，稍等一会，会再次在命令行下弹出一个下拉菜单。输入`ConvertToUTF8`或者`GBK Encoding Support`，选择匹配项。中文字符就可以正常显示了。\n\n \n\n  [1]: /img/bVGJsx\n  [2]: /img/bVGJsH","source":"_posts/Sublime一些问题的解决方法.md","raw":"---\ntitle: Sublime一些问题的解决方法\ndate: 2017-02-20 06:26:10\ntags:\n- Sublime\n---\n##一、如何关闭Sublime的自动更新 ##\n\n打开`Sublime`，找到`Preferences - Settings`(配置文件)\n![图片描述][1]\n打开后类似这样\n![图片描述][2]\n\n在最后的花括号（`}`）前添加一句：\n\n    \"update_check\":false,\n\n## 二、关闭记住上次打开的文件 ##\n\n\n`同样的位置`(配置文件)中添加\n\n    \"hot_exit\": false,\n    \"remember_open_files\": false\n\n## 三、中文文件名显示方框 ##\n`老地方`(配置文件)添加\n```\n\"dpi_scale\":1.0\n```\n## 四、在GBK编码下的中文乱码问题 ##\n\n 1.安装`Package Control`\n 菜单 `View - Show Console` 或者 `Ctrl` + `~` 快捷键，调出 console，输入下面代码，按回车\n\n```\nimport urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read())\n```\n\n2.关闭`Sublime`，重新打开\n\n3.`Ctrl` + `Shift`+ `p`打开命令行模式，输入`Install Package`关键字，然后点击自动出现的下拉菜单里的第一项：`Package Control: Install Package`\n\n4.左下角会有`=`号来回动，稍等一会，会再次在命令行下弹出一个下拉菜单。输入`ConvertToUTF8`或者`GBK Encoding Support`，选择匹配项。中文字符就可以正常显示了。\n\n \n\n  [1]: /img/bVGJsx\n  [2]: /img/bVGJsH","slug":"Sublime一些问题的解决方法","published":1,"updated":"2018-01-04T01:37:41.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyeru001nu8w6crk502yb","content":"<p>##一、如何关闭Sublime的自动更新 ##</p>\n<p>打开<code>Sublime</code>，找到<code>Preferences - Settings</code>(配置文件)<br><img src=\"/img/bVGJsx\" alt=\"图片描述\"><br>打开后类似这样<br><img src=\"/img/bVGJsH\" alt=\"图片描述\"></p>\n<p>在最后的花括号（<code>}</code>）前添加一句：</p>\n<pre><code>&quot;update_check&quot;:false,\n</code></pre><h2 id=\"二、关闭记住上次打开的文件\"><a href=\"#二、关闭记住上次打开的文件\" class=\"headerlink\" title=\"二、关闭记住上次打开的文件\"></a>二、关闭记住上次打开的文件</h2><p><code>同样的位置</code>(配置文件)中添加</p>\n<pre><code>&quot;hot_exit&quot;: false,\n&quot;remember_open_files&quot;: false\n</code></pre><h2 id=\"三、中文文件名显示方框\"><a href=\"#三、中文文件名显示方框\" class=\"headerlink\" title=\"三、中文文件名显示方框\"></a>三、中文文件名显示方框</h2><p><code>老地方</code>(配置文件)添加</p>\n<pre><code>&quot;dpi_scale&quot;:1.0\n</code></pre><h2 id=\"四、在GBK编码下的中文乱码问题\"><a href=\"#四、在GBK编码下的中文乱码问题\" class=\"headerlink\" title=\"四、在GBK编码下的中文乱码问题\"></a>四、在GBK编码下的中文乱码问题</h2><p> 1.安装<code>Package Control</code><br> 菜单 <code>View - Show Console</code> 或者 <code>Ctrl</code> + <code>~</code> 快捷键，调出 console，输入下面代码，按回车</p>\n<pre><code>import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())\n</code></pre><p>2.关闭<code>Sublime</code>，重新打开</p>\n<p>3.<code>Ctrl</code> + <code>Shift</code>+ <code>p</code>打开命令行模式，输入<code>Install Package</code>关键字，然后点击自动出现的下拉菜单里的第一项：<code>Package Control: Install Package</code></p>\n<p>4.左下角会有<code>=</code>号来回动，稍等一会，会再次在命令行下弹出一个下拉菜单。输入<code>ConvertToUTF8</code>或者<code>GBK Encoding Support</code>，选择匹配项。中文字符就可以正常显示了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##一、如何关闭Sublime的自动更新 ##</p>\n<p>打开<code>Sublime</code>，找到<code>Preferences - Settings</code>(配置文件)<br><img src=\"/img/bVGJsx\" alt=\"图片描述\"><br>打开后类似这样<br><img src=\"/img/bVGJsH\" alt=\"图片描述\"></p>\n<p>在最后的花括号（<code>}</code>）前添加一句：</p>\n<pre><code>&quot;update_check&quot;:false,\n</code></pre><h2 id=\"二、关闭记住上次打开的文件\"><a href=\"#二、关闭记住上次打开的文件\" class=\"headerlink\" title=\"二、关闭记住上次打开的文件\"></a>二、关闭记住上次打开的文件</h2><p><code>同样的位置</code>(配置文件)中添加</p>\n<pre><code>&quot;hot_exit&quot;: false,\n&quot;remember_open_files&quot;: false\n</code></pre><h2 id=\"三、中文文件名显示方框\"><a href=\"#三、中文文件名显示方框\" class=\"headerlink\" title=\"三、中文文件名显示方框\"></a>三、中文文件名显示方框</h2><p><code>老地方</code>(配置文件)添加</p>\n<pre><code>&quot;dpi_scale&quot;:1.0\n</code></pre><h2 id=\"四、在GBK编码下的中文乱码问题\"><a href=\"#四、在GBK编码下的中文乱码问题\" class=\"headerlink\" title=\"四、在GBK编码下的中文乱码问题\"></a>四、在GBK编码下的中文乱码问题</h2><p> 1.安装<code>Package Control</code><br> 菜单 <code>View - Show Console</code> 或者 <code>Ctrl</code> + <code>~</code> 快捷键，调出 console，输入下面代码，按回车</p>\n<pre><code>import urllib.request,os; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#39;wb&#39;).write(urllib.request.urlopen( &#39;http://sublime.wbond.net/&#39; + pf.replace(&#39; &#39;,&#39;%20&#39;)).read())\n</code></pre><p>2.关闭<code>Sublime</code>，重新打开</p>\n<p>3.<code>Ctrl</code> + <code>Shift</code>+ <code>p</code>打开命令行模式，输入<code>Install Package</code>关键字，然后点击自动出现的下拉菜单里的第一项：<code>Package Control: Install Package</code></p>\n<p>4.左下角会有<code>=</code>号来回动，稍等一会，会再次在命令行下弹出一个下拉菜单。输入<code>ConvertToUTF8</code>或者<code>GBK Encoding Support</code>，选择匹配项。中文字符就可以正常显示了。</p>\n"},{"title":"Hello World","date":"2017-02-10T21:59:57.000Z","_content":"折腾了几天终于用**Hexo**搭建好了一个博客，之前自己拿**ThinkPHP**写了一个，奈何前端CSS太渣，所以导致直接放弃原来的。本站用的是**Tinnypp**主题，教程也不写了，网上很多随便百度就能搜出很多。\n相关资料：\n- Hexo搭建的教程[1]\n- Hexo官方文档[2]\n- Hexo主题[3]\n\n[1]: http://www.jianshu.com/p/701b1095da11#\n[1]: https://hexo.io/zh-cn/docs/index.html\n[1]: https://hexo.io/themes/\n\n\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2017-02-11 05:59:57\ntags:\n---\n折腾了几天终于用**Hexo**搭建好了一个博客，之前自己拿**ThinkPHP**写了一个，奈何前端CSS太渣，所以导致直接放弃原来的。本站用的是**Tinnypp**主题，教程也不写了，网上很多随便百度就能搜出很多。\n相关资料：\n- Hexo搭建的教程[1]\n- Hexo官方文档[2]\n- Hexo主题[3]\n\n[1]: http://www.jianshu.com/p/701b1095da11#\n[1]: https://hexo.io/zh-cn/docs/index.html\n[1]: https://hexo.io/themes/\n\n\n\n","slug":"hello-world","published":1,"updated":"2018-01-04T01:37:41.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyerw001qu8w67x4y0z7r","content":"<p>折腾了几天终于用<strong>Hexo</strong>搭建好了一个博客，之前自己拿<strong>ThinkPHP</strong>写了一个，奈何前端CSS太渣，所以导致直接放弃原来的。本站用的是<strong>Tinnypp</strong>主题，教程也不写了，网上很多随便百度就能搜出很多。<br>相关资料：</p>\n<ul>\n<li>Hexo搭建的教程<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">1</a></li>\n<li>Hexo官方文档[2]</li>\n<li>Hexo主题[3]</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>折腾了几天终于用<strong>Hexo</strong>搭建好了一个博客，之前自己拿<strong>ThinkPHP</strong>写了一个，奈何前端CSS太渣，所以导致直接放弃原来的。本站用的是<strong>Tinnypp</strong>主题，教程也不写了，网上很多随便百度就能搜出很多。<br>相关资料：</p>\n<ul>\n<li>Hexo搭建的教程<a href=\"https://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">1</a></li>\n<li>Hexo官方文档[2]</li>\n<li>Hexo主题[3]</li>\n</ul>\n"},{"title":"yum 简单介绍","date":"2017-03-21T15:17:33.000Z","_content":"yum 简单介绍\n----------------\n`yum`（全称为 Yellow dog Updater, Modified）是一个在 `Fedora`和  `RedHat` 以及 `CentOS` 中的 `Shell` 前端软件包管理器。基于 `RPM` 包管理，能够从`指定`的服务器自动下载 `RPM` 包并且安装，可以`自动处理依赖`性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装\n\n`yum` 主要是更方便的添加、删除、更新RPM包，`自动解决`软件包之间的`依赖关系`，`方便系统更新`及`软件管理`。`yum` 通过软件仓库（repository）进行软件的下载、安装等，软件仓库可以是一个 HTTP 或 FTP 站点，也可以是一个本软件池，资源仓库也可以是多个，在 /etc/yum.conf 文件中进行相关配置即可。在yum的资源库中，会包括 `RPM` 的头信息（header），头信息中包括了软件的功能描述、依赖关系等。通过分析这些信息，`yum` 计算出依赖关系并进行相关的升级、安装、删除等操作\n\nyum 命令\n----------------\n\n命令格式：\n```\nyum [options] COMMAND\n```\n\n常用选项(options)列表：\n\n```\n-h, --help         #显示帮助信息\n-t, --tolerant     #容错\n-C, --cacheonly    #完全从系统缓存中运行，不更新缓存\n-c [config file], --config=[config file]      #本地配置文件\n-R [minutes], --randomwait=[minutes]          #命令最大等待时间\n-d [debug level], --debuglevel=[debug level]  #设置调试级别\n-e [error level], --errorlevel=[error level]  #设置错误等级\n-q, --quiet     #退出运行\n-v, --verbose   #详细模式\n-y, --assumeyes #对所有交互提问都回答 yes\n```\n命令(COMMAND)列表：\n\n```\ncheck         #检测 rpmdb 是否有问题\ncheck-update  #检查可更新的包\nclean         #清除缓存的数据\ndeplist       #显示包的依赖关系\ndistribution-synchronization  #将已安装的包同步到最新的可用版本\ndowngrade     #降级一个包\nerase         #删除包\ngroupinfo     #显示包组的详细信息\ngroupinstall  #安装指定的包组\ngrouplist     #显示可用包组信息\ngroupremove   #从系统删除已安装的包组\nhelp          #删除帮助信息\nhistory       #显示或使用交互历史\ninfo          #显示包或包组的详细信息\ninstall       #安装包\nlist          #显示可安装或可更新的包\nmakecache     #生成元数据缓存\nprovides      #搜索特定包文件名\nreinstall     #重新安装包\nrepolist      #显示已配置的资源库\nresolvedep    #指事实上依赖\nsearch        #搜索包\nshell         #进入yum的shell提示符\nupdate        #更新系统中的包\nupgrade       #升级系统中的包\nversion       #显示机器可用源的版本\n```\n`注`：以上可用命令和选项由于 `yum 版本`的不同可能会有所有`不同`\n\nyum 使用示例\n----------------\n1、安装方式：\n\n - 单独安装\n - 包组安装\n\n```\n# 安装软件包 foo\nyum install foo\n# 安装 Web server 软件包组\nyum groupinsall \"Web server\"\n```\n`注`：`groupinsall` 是一种快捷安装方式，他会将包组中所需的软件包一次性全部安装。如，上例中的 \"Web server\" 包组可能会包含： httpd、 crypto-utils 等软件包\n\n2、更新、升级\n对于已安装的程序，可以进行升级操作，有以下几种升级方式：\n\n```\n# 检查可用更新\nyum check-update \n# 全部更机关报\nyum update\n# 更新 foo 软件包\nyum update foo\n# 或\nyum upgrade foo\n# 升级 Web server 软件包组\nyum groupupdate \"Web server\"\n```\n更新安装包时，可以使用update或upgrade，二者区别如下：\n - yum update 是更新下载源里面的 metadata，包括这个源有什么包、每个包什么版本之类的\n - yum upgrade 会根据update后的元信息对软件包进行升级\n\n3、删除\n删除时，可以删除单个软件包或软件包组：\n\n```\n# 删除软件 foo\nyum remove foo\n# 删除 Web server 软件包组\nyum groupremove \"Web server\"\n```\n4、查找\n通过 `search` 命令可以查找软件包，而 `info` 命令可以用来显示`软件包信息`\n\n```\n# 查找名称包含 foo 的软件包\nyum search foo\n# 显示名为 foo 的软件包信息\nyum info foo\n# 显示软件包 foo 的依赖关系\nyum deplist foo\n# 显示软件包组 Web server 的信息\nyum groupinfo \"Web server\"\n# 显示已安装的软件包 \nyum list installed\n```\n\nyum 的配置\n----------------\n`yum` 的配置文件分为`main` 和`repository` ：\n 1. `main`:定义了`全局配置选项`，该文件只有一个。通常位于 `/etc/yum.conf`\n 2. `repository`:定义了`源服务器`的具体配置，可能是一或多个。通常位于 `/etc/yum.repo.d` 目录\n \n可以通过以下命令查看yum的配置：\n\n```\ncat /etc/yum.conf\n```\n\n主要配置项如下：\n\n```\n[main]\n# yum 的缓存目录，用于存储下载的 RPM 包和数据库\ncachedir=/var/cache/yum/$basearch/$releasever\n\n# 安装完成后是否保留软件包，0为不保留（默认为0），1为保留\nkeepcache=0\n   \n# Debug 信息输出等级，范围为0-10，默认为2\ndebuglevel=2\n\n# yum 日志文件位置，用户通过该文件查询做过的更新   \nlogfile=/var/log/yum.log\n   \n# 是否只安装和系统架构匹配的软件包。可选项为：1､0，默认为1\n# 设置为 1 时不会将 i686 的软件包安装在适合i386的系统中\nexactarch=1\n\n# update 设置，是否允许更新陈旧的 RPM 包，相当于 upgrade\nobsoletes=1\n   \n# 是否进行 GPG(GNU Private Guard) 校验，以确定 RPM 包的来源是有效和安全\n# 当在这个选项设置在[main]部分，则对每个 repository 都有效\nplugins=1\n\n# 是否启用插件，默认1为允许，0表示不允许\ngpgcheck=1\n   \n# 排除某些软件在升级名单之外，可以用通配符，各个项目用空格隔开\nexclude=*.i?86 kernel kernel-xen kernel-debug\n\n# 可同时安装多少程序包   \ninstallonly_limit=5\n\n# Bug 追踪路径   \nbugtracker_url=http://bugs.centos.org/set_project.php?project_id=16&ref=http://bugs.centos.org/bug_report_page.php?category=yum\n\n# 当前发行版版本号   \ndistroverpkg=centos-release\n```\n\n相关链接\n[CentOS更改yum源与更新系统][1]\n\n\n  [1]: http://www.zhazhablog.com/2017/03/07/CentOS%E6%9B%B4%E6%94%B9yum%E6%BA%90%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F/","source":"_posts/yum-简单介绍.md","raw":"---\ntitle: yum 简单介绍\ndate: 2017-03-21 23:17:33\ntags:\n- yum\ncategories:\n- Linux\n---\nyum 简单介绍\n----------------\n`yum`（全称为 Yellow dog Updater, Modified）是一个在 `Fedora`和  `RedHat` 以及 `CentOS` 中的 `Shell` 前端软件包管理器。基于 `RPM` 包管理，能够从`指定`的服务器自动下载 `RPM` 包并且安装，可以`自动处理依赖`性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装\n\n`yum` 主要是更方便的添加、删除、更新RPM包，`自动解决`软件包之间的`依赖关系`，`方便系统更新`及`软件管理`。`yum` 通过软件仓库（repository）进行软件的下载、安装等，软件仓库可以是一个 HTTP 或 FTP 站点，也可以是一个本软件池，资源仓库也可以是多个，在 /etc/yum.conf 文件中进行相关配置即可。在yum的资源库中，会包括 `RPM` 的头信息（header），头信息中包括了软件的功能描述、依赖关系等。通过分析这些信息，`yum` 计算出依赖关系并进行相关的升级、安装、删除等操作\n\nyum 命令\n----------------\n\n命令格式：\n```\nyum [options] COMMAND\n```\n\n常用选项(options)列表：\n\n```\n-h, --help         #显示帮助信息\n-t, --tolerant     #容错\n-C, --cacheonly    #完全从系统缓存中运行，不更新缓存\n-c [config file], --config=[config file]      #本地配置文件\n-R [minutes], --randomwait=[minutes]          #命令最大等待时间\n-d [debug level], --debuglevel=[debug level]  #设置调试级别\n-e [error level], --errorlevel=[error level]  #设置错误等级\n-q, --quiet     #退出运行\n-v, --verbose   #详细模式\n-y, --assumeyes #对所有交互提问都回答 yes\n```\n命令(COMMAND)列表：\n\n```\ncheck         #检测 rpmdb 是否有问题\ncheck-update  #检查可更新的包\nclean         #清除缓存的数据\ndeplist       #显示包的依赖关系\ndistribution-synchronization  #将已安装的包同步到最新的可用版本\ndowngrade     #降级一个包\nerase         #删除包\ngroupinfo     #显示包组的详细信息\ngroupinstall  #安装指定的包组\ngrouplist     #显示可用包组信息\ngroupremove   #从系统删除已安装的包组\nhelp          #删除帮助信息\nhistory       #显示或使用交互历史\ninfo          #显示包或包组的详细信息\ninstall       #安装包\nlist          #显示可安装或可更新的包\nmakecache     #生成元数据缓存\nprovides      #搜索特定包文件名\nreinstall     #重新安装包\nrepolist      #显示已配置的资源库\nresolvedep    #指事实上依赖\nsearch        #搜索包\nshell         #进入yum的shell提示符\nupdate        #更新系统中的包\nupgrade       #升级系统中的包\nversion       #显示机器可用源的版本\n```\n`注`：以上可用命令和选项由于 `yum 版本`的不同可能会有所有`不同`\n\nyum 使用示例\n----------------\n1、安装方式：\n\n - 单独安装\n - 包组安装\n\n```\n# 安装软件包 foo\nyum install foo\n# 安装 Web server 软件包组\nyum groupinsall \"Web server\"\n```\n`注`：`groupinsall` 是一种快捷安装方式，他会将包组中所需的软件包一次性全部安装。如，上例中的 \"Web server\" 包组可能会包含： httpd、 crypto-utils 等软件包\n\n2、更新、升级\n对于已安装的程序，可以进行升级操作，有以下几种升级方式：\n\n```\n# 检查可用更新\nyum check-update \n# 全部更机关报\nyum update\n# 更新 foo 软件包\nyum update foo\n# 或\nyum upgrade foo\n# 升级 Web server 软件包组\nyum groupupdate \"Web server\"\n```\n更新安装包时，可以使用update或upgrade，二者区别如下：\n - yum update 是更新下载源里面的 metadata，包括这个源有什么包、每个包什么版本之类的\n - yum upgrade 会根据update后的元信息对软件包进行升级\n\n3、删除\n删除时，可以删除单个软件包或软件包组：\n\n```\n# 删除软件 foo\nyum remove foo\n# 删除 Web server 软件包组\nyum groupremove \"Web server\"\n```\n4、查找\n通过 `search` 命令可以查找软件包，而 `info` 命令可以用来显示`软件包信息`\n\n```\n# 查找名称包含 foo 的软件包\nyum search foo\n# 显示名为 foo 的软件包信息\nyum info foo\n# 显示软件包 foo 的依赖关系\nyum deplist foo\n# 显示软件包组 Web server 的信息\nyum groupinfo \"Web server\"\n# 显示已安装的软件包 \nyum list installed\n```\n\nyum 的配置\n----------------\n`yum` 的配置文件分为`main` 和`repository` ：\n 1. `main`:定义了`全局配置选项`，该文件只有一个。通常位于 `/etc/yum.conf`\n 2. `repository`:定义了`源服务器`的具体配置，可能是一或多个。通常位于 `/etc/yum.repo.d` 目录\n \n可以通过以下命令查看yum的配置：\n\n```\ncat /etc/yum.conf\n```\n\n主要配置项如下：\n\n```\n[main]\n# yum 的缓存目录，用于存储下载的 RPM 包和数据库\ncachedir=/var/cache/yum/$basearch/$releasever\n\n# 安装完成后是否保留软件包，0为不保留（默认为0），1为保留\nkeepcache=0\n   \n# Debug 信息输出等级，范围为0-10，默认为2\ndebuglevel=2\n\n# yum 日志文件位置，用户通过该文件查询做过的更新   \nlogfile=/var/log/yum.log\n   \n# 是否只安装和系统架构匹配的软件包。可选项为：1､0，默认为1\n# 设置为 1 时不会将 i686 的软件包安装在适合i386的系统中\nexactarch=1\n\n# update 设置，是否允许更新陈旧的 RPM 包，相当于 upgrade\nobsoletes=1\n   \n# 是否进行 GPG(GNU Private Guard) 校验，以确定 RPM 包的来源是有效和安全\n# 当在这个选项设置在[main]部分，则对每个 repository 都有效\nplugins=1\n\n# 是否启用插件，默认1为允许，0表示不允许\ngpgcheck=1\n   \n# 排除某些软件在升级名单之外，可以用通配符，各个项目用空格隔开\nexclude=*.i?86 kernel kernel-xen kernel-debug\n\n# 可同时安装多少程序包   \ninstallonly_limit=5\n\n# Bug 追踪路径   \nbugtracker_url=http://bugs.centos.org/set_project.php?project_id=16&ref=http://bugs.centos.org/bug_report_page.php?category=yum\n\n# 当前发行版版本号   \ndistroverpkg=centos-release\n```\n\n相关链接\n[CentOS更改yum源与更新系统][1]\n\n\n  [1]: http://www.zhazhablog.com/2017/03/07/CentOS%E6%9B%B4%E6%94%B9yum%E6%BA%90%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F/","slug":"yum-简单介绍","published":1,"updated":"2018-01-03T02:37:16.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyerz001uu8w6vze25s7m","content":"<h2 id=\"yum-简单介绍\"><a href=\"#yum-简单介绍\" class=\"headerlink\" title=\"yum 简单介绍\"></a>yum 简单介绍</h2><p><code>yum</code>（全称为 Yellow dog Updater, Modified）是一个在 <code>Fedora</code>和  <code>RedHat</code> 以及 <code>CentOS</code> 中的 <code>Shell</code> 前端软件包管理器。基于 <code>RPM</code> 包管理，能够从<code>指定</code>的服务器自动下载 <code>RPM</code> 包并且安装，可以<code>自动处理依赖</code>性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装</p>\n<p><code>yum</code> 主要是更方便的添加、删除、更新RPM包，<code>自动解决</code>软件包之间的<code>依赖关系</code>，<code>方便系统更新</code>及<code>软件管理</code>。<code>yum</code> 通过软件仓库（repository）进行软件的下载、安装等，软件仓库可以是一个 HTTP 或 FTP 站点，也可以是一个本软件池，资源仓库也可以是多个，在 /etc/yum.conf 文件中进行相关配置即可。在yum的资源库中，会包括 <code>RPM</code> 的头信息（header），头信息中包括了软件的功能描述、依赖关系等。通过分析这些信息，<code>yum</code> 计算出依赖关系并进行相关的升级、安装、删除等操作</p>\n<h2 id=\"yum-命令\"><a href=\"#yum-命令\" class=\"headerlink\" title=\"yum 命令\"></a>yum 命令</h2><p>命令格式：</p>\n<pre><code>yum [options] COMMAND\n</code></pre><p>常用选项(options)列表：</p>\n<pre><code>-h, --help         #显示帮助信息\n-t, --tolerant     #容错\n-C, --cacheonly    #完全从系统缓存中运行，不更新缓存\n-c [config file], --config=[config file]      #本地配置文件\n-R [minutes], --randomwait=[minutes]          #命令最大等待时间\n-d [debug level], --debuglevel=[debug level]  #设置调试级别\n-e [error level], --errorlevel=[error level]  #设置错误等级\n-q, --quiet     #退出运行\n-v, --verbose   #详细模式\n-y, --assumeyes #对所有交互提问都回答 yes\n</code></pre><p>命令(COMMAND)列表：</p>\n<pre><code>check         #检测 rpmdb 是否有问题\ncheck-update  #检查可更新的包\nclean         #清除缓存的数据\ndeplist       #显示包的依赖关系\ndistribution-synchronization  #将已安装的包同步到最新的可用版本\ndowngrade     #降级一个包\nerase         #删除包\ngroupinfo     #显示包组的详细信息\ngroupinstall  #安装指定的包组\ngrouplist     #显示可用包组信息\ngroupremove   #从系统删除已安装的包组\nhelp          #删除帮助信息\nhistory       #显示或使用交互历史\ninfo          #显示包或包组的详细信息\ninstall       #安装包\nlist          #显示可安装或可更新的包\nmakecache     #生成元数据缓存\nprovides      #搜索特定包文件名\nreinstall     #重新安装包\nrepolist      #显示已配置的资源库\nresolvedep    #指事实上依赖\nsearch        #搜索包\nshell         #进入yum的shell提示符\nupdate        #更新系统中的包\nupgrade       #升级系统中的包\nversion       #显示机器可用源的版本\n</code></pre><p><code>注</code>：以上可用命令和选项由于 <code>yum 版本</code>的不同可能会有所有<code>不同</code></p>\n<h2 id=\"yum-使用示例\"><a href=\"#yum-使用示例\" class=\"headerlink\" title=\"yum 使用示例\"></a>yum 使用示例</h2><p>1、安装方式：</p>\n<ul>\n<li>单独安装</li>\n<li>包组安装</li>\n</ul>\n<pre><code># 安装软件包 foo\nyum install foo\n# 安装 Web server 软件包组\nyum groupinsall &quot;Web server&quot;\n</code></pre><p><code>注</code>：<code>groupinsall</code> 是一种快捷安装方式，他会将包组中所需的软件包一次性全部安装。如，上例中的 “Web server” 包组可能会包含： httpd、 crypto-utils 等软件包</p>\n<p>2、更新、升级<br>对于已安装的程序，可以进行升级操作，有以下几种升级方式：</p>\n<pre><code># 检查可用更新\nyum check-update \n# 全部更机关报\nyum update\n# 更新 foo 软件包\nyum update foo\n# 或\nyum upgrade foo\n# 升级 Web server 软件包组\nyum groupupdate &quot;Web server&quot;\n</code></pre><p>更新安装包时，可以使用update或upgrade，二者区别如下：</p>\n<ul>\n<li>yum update 是更新下载源里面的 metadata，包括这个源有什么包、每个包什么版本之类的</li>\n<li>yum upgrade 会根据update后的元信息对软件包进行升级</li>\n</ul>\n<p>3、删除<br>删除时，可以删除单个软件包或软件包组：</p>\n<pre><code># 删除软件 foo\nyum remove foo\n# 删除 Web server 软件包组\nyum groupremove &quot;Web server&quot;\n</code></pre><p>4、查找<br>通过 <code>search</code> 命令可以查找软件包，而 <code>info</code> 命令可以用来显示<code>软件包信息</code></p>\n<pre><code># 查找名称包含 foo 的软件包\nyum search foo\n# 显示名为 foo 的软件包信息\nyum info foo\n# 显示软件包 foo 的依赖关系\nyum deplist foo\n# 显示软件包组 Web server 的信息\nyum groupinfo &quot;Web server&quot;\n# 显示已安装的软件包 \nyum list installed\n</code></pre><h2 id=\"yum-的配置\"><a href=\"#yum-的配置\" class=\"headerlink\" title=\"yum 的配置\"></a>yum 的配置</h2><p><code>yum</code> 的配置文件分为<code>main</code> 和<code>repository</code> ：</p>\n<ol>\n<li><code>main</code>:定义了<code>全局配置选项</code>，该文件只有一个。通常位于 <code>/etc/yum.conf</code></li>\n<li><code>repository</code>:定义了<code>源服务器</code>的具体配置，可能是一或多个。通常位于 <code>/etc/yum.repo.d</code> 目录</li>\n</ol>\n<p>可以通过以下命令查看yum的配置：</p>\n<pre><code>cat /etc/yum.conf\n</code></pre><p>主要配置项如下：</p>\n<pre><code>[main]\n# yum 的缓存目录，用于存储下载的 RPM 包和数据库\ncachedir=/var/cache/yum/$basearch/$releasever\n\n# 安装完成后是否保留软件包，0为不保留（默认为0），1为保留\nkeepcache=0\n\n# Debug 信息输出等级，范围为0-10，默认为2\ndebuglevel=2\n\n# yum 日志文件位置，用户通过该文件查询做过的更新   \nlogfile=/var/log/yum.log\n\n# 是否只安装和系统架构匹配的软件包。可选项为：1､0，默认为1\n# 设置为 1 时不会将 i686 的软件包安装在适合i386的系统中\nexactarch=1\n\n# update 设置，是否允许更新陈旧的 RPM 包，相当于 upgrade\nobsoletes=1\n\n# 是否进行 GPG(GNU Private Guard) 校验，以确定 RPM 包的来源是有效和安全\n# 当在这个选项设置在[main]部分，则对每个 repository 都有效\nplugins=1\n\n# 是否启用插件，默认1为允许，0表示不允许\ngpgcheck=1\n\n# 排除某些软件在升级名单之外，可以用通配符，各个项目用空格隔开\nexclude=*.i?86 kernel kernel-xen kernel-debug\n\n# 可同时安装多少程序包   \ninstallonly_limit=5\n\n# Bug 追踪路径   \nbugtracker_url=http://bugs.centos.org/set_project.php?project_id=16&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yum\n\n# 当前发行版版本号   \ndistroverpkg=centos-release\n</code></pre><p>相关链接<br><a href=\"http://www.zhazhablog.com/2017/03/07/CentOS%E6%9B%B4%E6%94%B9yum%E6%BA%90%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F/\" target=\"_blank\" rel=\"noopener\">CentOS更改yum源与更新系统</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"yum-简单介绍\"><a href=\"#yum-简单介绍\" class=\"headerlink\" title=\"yum 简单介绍\"></a>yum 简单介绍</h2><p><code>yum</code>（全称为 Yellow dog Updater, Modified）是一个在 <code>Fedora</code>和  <code>RedHat</code> 以及 <code>CentOS</code> 中的 <code>Shell</code> 前端软件包管理器。基于 <code>RPM</code> 包管理，能够从<code>指定</code>的服务器自动下载 <code>RPM</code> 包并且安装，可以<code>自动处理依赖</code>性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装</p>\n<p><code>yum</code> 主要是更方便的添加、删除、更新RPM包，<code>自动解决</code>软件包之间的<code>依赖关系</code>，<code>方便系统更新</code>及<code>软件管理</code>。<code>yum</code> 通过软件仓库（repository）进行软件的下载、安装等，软件仓库可以是一个 HTTP 或 FTP 站点，也可以是一个本软件池，资源仓库也可以是多个，在 /etc/yum.conf 文件中进行相关配置即可。在yum的资源库中，会包括 <code>RPM</code> 的头信息（header），头信息中包括了软件的功能描述、依赖关系等。通过分析这些信息，<code>yum</code> 计算出依赖关系并进行相关的升级、安装、删除等操作</p>\n<h2 id=\"yum-命令\"><a href=\"#yum-命令\" class=\"headerlink\" title=\"yum 命令\"></a>yum 命令</h2><p>命令格式：</p>\n<pre><code>yum [options] COMMAND\n</code></pre><p>常用选项(options)列表：</p>\n<pre><code>-h, --help         #显示帮助信息\n-t, --tolerant     #容错\n-C, --cacheonly    #完全从系统缓存中运行，不更新缓存\n-c [config file], --config=[config file]      #本地配置文件\n-R [minutes], --randomwait=[minutes]          #命令最大等待时间\n-d [debug level], --debuglevel=[debug level]  #设置调试级别\n-e [error level], --errorlevel=[error level]  #设置错误等级\n-q, --quiet     #退出运行\n-v, --verbose   #详细模式\n-y, --assumeyes #对所有交互提问都回答 yes\n</code></pre><p>命令(COMMAND)列表：</p>\n<pre><code>check         #检测 rpmdb 是否有问题\ncheck-update  #检查可更新的包\nclean         #清除缓存的数据\ndeplist       #显示包的依赖关系\ndistribution-synchronization  #将已安装的包同步到最新的可用版本\ndowngrade     #降级一个包\nerase         #删除包\ngroupinfo     #显示包组的详细信息\ngroupinstall  #安装指定的包组\ngrouplist     #显示可用包组信息\ngroupremove   #从系统删除已安装的包组\nhelp          #删除帮助信息\nhistory       #显示或使用交互历史\ninfo          #显示包或包组的详细信息\ninstall       #安装包\nlist          #显示可安装或可更新的包\nmakecache     #生成元数据缓存\nprovides      #搜索特定包文件名\nreinstall     #重新安装包\nrepolist      #显示已配置的资源库\nresolvedep    #指事实上依赖\nsearch        #搜索包\nshell         #进入yum的shell提示符\nupdate        #更新系统中的包\nupgrade       #升级系统中的包\nversion       #显示机器可用源的版本\n</code></pre><p><code>注</code>：以上可用命令和选项由于 <code>yum 版本</code>的不同可能会有所有<code>不同</code></p>\n<h2 id=\"yum-使用示例\"><a href=\"#yum-使用示例\" class=\"headerlink\" title=\"yum 使用示例\"></a>yum 使用示例</h2><p>1、安装方式：</p>\n<ul>\n<li>单独安装</li>\n<li>包组安装</li>\n</ul>\n<pre><code># 安装软件包 foo\nyum install foo\n# 安装 Web server 软件包组\nyum groupinsall &quot;Web server&quot;\n</code></pre><p><code>注</code>：<code>groupinsall</code> 是一种快捷安装方式，他会将包组中所需的软件包一次性全部安装。如，上例中的 “Web server” 包组可能会包含： httpd、 crypto-utils 等软件包</p>\n<p>2、更新、升级<br>对于已安装的程序，可以进行升级操作，有以下几种升级方式：</p>\n<pre><code># 检查可用更新\nyum check-update \n# 全部更机关报\nyum update\n# 更新 foo 软件包\nyum update foo\n# 或\nyum upgrade foo\n# 升级 Web server 软件包组\nyum groupupdate &quot;Web server&quot;\n</code></pre><p>更新安装包时，可以使用update或upgrade，二者区别如下：</p>\n<ul>\n<li>yum update 是更新下载源里面的 metadata，包括这个源有什么包、每个包什么版本之类的</li>\n<li>yum upgrade 会根据update后的元信息对软件包进行升级</li>\n</ul>\n<p>3、删除<br>删除时，可以删除单个软件包或软件包组：</p>\n<pre><code># 删除软件 foo\nyum remove foo\n# 删除 Web server 软件包组\nyum groupremove &quot;Web server&quot;\n</code></pre><p>4、查找<br>通过 <code>search</code> 命令可以查找软件包，而 <code>info</code> 命令可以用来显示<code>软件包信息</code></p>\n<pre><code># 查找名称包含 foo 的软件包\nyum search foo\n# 显示名为 foo 的软件包信息\nyum info foo\n# 显示软件包 foo 的依赖关系\nyum deplist foo\n# 显示软件包组 Web server 的信息\nyum groupinfo &quot;Web server&quot;\n# 显示已安装的软件包 \nyum list installed\n</code></pre><h2 id=\"yum-的配置\"><a href=\"#yum-的配置\" class=\"headerlink\" title=\"yum 的配置\"></a>yum 的配置</h2><p><code>yum</code> 的配置文件分为<code>main</code> 和<code>repository</code> ：</p>\n<ol>\n<li><code>main</code>:定义了<code>全局配置选项</code>，该文件只有一个。通常位于 <code>/etc/yum.conf</code></li>\n<li><code>repository</code>:定义了<code>源服务器</code>的具体配置，可能是一或多个。通常位于 <code>/etc/yum.repo.d</code> 目录</li>\n</ol>\n<p>可以通过以下命令查看yum的配置：</p>\n<pre><code>cat /etc/yum.conf\n</code></pre><p>主要配置项如下：</p>\n<pre><code>[main]\n# yum 的缓存目录，用于存储下载的 RPM 包和数据库\ncachedir=/var/cache/yum/$basearch/$releasever\n\n# 安装完成后是否保留软件包，0为不保留（默认为0），1为保留\nkeepcache=0\n\n# Debug 信息输出等级，范围为0-10，默认为2\ndebuglevel=2\n\n# yum 日志文件位置，用户通过该文件查询做过的更新   \nlogfile=/var/log/yum.log\n\n# 是否只安装和系统架构匹配的软件包。可选项为：1､0，默认为1\n# 设置为 1 时不会将 i686 的软件包安装在适合i386的系统中\nexactarch=1\n\n# update 设置，是否允许更新陈旧的 RPM 包，相当于 upgrade\nobsoletes=1\n\n# 是否进行 GPG(GNU Private Guard) 校验，以确定 RPM 包的来源是有效和安全\n# 当在这个选项设置在[main]部分，则对每个 repository 都有效\nplugins=1\n\n# 是否启用插件，默认1为允许，0表示不允许\ngpgcheck=1\n\n# 排除某些软件在升级名单之外，可以用通配符，各个项目用空格隔开\nexclude=*.i?86 kernel kernel-xen kernel-debug\n\n# 可同时安装多少程序包   \ninstallonly_limit=5\n\n# Bug 追踪路径   \nbugtracker_url=http://bugs.centos.org/set_project.php?project_id=16&amp;ref=http://bugs.centos.org/bug_report_page.php?category=yum\n\n# 当前发行版版本号   \ndistroverpkg=centos-release\n</code></pre><p>相关链接<br><a href=\"http://www.zhazhablog.com/2017/03/07/CentOS%E6%9B%B4%E6%94%B9yum%E6%BA%90%E4%B8%8E%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F/\" target=\"_blank\" rel=\"noopener\">CentOS更改yum源与更新系统</a></p>\n"},{"title":"什么是Trait(性状)？","date":"2017-02-13T22:22:08.000Z","_content":"> 很多PHP开发朋友都没有弄清楚[Trait(性状)][1]。这是PHP5.4.0引入的新概念，既像`类`又像`接口`。\n> `性状`是`类`的`补分实现`(即常量、属性、方法)，可以混入`一个`或者`多个`现有的PHP类中。\n> `性状`有两个作用：表明类可以做什么(像是接口)；提供模块化实现(像是类)。\n> \n> `PHP`使用一种`典型的继承模型`，在这种模型中，我们`先编写一个通用的根类`，实现基本功能，然后扩展这个根类，创建更具体的类，从直接父类继承实现。这叫`继承层次结构`，很多编程语言都使用了这个模式\n> 大多时候，这种典型的继承模型能良好的运行，可是，如果想让两个无关的PHP类具有类似的行为，应该怎么做呢？\n\n\n**假如`Shop`和`Car`两个PHP类的作用十分不同，而且在`继承层次结构`中没有`共同的父类`。 那么这两个类都应该能使用地理编码技术转化成经纬度，然后在地图上显示。要怎么解决这个问题呢？**\n\n\n 1. 创建一个`父类`让`Shop`和`Car`都继承它\n\n 2. 创建一个`接口`，定义实现地理编码功能需要哪些方法，然后让`Shop`和`Car`两个类都实现这个接口\n\n 3. 创建一个`性状`，定义并实现地理编码相关的方法，然后把在`Shop`和`Car`两个类中混入这个性状\n\n第一种解决方法不好，因为我们强制让两个无关的类继承同一个祖先，而很明显，这个祖先不属于各自的继承层次结构。\n\n第二种解决方法好，因为每个类都能保有自然的继承层次结构。但是，我们要在两个类中重复实现的地理编码功能，这不符合`DRY原则`。\n**`注`**：`DRY`是 `Don't Repeat Yourself(不要自我重复)`的简称，表示不要在多个地方重复编写相同的代码，如果需要修改遵守这个原则编写的代码，只需要在一出修改，改动就能体现到其他地方。\n\n第三种解决方法最好，这么做不会搅乱这两个类原本自然的继承层次结构。\n\n\n----------\n\n### 如何创建性状？ ###\n\n```\ntrait Geocodable \n{\n\t// 这里是性状的实现\n}\n```\n### 如何使用性状？ ###\n\n```\nclass Shop\n{\n\tuse Geocodable;\n\n\t// 这里是类的实现\n}\n```\n\n\n----------\n### 例子 ###\n创建一个`Geocodable `性状\n```\ntrait Geocodable \n{\n\n\t/**\n    * 地址    \n    * @var string \n    */\n\tprotected $address;\n\n\t/**\n    * 编码器对象\n    * @var \\Geocoder\\Geocoder \n    */\n\tprotected $geocoder;\n\n\t/** \n    * 处理后结果对象\n    * @var \\Geocoder\\Result\\Geocoded \n    */\n\tprotected $geocoderResult;\n\n    //注入Geocoder对象\n\tpublic function setGeocoder(\\Geocoder\\GeocoderInterface $geocoder)\n\t{\n\t\t$this->geocoder = $geocoder;\n\t}\n\n    //设定地址\n\tpublic function setAddress($address)\n\t{\n\t\t$this->address = $address;\n\t}\n\n    //返回纬度\n\tpublic function getLatitude()\n\t{\n\t\tif (isset($this->geocoderResult) === false) {\n\t\t\t$this->geocodeAddress();\n\t\t}\n\n\t\treturn $this->geocoderResult->getLatitude();\n\t}\n\n    //返回经度\n\tpublic function getLongitude()\n\t{\n\t\tif (isset($this->geocoderResult) === false) {\n\t\t\t$this->geocodeAddress();\n\t\t}\n\n\t\treturn $this->geocoderResult->getLongitude();\n\t}\n    \n    //把地址字符串传给Geocoder实例，获取经地理编码器处理得到的结果\n\tprotected function geocodeAddress()\n\t{\n\t\t$this->geocoderResult = $this->geocoder->geocode($this->address);\n\n\t\treturn true;\n\t}\n}\n```\n\n**使用性状**\n```\n$geocoderAdapter = new \\Geocoder\\HttpAdapter\\CurlHttpAdapter();\n$geocoderAdapter = new \\Geocoder\\Provider\\GoogleMapsProvider($geocoderAdapter);\n$geocoder = new \\Geocoder\\Geocoder($geocoderProvider);\n\n$store = new Shop();\n$store->setAddress('420 9th Avenue, New York, NY 10001 USA');\n$store->setGeocoder($geocoder);\n\n$latiude   = $store->getLatitude();\n$longitude = $store->getLongitude();\necho $latitude, ':', $longitude;\n```\n\n\n  [1]: https://secure.php.net/manual/zh/language.oop5.traits.php\n  [2]: http://gecoder-php.org","source":"_posts/什么是Trait-性状-？.md","raw":"---\ntitle: 什么是Trait(性状)？\ndate: 2017-02-14 06:22:08\ntags:\n- Redis\n- yum\ncategories:\n- Linux\n---\n> 很多PHP开发朋友都没有弄清楚[Trait(性状)][1]。这是PHP5.4.0引入的新概念，既像`类`又像`接口`。\n> `性状`是`类`的`补分实现`(即常量、属性、方法)，可以混入`一个`或者`多个`现有的PHP类中。\n> `性状`有两个作用：表明类可以做什么(像是接口)；提供模块化实现(像是类)。\n> \n> `PHP`使用一种`典型的继承模型`，在这种模型中，我们`先编写一个通用的根类`，实现基本功能，然后扩展这个根类，创建更具体的类，从直接父类继承实现。这叫`继承层次结构`，很多编程语言都使用了这个模式\n> 大多时候，这种典型的继承模型能良好的运行，可是，如果想让两个无关的PHP类具有类似的行为，应该怎么做呢？\n\n\n**假如`Shop`和`Car`两个PHP类的作用十分不同，而且在`继承层次结构`中没有`共同的父类`。 那么这两个类都应该能使用地理编码技术转化成经纬度，然后在地图上显示。要怎么解决这个问题呢？**\n\n\n 1. 创建一个`父类`让`Shop`和`Car`都继承它\n\n 2. 创建一个`接口`，定义实现地理编码功能需要哪些方法，然后让`Shop`和`Car`两个类都实现这个接口\n\n 3. 创建一个`性状`，定义并实现地理编码相关的方法，然后把在`Shop`和`Car`两个类中混入这个性状\n\n第一种解决方法不好，因为我们强制让两个无关的类继承同一个祖先，而很明显，这个祖先不属于各自的继承层次结构。\n\n第二种解决方法好，因为每个类都能保有自然的继承层次结构。但是，我们要在两个类中重复实现的地理编码功能，这不符合`DRY原则`。\n**`注`**：`DRY`是 `Don't Repeat Yourself(不要自我重复)`的简称，表示不要在多个地方重复编写相同的代码，如果需要修改遵守这个原则编写的代码，只需要在一出修改，改动就能体现到其他地方。\n\n第三种解决方法最好，这么做不会搅乱这两个类原本自然的继承层次结构。\n\n\n----------\n\n### 如何创建性状？ ###\n\n```\ntrait Geocodable \n{\n\t// 这里是性状的实现\n}\n```\n### 如何使用性状？ ###\n\n```\nclass Shop\n{\n\tuse Geocodable;\n\n\t// 这里是类的实现\n}\n```\n\n\n----------\n### 例子 ###\n创建一个`Geocodable `性状\n```\ntrait Geocodable \n{\n\n\t/**\n    * 地址    \n    * @var string \n    */\n\tprotected $address;\n\n\t/**\n    * 编码器对象\n    * @var \\Geocoder\\Geocoder \n    */\n\tprotected $geocoder;\n\n\t/** \n    * 处理后结果对象\n    * @var \\Geocoder\\Result\\Geocoded \n    */\n\tprotected $geocoderResult;\n\n    //注入Geocoder对象\n\tpublic function setGeocoder(\\Geocoder\\GeocoderInterface $geocoder)\n\t{\n\t\t$this->geocoder = $geocoder;\n\t}\n\n    //设定地址\n\tpublic function setAddress($address)\n\t{\n\t\t$this->address = $address;\n\t}\n\n    //返回纬度\n\tpublic function getLatitude()\n\t{\n\t\tif (isset($this->geocoderResult) === false) {\n\t\t\t$this->geocodeAddress();\n\t\t}\n\n\t\treturn $this->geocoderResult->getLatitude();\n\t}\n\n    //返回经度\n\tpublic function getLongitude()\n\t{\n\t\tif (isset($this->geocoderResult) === false) {\n\t\t\t$this->geocodeAddress();\n\t\t}\n\n\t\treturn $this->geocoderResult->getLongitude();\n\t}\n    \n    //把地址字符串传给Geocoder实例，获取经地理编码器处理得到的结果\n\tprotected function geocodeAddress()\n\t{\n\t\t$this->geocoderResult = $this->geocoder->geocode($this->address);\n\n\t\treturn true;\n\t}\n}\n```\n\n**使用性状**\n```\n$geocoderAdapter = new \\Geocoder\\HttpAdapter\\CurlHttpAdapter();\n$geocoderAdapter = new \\Geocoder\\Provider\\GoogleMapsProvider($geocoderAdapter);\n$geocoder = new \\Geocoder\\Geocoder($geocoderProvider);\n\n$store = new Shop();\n$store->setAddress('420 9th Avenue, New York, NY 10001 USA');\n$store->setGeocoder($geocoder);\n\n$latiude   = $store->getLatitude();\n$longitude = $store->getLongitude();\necho $latitude, ':', $longitude;\n```\n\n\n  [1]: https://secure.php.net/manual/zh/language.oop5.traits.php\n  [2]: http://gecoder-php.org","slug":"什么是Trait-性状-？","published":1,"updated":"2018-01-04T01:37:41.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyes1001wu8w6lugj292z","content":"<blockquote>\n<p>很多PHP开发朋友都没有弄清楚<a href=\"https://secure.php.net/manual/zh/language.oop5.traits.php\" target=\"_blank\" rel=\"noopener\">Trait(性状)</a>。这是PHP5.4.0引入的新概念，既像<code>类</code>又像<code>接口</code>。<br><code>性状</code>是<code>类</code>的<code>补分实现</code>(即常量、属性、方法)，可以混入<code>一个</code>或者<code>多个</code>现有的PHP类中。<br><code>性状</code>有两个作用：表明类可以做什么(像是接口)；提供模块化实现(像是类)。</p>\n<p><code>PHP</code>使用一种<code>典型的继承模型</code>，在这种模型中，我们<code>先编写一个通用的根类</code>，实现基本功能，然后扩展这个根类，创建更具体的类，从直接父类继承实现。这叫<code>继承层次结构</code>，很多编程语言都使用了这个模式<br>大多时候，这种典型的继承模型能良好的运行，可是，如果想让两个无关的PHP类具有类似的行为，应该怎么做呢？</p>\n</blockquote>\n<p><strong>假如<code>Shop</code>和<code>Car</code>两个PHP类的作用十分不同，而且在<code>继承层次结构</code>中没有<code>共同的父类</code>。 那么这两个类都应该能使用地理编码技术转化成经纬度，然后在地图上显示。要怎么解决这个问题呢？</strong></p>\n<ol>\n<li><p>创建一个<code>父类</code>让<code>Shop</code>和<code>Car</code>都继承它</p>\n</li>\n<li><p>创建一个<code>接口</code>，定义实现地理编码功能需要哪些方法，然后让<code>Shop</code>和<code>Car</code>两个类都实现这个接口</p>\n</li>\n<li><p>创建一个<code>性状</code>，定义并实现地理编码相关的方法，然后把在<code>Shop</code>和<code>Car</code>两个类中混入这个性状</p>\n</li>\n</ol>\n<p>第一种解决方法不好，因为我们强制让两个无关的类继承同一个祖先，而很明显，这个祖先不属于各自的继承层次结构。</p>\n<p>第二种解决方法好，因为每个类都能保有自然的继承层次结构。但是，我们要在两个类中重复实现的地理编码功能，这不符合<code>DRY原则</code>。<br><strong><code>注</code></strong>：<code>DRY</code>是 <code>Don&#39;t Repeat Yourself(不要自我重复)</code>的简称，表示不要在多个地方重复编写相同的代码，如果需要修改遵守这个原则编写的代码，只需要在一出修改，改动就能体现到其他地方。</p>\n<p>第三种解决方法最好，这么做不会搅乱这两个类原本自然的继承层次结构。</p>\n<hr>\n<h3 id=\"如何创建性状？\"><a href=\"#如何创建性状？\" class=\"headerlink\" title=\"如何创建性状？\"></a>如何创建性状？</h3><pre><code>trait Geocodable \n{\n    // 这里是性状的实现\n}\n</code></pre><h3 id=\"如何使用性状？\"><a href=\"#如何使用性状？\" class=\"headerlink\" title=\"如何使用性状？\"></a>如何使用性状？</h3><pre><code>class Shop\n{\n    use Geocodable;\n\n    // 这里是类的实现\n}\n</code></pre><hr>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>创建一个<code>Geocodable</code>性状</p>\n<pre><code>trait Geocodable \n{\n\n    /**\n    * 地址    \n    * @var string \n    */\n    protected $address;\n\n    /**\n    * 编码器对象\n    * @var \\Geocoder\\Geocoder \n    */\n    protected $geocoder;\n\n    /** \n    * 处理后结果对象\n    * @var \\Geocoder\\Result\\Geocoded \n    */\n    protected $geocoderResult;\n\n    //注入Geocoder对象\n    public function setGeocoder(\\Geocoder\\GeocoderInterface $geocoder)\n    {\n        $this-&gt;geocoder = $geocoder;\n    }\n\n    //设定地址\n    public function setAddress($address)\n    {\n        $this-&gt;address = $address;\n    }\n\n    //返回纬度\n    public function getLatitude()\n    {\n        if (isset($this-&gt;geocoderResult) === false) {\n            $this-&gt;geocodeAddress();\n        }\n\n        return $this-&gt;geocoderResult-&gt;getLatitude();\n    }\n\n    //返回经度\n    public function getLongitude()\n    {\n        if (isset($this-&gt;geocoderResult) === false) {\n            $this-&gt;geocodeAddress();\n        }\n\n        return $this-&gt;geocoderResult-&gt;getLongitude();\n    }\n\n    //把地址字符串传给Geocoder实例，获取经地理编码器处理得到的结果\n    protected function geocodeAddress()\n    {\n        $this-&gt;geocoderResult = $this-&gt;geocoder-&gt;geocode($this-&gt;address);\n\n        return true;\n    }\n}\n</code></pre><p><strong>使用性状</strong></p>\n<pre><code>$geocoderAdapter = new \\Geocoder\\HttpAdapter\\CurlHttpAdapter();\n$geocoderAdapter = new \\Geocoder\\Provider\\GoogleMapsProvider($geocoderAdapter);\n$geocoder = new \\Geocoder\\Geocoder($geocoderProvider);\n\n$store = new Shop();\n$store-&gt;setAddress(&#39;420 9th Avenue, New York, NY 10001 USA&#39;);\n$store-&gt;setGeocoder($geocoder);\n\n$latiude   = $store-&gt;getLatitude();\n$longitude = $store-&gt;getLongitude();\necho $latitude, &#39;:&#39;, $longitude;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>很多PHP开发朋友都没有弄清楚<a href=\"https://secure.php.net/manual/zh/language.oop5.traits.php\" target=\"_blank\" rel=\"noopener\">Trait(性状)</a>。这是PHP5.4.0引入的新概念，既像<code>类</code>又像<code>接口</code>。<br><code>性状</code>是<code>类</code>的<code>补分实现</code>(即常量、属性、方法)，可以混入<code>一个</code>或者<code>多个</code>现有的PHP类中。<br><code>性状</code>有两个作用：表明类可以做什么(像是接口)；提供模块化实现(像是类)。</p>\n<p><code>PHP</code>使用一种<code>典型的继承模型</code>，在这种模型中，我们<code>先编写一个通用的根类</code>，实现基本功能，然后扩展这个根类，创建更具体的类，从直接父类继承实现。这叫<code>继承层次结构</code>，很多编程语言都使用了这个模式<br>大多时候，这种典型的继承模型能良好的运行，可是，如果想让两个无关的PHP类具有类似的行为，应该怎么做呢？</p>\n</blockquote>\n<p><strong>假如<code>Shop</code>和<code>Car</code>两个PHP类的作用十分不同，而且在<code>继承层次结构</code>中没有<code>共同的父类</code>。 那么这两个类都应该能使用地理编码技术转化成经纬度，然后在地图上显示。要怎么解决这个问题呢？</strong></p>\n<ol>\n<li><p>创建一个<code>父类</code>让<code>Shop</code>和<code>Car</code>都继承它</p>\n</li>\n<li><p>创建一个<code>接口</code>，定义实现地理编码功能需要哪些方法，然后让<code>Shop</code>和<code>Car</code>两个类都实现这个接口</p>\n</li>\n<li><p>创建一个<code>性状</code>，定义并实现地理编码相关的方法，然后把在<code>Shop</code>和<code>Car</code>两个类中混入这个性状</p>\n</li>\n</ol>\n<p>第一种解决方法不好，因为我们强制让两个无关的类继承同一个祖先，而很明显，这个祖先不属于各自的继承层次结构。</p>\n<p>第二种解决方法好，因为每个类都能保有自然的继承层次结构。但是，我们要在两个类中重复实现的地理编码功能，这不符合<code>DRY原则</code>。<br><strong><code>注</code></strong>：<code>DRY</code>是 <code>Don&#39;t Repeat Yourself(不要自我重复)</code>的简称，表示不要在多个地方重复编写相同的代码，如果需要修改遵守这个原则编写的代码，只需要在一出修改，改动就能体现到其他地方。</p>\n<p>第三种解决方法最好，这么做不会搅乱这两个类原本自然的继承层次结构。</p>\n<hr>\n<h3 id=\"如何创建性状？\"><a href=\"#如何创建性状？\" class=\"headerlink\" title=\"如何创建性状？\"></a>如何创建性状？</h3><pre><code>trait Geocodable \n{\n    // 这里是性状的实现\n}\n</code></pre><h3 id=\"如何使用性状？\"><a href=\"#如何使用性状？\" class=\"headerlink\" title=\"如何使用性状？\"></a>如何使用性状？</h3><pre><code>class Shop\n{\n    use Geocodable;\n\n    // 这里是类的实现\n}\n</code></pre><hr>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>创建一个<code>Geocodable</code>性状</p>\n<pre><code>trait Geocodable \n{\n\n    /**\n    * 地址    \n    * @var string \n    */\n    protected $address;\n\n    /**\n    * 编码器对象\n    * @var \\Geocoder\\Geocoder \n    */\n    protected $geocoder;\n\n    /** \n    * 处理后结果对象\n    * @var \\Geocoder\\Result\\Geocoded \n    */\n    protected $geocoderResult;\n\n    //注入Geocoder对象\n    public function setGeocoder(\\Geocoder\\GeocoderInterface $geocoder)\n    {\n        $this-&gt;geocoder = $geocoder;\n    }\n\n    //设定地址\n    public function setAddress($address)\n    {\n        $this-&gt;address = $address;\n    }\n\n    //返回纬度\n    public function getLatitude()\n    {\n        if (isset($this-&gt;geocoderResult) === false) {\n            $this-&gt;geocodeAddress();\n        }\n\n        return $this-&gt;geocoderResult-&gt;getLatitude();\n    }\n\n    //返回经度\n    public function getLongitude()\n    {\n        if (isset($this-&gt;geocoderResult) === false) {\n            $this-&gt;geocodeAddress();\n        }\n\n        return $this-&gt;geocoderResult-&gt;getLongitude();\n    }\n\n    //把地址字符串传给Geocoder实例，获取经地理编码器处理得到的结果\n    protected function geocodeAddress()\n    {\n        $this-&gt;geocoderResult = $this-&gt;geocoder-&gt;geocode($this-&gt;address);\n\n        return true;\n    }\n}\n</code></pre><p><strong>使用性状</strong></p>\n<pre><code>$geocoderAdapter = new \\Geocoder\\HttpAdapter\\CurlHttpAdapter();\n$geocoderAdapter = new \\Geocoder\\Provider\\GoogleMapsProvider($geocoderAdapter);\n$geocoder = new \\Geocoder\\Geocoder($geocoderProvider);\n\n$store = new Shop();\n$store-&gt;setAddress(&#39;420 9th Avenue, New York, NY 10001 USA&#39;);\n$store-&gt;setGeocoder($geocoder);\n\n$latiude   = $store-&gt;getLatitude();\n$longitude = $store-&gt;getLongitude();\necho $latitude, &#39;:&#39;, $longitude;\n</code></pre>"},{"title":"什么是接口？","date":"2017-02-19T15:08:15.000Z","_content":"> `接口`是两个PHP对象之间的契约，其目的`不是`让一个对象依赖另一个对象，`而是`依赖一个对象的能力。 \n> `接口`把我们的代码和依赖`解耦`了，而且允许我们的代码任何实现了预期接口的第三方代码。我们不管第三方代码是如何实现接口的，只关心第三方代码是否实现了指定的接口。\n\n\n----------\n\n\n定义一个`DocumentStore`类\n作用是从不同的源收集文本：可以从远程URL读取HTML，也可以读取流资源，也可以收集终端的输出\n\n```\nclass DocumentStore \n{\n\tprotected $data = [];\n\n\tpublic function addDocument(Documentable $document)\n\t{\n\t\t$key   = $document->getId();\n\t\t$value = $document->getContent();\n\t\t$this->data[$key] = $value;\n\t}\n\n\tpublic function getDocuments()\n\t{\n\t\treturn $this->data;\n\t}\t\n}\n```\n定义`Documentable`接口\n\n```\ninterface Documentable\n{\n\tpublic function getId();\n\tpublic function getContent();\n}\n```\n这个`接口`的定义表明，实现`Documentable`接口的任何对象必须提供一个公开的`getId()`和`getContent()`方法\n\n这么做的用处是，我们可以分开定义获取文档的类，而且使用十分不同的实现方法\n\n```\n//使用curl从远程URL获取HTML\nclass HtmlDocument implements Documentable\n{\n\tprotected $url;\n\n\tpublic function __construct($url)\n\t{\n\t\t$this->url = $url;\n\t}\n\n\tpublic function getId()\n\t{\n\t\treturn $this->url;\n\t}\n\n\tpublic function getContent()\n\t{\n\t\t$ch = curl_init();\n\t\tcurl_setopt($ch, CURLOPT_URL, $this->url);\n\t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\t\tcurl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3);\n\t\tcurl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n\t\tcurl_setopt($ch, CURLOPT_MAXREDIRS, 1);\n\t\t$html = curl_exec($ch);\n\t\tcurl_close($ch);\n\n\t\treturn $html;\n\t\n```\n\n```\n//读取资源流\nclass StreamDocument implements Documentable\n{\n\tprotected $resource;\n\tprotected $buffer;\n\n\tpublic function __construct($resource, $buffer = 4096)\n\t{\n\t\t$this->resource = $resource;\n\t\t$this->buffer = $buffer;\n\t}\n\n\tpublic function getId()\n\t{\n\t\treturn 'resource-' . (int)$this->resource;\n\t}\n\n\tpublic function getContent()\n\t{\n\t\t$streamContent = '';\n\t\trewind($this->resource);\n\t\twhile (feof($this->resource) == false) {\n\t\t\t$streamContent .= fread($this->resource, $this->buffer);\n\t\t}\n\n\t\treturn $streamContent;\n\t}\n}\n```\n\n```\n//获取终端命令的执行结果\nclass CommandOutputDocument implements Documentable\n{\n\tprotected $command;\n\n\tpublic function __construct($command)\n\t{\n\t\t$this->command = $command;\n\t}\n\n\tpublic function getId()\n\t{\n\t\treturn $this->command;\n\t}\n\n\tpublic function getContent()\n\t{\n\t\treturn shell_exec($this->command);\n\t}\n}\n```\n如何借助这三种收集文档的实现方法使用`DocumentStore`类呢？\n\n```\n$documentStore = new DocumentStore();\n\n//添加HTML文档\n$htmlDoc = new HtmlDocument('https://php.net');\n$documentStore->addDocument($htmlDoc);\n\n//添加流文档\n$streamDoc = new StreamDocument('stream.txt', 'rb');\n$documentStore->addDocument($streamDoc);\n\n//添加终端命令文档\n$cmdDoc = new CommandOutputDocument('cat /etc/hosts');\n$documentStore->addDocument($cmdDoc);\n\nprint_r($documentStore->getDocuments());\n```\n\n`HtmlDocument`、`StreamDocument`、`CommandOutputDocument`三个类没任何共同点，只是实现了一个接口\n\n\n\n\n\n","source":"_posts/什么是接口？.md","raw":"---\ntitle: 什么是接口？\ndate: 2017-02-19 23:08:15\ncategories:\n- PHP\n---\n> `接口`是两个PHP对象之间的契约，其目的`不是`让一个对象依赖另一个对象，`而是`依赖一个对象的能力。 \n> `接口`把我们的代码和依赖`解耦`了，而且允许我们的代码任何实现了预期接口的第三方代码。我们不管第三方代码是如何实现接口的，只关心第三方代码是否实现了指定的接口。\n\n\n----------\n\n\n定义一个`DocumentStore`类\n作用是从不同的源收集文本：可以从远程URL读取HTML，也可以读取流资源，也可以收集终端的输出\n\n```\nclass DocumentStore \n{\n\tprotected $data = [];\n\n\tpublic function addDocument(Documentable $document)\n\t{\n\t\t$key   = $document->getId();\n\t\t$value = $document->getContent();\n\t\t$this->data[$key] = $value;\n\t}\n\n\tpublic function getDocuments()\n\t{\n\t\treturn $this->data;\n\t}\t\n}\n```\n定义`Documentable`接口\n\n```\ninterface Documentable\n{\n\tpublic function getId();\n\tpublic function getContent();\n}\n```\n这个`接口`的定义表明，实现`Documentable`接口的任何对象必须提供一个公开的`getId()`和`getContent()`方法\n\n这么做的用处是，我们可以分开定义获取文档的类，而且使用十分不同的实现方法\n\n```\n//使用curl从远程URL获取HTML\nclass HtmlDocument implements Documentable\n{\n\tprotected $url;\n\n\tpublic function __construct($url)\n\t{\n\t\t$this->url = $url;\n\t}\n\n\tpublic function getId()\n\t{\n\t\treturn $this->url;\n\t}\n\n\tpublic function getContent()\n\t{\n\t\t$ch = curl_init();\n\t\tcurl_setopt($ch, CURLOPT_URL, $this->url);\n\t\tcurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n\t\tcurl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3);\n\t\tcurl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n\t\tcurl_setopt($ch, CURLOPT_MAXREDIRS, 1);\n\t\t$html = curl_exec($ch);\n\t\tcurl_close($ch);\n\n\t\treturn $html;\n\t\n```\n\n```\n//读取资源流\nclass StreamDocument implements Documentable\n{\n\tprotected $resource;\n\tprotected $buffer;\n\n\tpublic function __construct($resource, $buffer = 4096)\n\t{\n\t\t$this->resource = $resource;\n\t\t$this->buffer = $buffer;\n\t}\n\n\tpublic function getId()\n\t{\n\t\treturn 'resource-' . (int)$this->resource;\n\t}\n\n\tpublic function getContent()\n\t{\n\t\t$streamContent = '';\n\t\trewind($this->resource);\n\t\twhile (feof($this->resource) == false) {\n\t\t\t$streamContent .= fread($this->resource, $this->buffer);\n\t\t}\n\n\t\treturn $streamContent;\n\t}\n}\n```\n\n```\n//获取终端命令的执行结果\nclass CommandOutputDocument implements Documentable\n{\n\tprotected $command;\n\n\tpublic function __construct($command)\n\t{\n\t\t$this->command = $command;\n\t}\n\n\tpublic function getId()\n\t{\n\t\treturn $this->command;\n\t}\n\n\tpublic function getContent()\n\t{\n\t\treturn shell_exec($this->command);\n\t}\n}\n```\n如何借助这三种收集文档的实现方法使用`DocumentStore`类呢？\n\n```\n$documentStore = new DocumentStore();\n\n//添加HTML文档\n$htmlDoc = new HtmlDocument('https://php.net');\n$documentStore->addDocument($htmlDoc);\n\n//添加流文档\n$streamDoc = new StreamDocument('stream.txt', 'rb');\n$documentStore->addDocument($streamDoc);\n\n//添加终端命令文档\n$cmdDoc = new CommandOutputDocument('cat /etc/hosts');\n$documentStore->addDocument($cmdDoc);\n\nprint_r($documentStore->getDocuments());\n```\n\n`HtmlDocument`、`StreamDocument`、`CommandOutputDocument`三个类没任何共同点，只是实现了一个接口\n\n\n\n\n\n","slug":"什么是接口？","published":1,"updated":"2018-01-04T01:37:41.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyes40020u8w6wjbpn6xq","content":"<blockquote>\n<p><code>接口</code>是两个PHP对象之间的契约，其目的<code>不是</code>让一个对象依赖另一个对象，<code>而是</code>依赖一个对象的能力。<br><code>接口</code>把我们的代码和依赖<code>解耦</code>了，而且允许我们的代码任何实现了预期接口的第三方代码。我们不管第三方代码是如何实现接口的，只关心第三方代码是否实现了指定的接口。</p>\n</blockquote>\n<hr>\n<p>定义一个<code>DocumentStore</code>类<br>作用是从不同的源收集文本：可以从远程URL读取HTML，也可以读取流资源，也可以收集终端的输出</p>\n<pre><code>class DocumentStore \n{\n    protected $data = [];\n\n    public function addDocument(Documentable $document)\n    {\n        $key   = $document-&gt;getId();\n        $value = $document-&gt;getContent();\n        $this-&gt;data[$key] = $value;\n    }\n\n    public function getDocuments()\n    {\n        return $this-&gt;data;\n    }    \n}\n</code></pre><p>定义<code>Documentable</code>接口</p>\n<pre><code>interface Documentable\n{\n    public function getId();\n    public function getContent();\n}\n</code></pre><p>这个<code>接口</code>的定义表明，实现<code>Documentable</code>接口的任何对象必须提供一个公开的<code>getId()</code>和<code>getContent()</code>方法</p>\n<p>这么做的用处是，我们可以分开定义获取文档的类，而且使用十分不同的实现方法</p>\n<pre><code>//使用curl从远程URL获取HTML\nclass HtmlDocument implements Documentable\n{\n    protected $url;\n\n    public function __construct($url)\n    {\n        $this-&gt;url = $url;\n    }\n\n    public function getId()\n    {\n        return $this-&gt;url;\n    }\n\n    public function getContent()\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $this-&gt;url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 1);\n        $html = curl_exec($ch);\n        curl_close($ch);\n\n        return $html;\n</code></pre><pre><code>//读取资源流\nclass StreamDocument implements Documentable\n{\n    protected $resource;\n    protected $buffer;\n\n    public function __construct($resource, $buffer = 4096)\n    {\n        $this-&gt;resource = $resource;\n        $this-&gt;buffer = $buffer;\n    }\n\n    public function getId()\n    {\n        return &#39;resource-&#39; . (int)$this-&gt;resource;\n    }\n\n    public function getContent()\n    {\n        $streamContent = &#39;&#39;;\n        rewind($this-&gt;resource);\n        while (feof($this-&gt;resource) == false) {\n            $streamContent .= fread($this-&gt;resource, $this-&gt;buffer);\n        }\n\n        return $streamContent;\n    }\n}\n</code></pre><pre><code>//获取终端命令的执行结果\nclass CommandOutputDocument implements Documentable\n{\n    protected $command;\n\n    public function __construct($command)\n    {\n        $this-&gt;command = $command;\n    }\n\n    public function getId()\n    {\n        return $this-&gt;command;\n    }\n\n    public function getContent()\n    {\n        return shell_exec($this-&gt;command);\n    }\n}\n</code></pre><p>如何借助这三种收集文档的实现方法使用<code>DocumentStore</code>类呢？</p>\n<pre><code>$documentStore = new DocumentStore();\n\n//添加HTML文档\n$htmlDoc = new HtmlDocument(&#39;https://php.net&#39;);\n$documentStore-&gt;addDocument($htmlDoc);\n\n//添加流文档\n$streamDoc = new StreamDocument(&#39;stream.txt&#39;, &#39;rb&#39;);\n$documentStore-&gt;addDocument($streamDoc);\n\n//添加终端命令文档\n$cmdDoc = new CommandOutputDocument(&#39;cat /etc/hosts&#39;);\n$documentStore-&gt;addDocument($cmdDoc);\n\nprint_r($documentStore-&gt;getDocuments());\n</code></pre><p><code>HtmlDocument</code>、<code>StreamDocument</code>、<code>CommandOutputDocument</code>三个类没任何共同点，只是实现了一个接口</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><code>接口</code>是两个PHP对象之间的契约，其目的<code>不是</code>让一个对象依赖另一个对象，<code>而是</code>依赖一个对象的能力。<br><code>接口</code>把我们的代码和依赖<code>解耦</code>了，而且允许我们的代码任何实现了预期接口的第三方代码。我们不管第三方代码是如何实现接口的，只关心第三方代码是否实现了指定的接口。</p>\n</blockquote>\n<hr>\n<p>定义一个<code>DocumentStore</code>类<br>作用是从不同的源收集文本：可以从远程URL读取HTML，也可以读取流资源，也可以收集终端的输出</p>\n<pre><code>class DocumentStore \n{\n    protected $data = [];\n\n    public function addDocument(Documentable $document)\n    {\n        $key   = $document-&gt;getId();\n        $value = $document-&gt;getContent();\n        $this-&gt;data[$key] = $value;\n    }\n\n    public function getDocuments()\n    {\n        return $this-&gt;data;\n    }    \n}\n</code></pre><p>定义<code>Documentable</code>接口</p>\n<pre><code>interface Documentable\n{\n    public function getId();\n    public function getContent();\n}\n</code></pre><p>这个<code>接口</code>的定义表明，实现<code>Documentable</code>接口的任何对象必须提供一个公开的<code>getId()</code>和<code>getContent()</code>方法</p>\n<p>这么做的用处是，我们可以分开定义获取文档的类，而且使用十分不同的实现方法</p>\n<pre><code>//使用curl从远程URL获取HTML\nclass HtmlDocument implements Documentable\n{\n    protected $url;\n\n    public function __construct($url)\n    {\n        $this-&gt;url = $url;\n    }\n\n    public function getId()\n    {\n        return $this-&gt;url;\n    }\n\n    public function getContent()\n    {\n        $ch = curl_init();\n        curl_setopt($ch, CURLOPT_URL, $this-&gt;url);\n        curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n        curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3);\n        curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\n        curl_setopt($ch, CURLOPT_MAXREDIRS, 1);\n        $html = curl_exec($ch);\n        curl_close($ch);\n\n        return $html;\n</code></pre><pre><code>//读取资源流\nclass StreamDocument implements Documentable\n{\n    protected $resource;\n    protected $buffer;\n\n    public function __construct($resource, $buffer = 4096)\n    {\n        $this-&gt;resource = $resource;\n        $this-&gt;buffer = $buffer;\n    }\n\n    public function getId()\n    {\n        return &#39;resource-&#39; . (int)$this-&gt;resource;\n    }\n\n    public function getContent()\n    {\n        $streamContent = &#39;&#39;;\n        rewind($this-&gt;resource);\n        while (feof($this-&gt;resource) == false) {\n            $streamContent .= fread($this-&gt;resource, $this-&gt;buffer);\n        }\n\n        return $streamContent;\n    }\n}\n</code></pre><pre><code>//获取终端命令的执行结果\nclass CommandOutputDocument implements Documentable\n{\n    protected $command;\n\n    public function __construct($command)\n    {\n        $this-&gt;command = $command;\n    }\n\n    public function getId()\n    {\n        return $this-&gt;command;\n    }\n\n    public function getContent()\n    {\n        return shell_exec($this-&gt;command);\n    }\n}\n</code></pre><p>如何借助这三种收集文档的实现方法使用<code>DocumentStore</code>类呢？</p>\n<pre><code>$documentStore = new DocumentStore();\n\n//添加HTML文档\n$htmlDoc = new HtmlDocument(&#39;https://php.net&#39;);\n$documentStore-&gt;addDocument($htmlDoc);\n\n//添加流文档\n$streamDoc = new StreamDocument(&#39;stream.txt&#39;, &#39;rb&#39;);\n$documentStore-&gt;addDocument($streamDoc);\n\n//添加终端命令文档\n$cmdDoc = new CommandOutputDocument(&#39;cat /etc/hosts&#39;);\n$documentStore-&gt;addDocument($cmdDoc);\n\nprint_r($documentStore-&gt;getDocuments());\n</code></pre><p><code>HtmlDocument</code>、<code>StreamDocument</code>、<code>CommandOutputDocument</code>三个类没任何共同点，只是实现了一个接口</p>\n"},{"title":"推荐一款好用的LNMP、LAMP、LANMP一键安装脚本(Linxu)","date":"2017-02-20T22:26:26.000Z","_content":"相信大家自己学习的时候一定是下载**VMware**安装**CentOS**后用**yum**源或其他直接编译方式来安装**PHP的环境**(LAMP、LNMP)，但是会遇到各种各样的问题，比如yum源里面软件版本比较低，想安装更高的版本或者各种依赖没有安装直接编译的时候各种报错(本博就是这样过来的)相信大家都能解决，安装环境是最基本的东西，与其在安装上面浪费很长的时间，不如拿这些时间来研究下软件的配置，So今天推荐一个基本无脑式的[LNMP、LAMP、LANMP一键安装脚本](https://blog.linuxeye.com/31.html)，很好用！","source":"_posts/推荐一款好用的LNMP、LAMP、LANMP一键安装脚本-Linxu.md","raw":"---\ntitle: 推荐一款好用的LNMP、LAMP、LANMP一键安装脚本(Linxu)\ndate: 2017-02-21 06:26:26\ntags:\ncategories:\n- Linux\n---\n相信大家自己学习的时候一定是下载**VMware**安装**CentOS**后用**yum**源或其他直接编译方式来安装**PHP的环境**(LAMP、LNMP)，但是会遇到各种各样的问题，比如yum源里面软件版本比较低，想安装更高的版本或者各种依赖没有安装直接编译的时候各种报错(本博就是这样过来的)相信大家都能解决，安装环境是最基本的东西，与其在安装上面浪费很长的时间，不如拿这些时间来研究下软件的配置，So今天推荐一个基本无脑式的[LNMP、LAMP、LANMP一键安装脚本](https://blog.linuxeye.com/31.html)，很好用！","slug":"推荐一款好用的LNMP、LAMP、LANMP一键安装脚本-Linxu","published":1,"updated":"2018-01-04T02:35:43.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyes70023u8w6t5szwt9u","content":"<p>相信大家自己学习的时候一定是下载<strong>VMware</strong>安装<strong>CentOS</strong>后用<strong>yum</strong>源或其他直接编译方式来安装<strong>PHP的环境</strong>(LAMP、LNMP)，但是会遇到各种各样的问题，比如yum源里面软件版本比较低，想安装更高的版本或者各种依赖没有安装直接编译的时候各种报错(本博就是这样过来的)相信大家都能解决，安装环境是最基本的东西，与其在安装上面浪费很长的时间，不如拿这些时间来研究下软件的配置，So今天推荐一个基本无脑式的<a href=\"https://blog.linuxeye.com/31.html\" target=\"_blank\" rel=\"noopener\">LNMP、LAMP、LANMP一键安装脚本</a>，很好用！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>相信大家自己学习的时候一定是下载<strong>VMware</strong>安装<strong>CentOS</strong>后用<strong>yum</strong>源或其他直接编译方式来安装<strong>PHP的环境</strong>(LAMP、LNMP)，但是会遇到各种各样的问题，比如yum源里面软件版本比较低，想安装更高的版本或者各种依赖没有安装直接编译的时候各种报错(本博就是这样过来的)相信大家都能解决，安装环境是最基本的东西，与其在安装上面浪费很长的时间，不如拿这些时间来研究下软件的配置，So今天推荐一个基本无脑式的<a href=\"https://blog.linuxeye.com/31.html\" target=\"_blank\" rel=\"noopener\">LNMP、LAMP、LANMP一键安装脚本</a>，很好用！</p>\n"},{"title":"整理一个自己知识体系","date":"2017-07-20T13:21:34.000Z","_content":"整理自己一个[知识体系](https://github.com/a330202207/MySummary)，慢慢完善\n![](http://olln3wpar.bkt.clouddn.com/image/MySummaryIMG_2846.JPG)\n","source":"_posts/整理一个自己知识体系.md","raw":"---\ntitle: 整理一个自己知识体系\ndate: 2017-07-20 21:21:34\ncategories:\n- PHP\n---\n整理自己一个[知识体系](https://github.com/a330202207/MySummary)，慢慢完善\n![](http://olln3wpar.bkt.clouddn.com/image/MySummaryIMG_2846.JPG)\n","slug":"整理一个自己知识体系","published":1,"updated":"2018-01-04T01:37:41.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyesd0027u8w6vf3wg3ma","content":"<p>整理自己一个<a href=\"https://github.com/a330202207/MySummary\" target=\"_blank\" rel=\"noopener\">知识体系</a>，慢慢完善<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MySummaryIMG_2846.JPG\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>整理自己一个<a href=\"https://github.com/a330202207/MySummary\" target=\"_blank\" rel=\"noopener\">知识体系</a>，慢慢完善<br><img src=\"http://olln3wpar.bkt.clouddn.com/image/MySummaryIMG_2846.JPG\" alt=\"\"></p>\n"},{"title":"解决向github提交代码不用输入帐号密码","date":"2017-03-07T02:22:50.000Z","_content":"\n缘由：每次向github提交代码时都要输入用户名密码，每次都是啊, 这也太麻烦了，影响效率\n解决方案：\n\n**方案一：**\n\n 1. 在你的用户目录下新建一个文本文件`.git-credentials`\n    * `Windows`：`C:/Users/username`\n    * `Mac OS X`： `/Users/username`\n    * `Linux`： `/home/username`\n    注意：鼠标右键新建文件`重复命名`是成功不了的，需要借助`Sublime`等`IDE`工具来创建文件。\n 2. `.git-credentials`在文件中输入以下内容：\n    ```\n    https:{username}:{password}@github.com\n    \n    ```\n    `{username}`和`{password}`是你的`github`的`账号`和`密码`\n 3. 修改`git`配置\n    执行命令：`git config --global credential.helper store`\n    上述命令会在`.gitconfig`文件(`.gitconfig`与`.git-credentials`在同目录下)末尾添加如下配置:\n\n![此处输入图片的描述][1]\n经过上述三步配置之后, 你push代码到github时, 便无需再输入用户名密码了\n  \n\n **方案二：**\n\n 1. 在命令行输入命令:\n    ```\n    git config --global credential.helper store\n    ```\n    这一步会在用户目录下的.gitconfig文件最后添加：\n    ```\n    [credential]\n\t    helper = store\n    ```\n    \n 2. push 代码\n`push`你的代码 (`git push`), 这时会让你输入`用户名`和`密码`, 这一步输入的用户名密码会被`记住`, 下次再push代码时就不用输入用户名密码!这一步会在用户目录下生成文件`.git-credential`记录用户名密码的信息。\n\n**总结：**\n方案一与方案二都是创建`.git-credential`文件并写入用户信息，一个是手动创建，一个命令创建。\n\n  [1]: http://olln3wpar.bkt.clouddn.com/git_1.png","source":"_posts/解决向github提交代码不用输入帐号密码.md","raw":"---\ntitle: 解决向github提交代码不用输入帐号密码\ndate: 2017-03-07 10:22:50\ncategories:\n- Git\n---\n\n缘由：每次向github提交代码时都要输入用户名密码，每次都是啊, 这也太麻烦了，影响效率\n解决方案：\n\n**方案一：**\n\n 1. 在你的用户目录下新建一个文本文件`.git-credentials`\n    * `Windows`：`C:/Users/username`\n    * `Mac OS X`： `/Users/username`\n    * `Linux`： `/home/username`\n    注意：鼠标右键新建文件`重复命名`是成功不了的，需要借助`Sublime`等`IDE`工具来创建文件。\n 2. `.git-credentials`在文件中输入以下内容：\n    ```\n    https:{username}:{password}@github.com\n    \n    ```\n    `{username}`和`{password}`是你的`github`的`账号`和`密码`\n 3. 修改`git`配置\n    执行命令：`git config --global credential.helper store`\n    上述命令会在`.gitconfig`文件(`.gitconfig`与`.git-credentials`在同目录下)末尾添加如下配置:\n\n![此处输入图片的描述][1]\n经过上述三步配置之后, 你push代码到github时, 便无需再输入用户名密码了\n  \n\n **方案二：**\n\n 1. 在命令行输入命令:\n    ```\n    git config --global credential.helper store\n    ```\n    这一步会在用户目录下的.gitconfig文件最后添加：\n    ```\n    [credential]\n\t    helper = store\n    ```\n    \n 2. push 代码\n`push`你的代码 (`git push`), 这时会让你输入`用户名`和`密码`, 这一步输入的用户名密码会被`记住`, 下次再push代码时就不用输入用户名密码!这一步会在用户目录下生成文件`.git-credential`记录用户名密码的信息。\n\n**总结：**\n方案一与方案二都是创建`.git-credential`文件并写入用户信息，一个是手动创建，一个命令创建。\n\n  [1]: http://olln3wpar.bkt.clouddn.com/git_1.png","slug":"解决向github提交代码不用输入帐号密码","published":1,"updated":"2018-01-03T02:05:08.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbzyyesg002au8w6wecz3d64","content":"<p>缘由：每次向github提交代码时都要输入用户名密码，每次都是啊, 这也太麻烦了，影响效率<br>解决方案：</p>\n<p><strong>方案一：</strong></p>\n<ol>\n<li>在你的用户目录下新建一个文本文件<code>.git-credentials</code><ul>\n<li><code>Windows</code>：<code>C:/Users/username</code></li>\n<li><code>Mac OS X</code>： <code>/Users/username</code></li>\n<li><code>Linux</code>： <code>/home/username</code><br>注意：鼠标右键新建文件<code>重复命名</code>是成功不了的，需要借助<code>Sublime</code>等<code>IDE</code>工具来创建文件。</li>\n</ul>\n</li>\n<li><p><code>.git-credentials</code>在文件中输入以下内容：</p>\n<pre><code>https:{username}:{password}@github.com\n</code></pre><p><code>{username}</code>和<code>{password}</code>是你的<code>github</code>的<code>账号</code>和<code>密码</code></p>\n</li>\n<li>修改<code>git</code>配置<br>执行命令：<code>git config --global credential.helper store</code><br>上述命令会在<code>.gitconfig</code>文件(<code>.gitconfig</code>与<code>.git-credentials</code>在同目录下)末尾添加如下配置:</li>\n</ol>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/git_1.png\" alt=\"此处输入图片的描述\"><br>经过上述三步配置之后, 你push代码到github时, 便无需再输入用户名密码了</p>\n<p> <strong>方案二：</strong></p>\n<ol>\n<li><p>在命令行输入命令:</p>\n<pre><code>git config --global credential.helper store\n</code></pre><p>这一步会在用户目录下的.gitconfig文件最后添加：</p>\n<pre><code>[credential]\n    helper = store\n</code></pre></li>\n<li><p>push 代码<br><code>push</code>你的代码 (<code>git push</code>), 这时会让你输入<code>用户名</code>和<code>密码</code>, 这一步输入的用户名密码会被<code>记住</code>, 下次再push代码时就不用输入用户名密码!这一步会在用户目录下生成文件<code>.git-credential</code>记录用户名密码的信息。</p>\n</li>\n</ol>\n<p><strong>总结：</strong><br>方案一与方案二都是创建<code>.git-credential</code>文件并写入用户信息，一个是手动创建，一个命令创建。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>缘由：每次向github提交代码时都要输入用户名密码，每次都是啊, 这也太麻烦了，影响效率<br>解决方案：</p>\n<p><strong>方案一：</strong></p>\n<ol>\n<li>在你的用户目录下新建一个文本文件<code>.git-credentials</code><ul>\n<li><code>Windows</code>：<code>C:/Users/username</code></li>\n<li><code>Mac OS X</code>： <code>/Users/username</code></li>\n<li><code>Linux</code>： <code>/home/username</code><br>注意：鼠标右键新建文件<code>重复命名</code>是成功不了的，需要借助<code>Sublime</code>等<code>IDE</code>工具来创建文件。</li>\n</ul>\n</li>\n<li><p><code>.git-credentials</code>在文件中输入以下内容：</p>\n<pre><code>https:{username}:{password}@github.com\n</code></pre><p><code>{username}</code>和<code>{password}</code>是你的<code>github</code>的<code>账号</code>和<code>密码</code></p>\n</li>\n<li>修改<code>git</code>配置<br>执行命令：<code>git config --global credential.helper store</code><br>上述命令会在<code>.gitconfig</code>文件(<code>.gitconfig</code>与<code>.git-credentials</code>在同目录下)末尾添加如下配置:</li>\n</ol>\n<p><img src=\"http://olln3wpar.bkt.clouddn.com/git_1.png\" alt=\"此处输入图片的描述\"><br>经过上述三步配置之后, 你push代码到github时, 便无需再输入用户名密码了</p>\n<p> <strong>方案二：</strong></p>\n<ol>\n<li><p>在命令行输入命令:</p>\n<pre><code>git config --global credential.helper store\n</code></pre><p>这一步会在用户目录下的.gitconfig文件最后添加：</p>\n<pre><code>[credential]\n    helper = store\n</code></pre></li>\n<li><p>push 代码<br><code>push</code>你的代码 (<code>git push</code>), 这时会让你输入<code>用户名</code>和<code>密码</code>, 这一步输入的用户名密码会被<code>记住</code>, 下次再push代码时就不用输入用户名密码!这一步会在用户目录下生成文件<code>.git-credential</code>记录用户名密码的信息。</p>\n</li>\n</ol>\n<p><strong>总结：</strong><br>方案一与方案二都是创建<code>.git-credential</code>文件并写入用户信息，一个是手动创建，一个命令创建。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjbzyyeoy0000u8w6hdal84m9","category_id":"cjbzyyepe0002u8w69y5xacqj","_id":"cjbzyyeqd000du8w69x54d981"},{"post_id":"cjbzyyep60001u8w6l0ssi6x7","category_id":"cjbzyyepe0002u8w69y5xacqj","_id":"cjbzyyeqn000iu8w65n94n20w"},{"post_id":"cjbzyyepi0004u8w6wn2lupuk","category_id":"cjbzyyepe0002u8w69y5xacqj","_id":"cjbzyyeqr000ou8w66iufwbat"},{"post_id":"cjbzyyepl0005u8w61yqerdmh","category_id":"cjbzyyeqm000hu8w6616zipyu","_id":"cjbzyyeqz000vu8w68mn5u0sc"},{"post_id":"cjbzyyepu0006u8w6rivqvxmk","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyer60013u8w6yni31jia"},{"post_id":"cjbzyyeq1000au8w6n43p2mqc","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyerd0018u8w6lir47kpx"},{"post_id":"cjbzyyeqb000bu8w6dgmjd6dy","category_id":"cjbzyyer50012u8w6p1g01goe","_id":"cjbzyyerm001gu8w674t6wgyv"},{"post_id":"cjbzyyeqh000fu8w6r6wv7dzg","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyert001mu8w6qm074r88"},{"post_id":"cjbzyyerj001du8w6jm4by46f","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyerv001pu8w63corzq3l"},{"post_id":"cjbzyyerm001hu8w6rtqckdpr","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyerz001tu8w6exjmens6"},{"post_id":"cjbzyyeql000gu8w6n437mapx","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyes1001vu8w63u6ydjol"},{"post_id":"cjbzyyerr001ju8w6637c45ln","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyes4001zu8w6ohdqjtg5"},{"post_id":"cjbzyyeqp000lu8w6beyslnsn","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyes70022u8w6knd4r4hf"},{"post_id":"cjbzyyerz001uu8w6vze25s7m","category_id":"cjbzyyepe0002u8w69y5xacqj","_id":"cjbzyyesc0026u8w6xxhdt63y"},{"post_id":"cjbzyyeqq000nu8w6gikdr826","category_id":"cjbzyyeqs000pu8w6f719cyap","_id":"cjbzyyesf0029u8w63y1at1qc"},{"post_id":"cjbzyyes1001wu8w6lugj292z","category_id":"cjbzyyepe0002u8w69y5xacqj","_id":"cjbzyyesi002bu8w6fzzwrs9j"},{"post_id":"cjbzyyequ000su8w64kr7675v","category_id":"cjbzyyer50012u8w6p1g01goe","_id":"cjbzyyesj002du8w6rpqyxx77"},{"post_id":"cjbzyyes70023u8w6t5szwt9u","category_id":"cjbzyyepe0002u8w69y5xacqj","_id":"cjbzyyesj002eu8w616o3aliy"},{"post_id":"cjbzyyesg002au8w6wecz3d64","category_id":"cjbzyyeqm000hu8w6616zipyu","_id":"cjbzyyesk002gu8w6h4ofuf3o"},{"post_id":"cjbzyyeqx000uu8w64fsa29p6","category_id":"cjbzyyesc0025u8w6drezpx8t","_id":"cjbzyyesl002hu8w6w9n78ig2"},{"post_id":"cjbzyyer1000zu8w6i3tpbno2","category_id":"cjbzyyesc0025u8w6drezpx8t","_id":"cjbzyyesm002ju8w6l07g2j69"},{"post_id":"cjbzyyer40011u8w6ow85vka3","category_id":"cjbzyyesc0025u8w6drezpx8t","_id":"cjbzyyesm002lu8w6pzpns6yr"},{"post_id":"cjbzyyer70015u8w6d5h9tqk7","category_id":"cjbzyyesc0025u8w6drezpx8t","_id":"cjbzyyesn002nu8w6zoab04yy"},{"post_id":"cjbzyyera0017u8w6tco7kq56","category_id":"cjbzyyesc0025u8w6drezpx8t","_id":"cjbzyyesp002pu8w67chby1m4"},{"post_id":"cjbzyyerf001bu8w6bk5xy1sb","category_id":"cjbzyyesc0025u8w6drezpx8t","_id":"cjbzyyesr002ru8w6lpppolir"},{"post_id":"cjbzyyes40020u8w6wjbpn6xq","category_id":"cjbzyyesc0025u8w6drezpx8t","_id":"cjbzyyest002su8w6t3i0zr51"},{"post_id":"cjbzyyesd0027u8w6vf3wg3ma","category_id":"cjbzyyesc0025u8w6drezpx8t","_id":"cjbzyyest002tu8w6eyxrdnry"}],"PostTag":[{"post_id":"cjbzyyeoy0000u8w6hdal84m9","tag_id":"cjbzyyeph0003u8w6dlrdy664","_id":"cjbzyyeq00009u8w6uz5nucy0"},{"post_id":"cjbzyyeqh000fu8w6r6wv7dzg","tag_id":"cjbzyyepv0008u8w6a2unghnk","_id":"cjbzyyeqo000ku8w6m6k58tg9"},{"post_id":"cjbzyyep60001u8w6l0ssi6x7","tag_id":"cjbzyyepv0008u8w6a2unghnk","_id":"cjbzyyeqq000mu8w618tkaa8u"},{"post_id":"cjbzyyep60001u8w6l0ssi6x7","tag_id":"cjbzyyeph0003u8w6dlrdy664","_id":"cjbzyyequ000ru8w63fk5j8ve"},{"post_id":"cjbzyyeql000gu8w6n437mapx","tag_id":"cjbzyyepv0008u8w6a2unghnk","_id":"cjbzyyeqx000tu8w6hqh0aqbe"},{"post_id":"cjbzyyeqp000lu8w6beyslnsn","tag_id":"cjbzyyepv0008u8w6a2unghnk","_id":"cjbzyyer0000yu8w6wnj81r5r"},{"post_id":"cjbzyyepi0004u8w6wn2lupuk","tag_id":"cjbzyyeph0003u8w6dlrdy664","_id":"cjbzyyer40010u8w6nqwggj25"},{"post_id":"cjbzyyeqq000nu8w6gikdr826","tag_id":"cjbzyyepv0008u8w6a2unghnk","_id":"cjbzyyer60014u8w6defb4gkz"},{"post_id":"cjbzyyepu0006u8w6rivqvxmk","tag_id":"cjbzyyeqs000qu8w6197zc45i","_id":"cjbzyyer80016u8w6gws5of95"},{"post_id":"cjbzyyepu0006u8w6rivqvxmk","tag_id":"cjbzyyeph0003u8w6dlrdy664","_id":"cjbzyyere0019u8w6bb9v86b3"},{"post_id":"cjbzyyeq1000au8w6n43p2mqc","tag_id":"cjbzyyeqs000qu8w6197zc45i","_id":"cjbzyyerj001cu8w6p4b3zltz"},{"post_id":"cjbzyyeq1000au8w6n43p2mqc","tag_id":"cjbzyyeph0003u8w6dlrdy664","_id":"cjbzyyerk001eu8w6g44emfpj"},{"post_id":"cjbzyyerj001du8w6jm4by46f","tag_id":"cjbzyyeqs000qu8w6197zc45i","_id":"cjbzyyerq001iu8w6q73411gy"},{"post_id":"cjbzyyerm001hu8w6rtqckdpr","tag_id":"cjbzyyeqs000qu8w6197zc45i","_id":"cjbzyyers001ku8w6ncxh0ffg"},{"post_id":"cjbzyyerr001ju8w6637c45ln","tag_id":"cjbzyyeqs000qu8w6197zc45i","_id":"cjbzyyerv001ou8w68e85ukhi"},{"post_id":"cjbzyyerz001uu8w6vze25s7m","tag_id":"cjbzyyeph0003u8w6dlrdy664","_id":"cjbzyyes3001xu8w6xmjl576z"},{"post_id":"cjbzyyes1001wu8w6lugj292z","tag_id":"cjbzyyeqs000qu8w6197zc45i","_id":"cjbzyyes60021u8w6ytg95u77"},{"post_id":"cjbzyyes1001wu8w6lugj292z","tag_id":"cjbzyyeph0003u8w6dlrdy664","_id":"cjbzyyesc0024u8w6htwlcq4v"},{"post_id":"cjbzyyeru001nu8w6crk502yb","tag_id":"cjbzyyery001ru8w6kcce0460","_id":"cjbzyyesf0028u8w6xequ4zf6"}],"Tag":[{"name":"yum","_id":"cjbzyyeph0003u8w6dlrdy664"},{"name":"MongoDB","_id":"cjbzyyepv0008u8w6a2unghnk"},{"name":"Redis","_id":"cjbzyyeqs000qu8w6197zc45i"},{"name":"Sublime","_id":"cjbzyyery001ru8w6kcce0460"}]}}